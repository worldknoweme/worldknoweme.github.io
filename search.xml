<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[第四节css基础（一）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%9B%9B%E8%8A%82css%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>css是一种html样式标记语言,使用css可以对html的样式进行快速精准的修改和实现.<br>使用css语言有哪些好处呢?<br>下面,通过举例比较一下使用css和不使用css的区别.<br>需求:我们有一个表格,要求给所以表格添加背景色.</p>
<h2 id="不使用css"><a href="#不使用css" class="headerlink" title="不使用css"></a>不使用css</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">  &lt;tr &gt;</span><br><span class="line">      &lt;td bgcolor=&quot;gray&quot; &gt;1&lt;/td&gt;</span><br><span class="line">      &lt;td bgcolor=&quot;gray&quot;&gt;2&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">      &lt;td  bgcolor=&quot;gray&quot;&gt;3&lt;/td&gt;</span><br><span class="line">      &lt;td  bgcolor=&quot;gray&quot;&gt;4&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">      &lt;td  bgcolor=&quot;gray&quot;&gt;a&lt;/td&gt;</span><br><span class="line">      &lt;td  bgcolor=&quot;gray&quot;&gt;b&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用css"><a href="#使用css" class="headerlink" title="使用css"></a>使用css</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">td&#123;</span><br><span class="line">  background-color:gray;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">  &lt;tr &gt;</span><br><span class="line">      &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;2&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;3&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;a&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;b&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出css带来的作用和优势了吗?</p>
<h1 id="css语法"><a href="#css语法" class="headerlink" title="css语法"></a>css语法</h1><p>使用style标签进行包围,之后在style标签内便可以进行样式的定义了.<br>样式的语法如下:<br>selector {property: value}<br>即 选择器{属性:属性值}<br>举例:<br>将输入的所有元素字体颜色改为红色.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">   color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;这是一个P&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这是一个P&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这是一个P&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这是一个P&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>当然,我们也可以通过标签的style属性,进行css样式的定义,目前几乎所有的标签都支持style属性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color:red&quot;&gt;这是style为红色的&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这是一个没有style的p&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p> <strong>元素选择器</strong><br>以标签名进行对应标签的选择,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;p元素&lt;/p&gt;</span><br><span class="line">&lt;p&gt;p元素&lt;/p&gt;</span><br><span class="line">&lt;p&gt;p元素&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>所有p元素的字体颜色都变为了红色.</p>
<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>使用#id{}的格式进行指定id元素的样式修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line">#p1&#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br><span class="line">#p2&#123;</span><br><span class="line">  color:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;没有id的p&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;id=p1的p&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;p2&quot;&gt;id=p2的p&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>这是css最常用的写法.<br>.类名{}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.pre&#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br><span class="line">.after&#123;</span><br><span class="line">  color:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p class=&quot;pre&quot;&gt;前3个&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;pre&quot;&gt;前3个&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;pre&quot;&gt;前3个&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;after&quot;&gt;后3个&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;after&quot;&gt;后3个&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;after&quot;&gt;后3个&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h2 id="深入选择器"><a href="#深入选择器" class="headerlink" title="深入选择器"></a>深入选择器</h2><p>当然还可以进行任意组合选择,使选择结果更加精确,比如使用元素+class来选择.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p.blue&#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p class=&quot;blue&quot;&gt;class=blue的p&lt;/p&gt;</span><br><span class="line">&lt;span class=&quot;blue&quot;&gt;class=blue的span&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>/**/格式来进行注释</p>
]]></content>
      
        <categories>
            
            <category> web基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第三节html基础（二）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%89%E8%8A%82html%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><p>阶段性效果<br><img src="https://images.gitee.com/uploads/images/2018/0910/102342_b2fed50f_87680.png" alt="输入图片说明" title="2018-09-10 10-23-35屏幕截图.png"><br>想要实现以上的效果,需要如下元素:<br>文本框input type=text<br>密码框-&gt;password<br>表单 form 提交元素到后台<br>单选框-&gt;radio<br>复选框-&gt;checkbox<br>下拉列表 select option  默认选中selected 可多选 multiple 设置高度size<br>文本域 textarea cols rows<br>普通按钮 button<br>提交按钮 submit<br>重置按钮 reset<br>图像提交 type=image<br>按钮 button 比input更加丰富,在标签内定义图片  </p>
<pre><code>&lt;button&gt;&lt;img src=&quot;http://how2j.cn/example.gif&quot;/&gt;&lt;/button&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> web基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第二节html基础（一）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%BA%8C%E8%8A%82html%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3><p> 打印一个helloworl的网页.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">```  </span><br><span class="line">### 开发工具  </span><br><span class="line">我们使用idea进行html网页的开发.  </span><br><span class="line">使用chrome进行网页的最终调试.  </span><br><span class="line">### 中文编码  </span><br><span class="line">我们在html网页最顶端进行了编码格式的声明,具体内容如下:</span><br></pre></td></tr></table></figure>
<p><meta charset="UTF-8"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">这里指定我们网页使用utf8编码格式  </span><br><span class="line">### html标签</span><br><span class="line">标签由开始标签和结束标签组成   </span><br><span class="line">其中上文提到的p标签就是html给定的一个标准标签.  </span><br><span class="line">我们对html的学习,主要就是学习标准标签的一些常见用法.  </span><br><span class="line">### html元素  </span><br><span class="line">html元素指的是从开始标签到结束标签以及其中所以的内容.  </span><br><span class="line">上文写的html中p标签以及其中包裹的信息统称为一个p元素  </span><br><span class="line"> **完整html**  </span><br><span class="line">应该至少包含html元素，body元素，以及里面的内容  </span><br><span class="line"> **不完整的元素**</span><br><span class="line">比如:  </span><br><span class="line">`&lt;h1&gt;aaaaa`  </span><br><span class="line">上述代码也是可以正常显示的.当然,这里能正常显示并不是因为你写的代码多么牛逼,主要是因为如今的浏览器都非常强大.  </span><br><span class="line">强大到什么程度呢?可以允许适度的代码错误,即便是非标准的,不完整的元素也可以保证其正常显示.  </span><br><span class="line">  </span><br><span class="line"> **特殊元素**  </span><br><span class="line">`&lt;br/&gt;表示换行`  </span><br><span class="line">`&lt;hr&gt;表示间隔线.`  </span><br><span class="line">### 属性  </span><br><span class="line">修饰标签的特定字符即属性.  </span><br><span class="line">比如:  </span><br><span class="line">`&lt;h1 align=&quot;center&quot;&gt;居中标题&lt;/h1&gt;`  </span><br><span class="line">其中h1标签里面align表示属性,代码其中的元素居中的意思.  </span><br><span class="line">### 注释  </span><br><span class="line">使用`&lt;!----&gt;`进行注释  </span><br><span class="line">### 基本元素  </span><br><span class="line">基本元素一,我们计划实现一下的效果:  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0910/095035_de454082_87680.png &quot;2018-09-10 09-50-25屏幕截图.png&quot;)   </span><br><span class="line">百度百科搜索java.  </span><br><span class="line">为了实现以上效果,我们需要了解html如下的基本元素:  </span><br><span class="line">标题/段落/粗体/斜体/预格式/删除效果/下划线,分别对应的标签为:  </span><br><span class="line">&lt;h1&gt;-&lt;h5&gt;  </span><br><span class="line">&lt;p&gt;  </span><br><span class="line">&lt;b&gt;&lt;strong&gt;  </span><br><span class="line">&lt;i&gt;&lt;em&gt;  </span><br><span class="line">&lt;pre&gt;  即一些特定的格式,代码格式</span><br></pre></td></tr></table></figure></p>
<p><pre><br>public class HelloWorld {</pre></p>
<pre><code>public static void main(String[] args) {
    System.out.println(&quot;Hello World&quot;);
}
</code></pre><p>}</p>
<p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">del    </span><br><span class="line">ins    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### 阶段练习二  </span><br><span class="line"></span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0910/100407_1c573031_87680.png &quot;2018-09-10 10-03-45屏幕截图.png&quot;)   </span><br><span class="line"> </span><br><span class="line">实现上述效果,需要用到如下元素.  </span><br><span class="line">图像/超链接/表格/列表/块div span/字体/内联框架  </span><br><span class="line">分别对应的标签为:  </span><br><span class="line">img src   </span><br><span class="line">a href  </span><br><span class="line">table tr td  </span><br><span class="line">ul li 无序   </span><br><span class="line">ol li 有序    </span><br><span class="line">div span  </span><br><span class="line">font color size  关于颜色,可以使用取色器,推荐好色鬼  </span><br><span class="line">iframe</span><br></pre></td></tr></table></figure></p>
<p><iframe src="http://www.baidu.com/" width="600px" height="400px"><br></iframe><br>```  </p>
]]></content>
      
        <categories>
            
            <category> web基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第一节web基础]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%80%E8%8A%82web%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="基础问答"><a href="#基础问答" class="headerlink" title="基础问答"></a>基础问答</h3><p>javaee是什么?<br>web是什么?<br>java和web存在什么关系?  </p>
]]></content>
      
        <categories>
            
            <category> web基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十七节java的部署与打包]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E4%B8%83%E8%8A%82java%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="java文件的打包"><a href="#java文件的打包" class="headerlink" title="java文件的打包"></a>java文件的打包</h3><p>将项目打包成为jar文件.<br>步骤如下:  </p>
<ol>
<li>所在项目上面右键,选择Open Module Settings  </li>
<li>选择Artifactes<br><img src="https://images.gitee.com/uploads/images/2018/0908/102848_30fdaf4f_87680.png" alt="输入图片说明" title="2018-09-08 10-28-11屏幕截图.png">  </li>
<li>选择增加一个打包功能,左上方的加号按钮,之后选择jar-&gt;from modules with depen..<br><img src="https://images.gitee.com/uploads/images/2018/0908/102954_0fb7e32c_87680.png" alt="输入图片说明" title="2018-09-08 10-29-46屏幕截图.png"><br>mainclass位置输入对于的主函数,点击保存即可.  </li>
<li>选择build -&gt; Build Artifacts即可.  </li>
</ol>
<h3 id="jar文件的执行"><a href="#jar文件的执行" class="headerlink" title="jar文件的执行"></a>jar文件的执行</h3><p>使用java命令执行jar包即可.<br>执行方法为:java -jar 指定jar包  </p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十六节java的集合]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%8A%82java%E7%9A%84%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h3 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h3><p> <strong>ArrayList</strong><br>回忆问题:  </p>
<ol>
<li>数据和list的区别是什么?  </li>
<li>arraylist是如何存放对象的,又是如何遍历对象的?<br>arraylist的常用方法:<br><img src="https://images.gitee.com/uploads/images/2018/0907/192006_4d4af984_87680.png" alt="输入图片说明" title="2018-09-07 19-19-55屏幕截图.png"><br>尝试练习常用方法.<br><strong>问题:arraylist和list的区别?</strong><br><em>遍历list对象的话,其实还有另外一种遍历的方式,叫做迭代器遍历</em><br>迭代器,即Iterator.<br><img src="https://images.gitee.com/uploads/images/2018/0907/192225_a4028e0c_87680.png" alt="输入图片说明" title="2018-09-07 19-22-18屏幕截图.png"><br>迭代器进行遍历的示例代码:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package collection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestCollection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();</span><br><span class="line">         </span><br><span class="line">        //放5个Hero进入容器</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero name &quot; +i));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //第二种遍历，使用迭代器</span><br><span class="line">        System.out.println(&quot;--------使用while的iterator-------&quot;);</span><br><span class="line">        Iterator&lt;Hero&gt; it= heros.iterator();</span><br><span class="line">        //从最开始的位置判断&quot;下一个&quot;位置是否有数据</span><br><span class="line">        //如果有就通过next取出来，并且把指针向下移动</span><br><span class="line">        //直到&quot;下一个&quot;位置没有数据</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Hero h = it.next();</span><br><span class="line">            System.out.println(h);</span><br><span class="line">        &#125;</span><br><span class="line">        //迭代器的for写法</span><br><span class="line">        System.out.println(&quot;--------使用for的iterator-------&quot;);</span><br><span class="line">        for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            Hero hero = (Hero) iterator.next();</span><br><span class="line">            System.out.println(hero);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> _常见问题:假如我现在有这样一个需求,我现在有一个string类型的arraylist,里面存放的是学生姓名.如何将该arraylist指定的学生姓名删除掉呢?_  </span><br><span class="line"> **LinkedList**  </span><br><span class="line">可以将LinkedList当做Arraylist的一个扩展,他除了用于ArrayList的常用功能外,还具有其特殊的高效方法.  </span><br><span class="line">其主要的高效方法如下:  </span><br><span class="line">1. 作为一个双向的链表,可以在其头部和尾部方便的插入和删除元素,该类存在其特殊方法.  </span><br><span class="line">2. 可以作为队列,使用其提供的三个特殊方法offer在最后添加元素/poll取出第一个元素/peek查看第一个元素</span><br><span class="line"></span><br><span class="line">实例代码如下:  </span><br><span class="line">作为双向链表:</span><br></pre></td></tr></table></figure>
<p>package collection;</p>
<p>import java.util.LinkedList;</p>
<p>import charactor.Hero;</p>
<p>public class TestCollection {</p>
<pre><code>public static void main(String[] args) {

    //LinkedList是一个双向链表结构的list
    LinkedList&lt;Hero&gt; ll =new LinkedList&lt;Hero&gt;();

    //所以可以很方便的在头部和尾部插入数据
    //在最后插入新的英雄
    ll.addLast(new Hero(&quot;hero1&quot;));
    ll.addLast(new Hero(&quot;hero2&quot;));
    ll.addLast(new Hero(&quot;hero3&quot;));
    System.out.println(ll);

    //在最前面插入新的英雄
    ll.addFirst(new Hero(&quot;heroX&quot;));
    System.out.println(ll);

    //查看最前面的英雄
    System.out.println(ll.getFirst());
    //查看最后面的英雄
    System.out.println(ll.getLast());

    //查看不会导致英雄被删除
    System.out.println(ll);
    //取出最前面的英雄
    System.out.println(ll.removeFirst());

    //取出最后面的英雄
    System.out.println(ll.removeLast());

    //取出会导致英雄被删除
    System.out.println(ll);

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例代码:</span><br><span class="line">作为队列:</span><br></pre></td></tr></table></figure></p>
<p>package collection;</p>
<p>import java.util.LinkedList;<br>import java.util.List;<br>import java.util.Queue;</p>
<p>import charactor.Hero;</p>
<p>public class TestCollection {</p>
<pre><code>public static void main(String[] args) {
    //和ArrayList一样，LinkedList也实现了List接口
    List ll =new LinkedList&lt;Hero&gt;();

    //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
    //Queue代表FIFO 先进先出的队列
    Queue&lt;Hero&gt; q= new LinkedList&lt;Hero&gt;();

    //加在队列的最后面
    System.out.print(&quot;初始化队列：\t&quot;);
    q.offer(new Hero(&quot;Hero1&quot;));
    q.offer(new Hero(&quot;Hero2&quot;));
    q.offer(new Hero(&quot;Hero3&quot;));
    q.offer(new Hero(&quot;Hero4&quot;));

    System.out.println(q);
    System.out.print(&quot;把第一个元素取poll()出来:\t&quot;);
    //取出第一个Hero，FIFO 先进先出
    Hero h = q.poll();
    System.out.println(h);
    System.out.print(&quot;取出第一个元素之后的队列:\t&quot;);
    System.out.println(q);

    //把第一个拿出来看一看，但是不取出来
    h=q.peek();
    System.out.print(&quot;查看peek()第一个元素:\t&quot;);
    System.out.println(h);
    System.out.print(&quot;查看并不会导致第一个元素被取出来:\t&quot;);
    System.out.println(q);

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### HashMap  </span><br><span class="line">之前学过hashmap进行键值对的存放.  </span><br><span class="line">现在拓展一下,便利一下map,将其键值对,键和值全部都输出出来.</span><br></pre></td></tr></table></figure></p>
<p>Map<integer, integer=""> map = new HashMap<integer, integer="">();<br>Iterator<map.entry<integer, integer="">&gt; entries = map.entrySet().iterator();<br>while (entries.hasNext()) {<br>  Map.Entry<integer, integer=""> entry = entries.next();<br>  System.out.println(“Key = “ + entry.getKey() + “, Value = “ + entry.getValue());<br>}<br>```</integer,></map.entry<integer,></integer,></integer,></p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十五节多线程简介]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E4%BA%94%E8%8A%82%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓多线程就是在同一时间,可以做多件事情.<br>创建多线程主要有三种方式,分别为:  </p>
<ol>
<li>继承线程类  </li>
<li>实现runnable接口  </li>
<li>匿名类<br>首先,明确线程概念.了解线程概念之前需要搞清楚进程的概念.<br><strong>进程：</strong>启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。<br><strong>线程：</strong>线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如”盖伦” 击杀“提莫”，同时“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。<br>一个非多线程的例子:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import java.io.Serializable;</span><br><span class="line">  </span><br><span class="line">public class Hero&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">     </span><br><span class="line">    public int damage;</span><br><span class="line">     </span><br><span class="line">    public void attackHero(Hero h) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //为了表示攻击需要时间，每次攻击暂停1000毫秒</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        h.hp-=damage;</span><br><span class="line">        System.out.format(&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;,name,h.name,h.name,h.hp);</span><br><span class="line">         </span><br><span class="line">        if(h.isDead())</span><br><span class="line">            System.out.println(h.name +&quot;死了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        return 0&gt;=hp?true:false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">模拟测试类:</span><br></pre></td></tr></table></figure>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 616;
    gareen.damage = 50;

    Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 300;
    teemo.damage = 30;

    Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 500;
    bh.damage = 65;

    Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 455;
    leesin.damage = 80;

    //盖伦攻击提莫
    while(!teemo.isDead()){
        gareen.attackHero(teemo);
    }

    //赏金猎人攻击盲僧
    while(!leesin.isDead()){
        bh.attackHero(leesin);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上述代码,我们会发现,盖伦在攻击完提莫之后,赏金猎人才会攻击盲僧.  </span><br><span class="line"> **多线程的形式进行攻击**</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class KillThread extends Thread{</p>
<pre><code>private Hero h1;
private Hero h2;

public KillThread(Hero h1, Hero h2){
    this.h1 = h1;
    this.h2 = h2;
}

public void run(){
    while(!h2.isDead()){
        h1.attackHero(h2);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主线程进行代码测试</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 616;
    gareen.damage = 50;

    Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 300;
    teemo.damage = 30;

    Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 500;
    bh.damage = 65;

    Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 455;
    leesin.damage = 80;

    KillThread killThread1 = new KillThread(gareen,teemo);
    killThread1.start();
    KillThread killThread2 = new KillThread(bh,leesin);
    killThread2.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上为继承thread的方式进行的多线程的代码实现.  </span><br><span class="line"></span><br><span class="line"> **使用实现runnable接口的形式进行多线程的实现**</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class Battle implements Runnable{</p>
<pre><code>private Hero h1;
private Hero h2;

public Battle(Hero h1, Hero h2){
    this.h1 = h1;
    this.h2 = h2;
}

public void run(){
    while(!h2.isDead()){
        h1.attackHero(h2);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主线程测试类:</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 616;
    gareen.damage = 50;

    Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 300;
    teemo.damage = 30;

    Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 500;
    bh.damage = 65;

    Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 455;
    leesin.damage = 80;

    Battle battle1 = new Battle(gareen,teemo);

    new Thread(battle1).start();

    Battle battle2 = new Battle(bh,leesin);
    new Thread(battle2).start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**匿名类**</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 616;
    gareen.damage = 50;

    Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 300;
    teemo.damage = 30;

    Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 500;
    bh.damage = 65;

    Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 455;
    leesin.damage = 80;

    //匿名类
    Thread t1= new Thread(){
        public void run(){
            //匿名类中用到外部的局部变量teemo，必须把teemo声明为final
            //但是在JDK7以后，就不是必须加final的了
            while(!teemo.isDead()){
                gareen.attackHero(teemo);
            }              
        }
    };

    t1.start();

    Thread t2= new Thread(){
        public void run(){
            while(!leesin.isDead()){
                bh.attackHero(leesin);
            }              
        }
    };
    t2.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _start方法和run方法的区别?_  </span><br><span class="line">### 常见线程操作方法  </span><br><span class="line"> **线程暂停**  </span><br><span class="line">Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响   </span><br><span class="line">Thread.sleep(1000); 会抛出InterruptedException 中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出 InterruptedException</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Thread t1= new Thread(){
        public void run(){
            int seconds =0;
            while(true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);
            }              
        }
    };
    t1.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> **加入到当前线程**  </span><br><span class="line">首先解释一下主线程的概念  </span><br><span class="line">所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在。  </span><br><span class="line">在42行执行t.join，即表明在主线程中加入该线程。  </span><br><span class="line">主线程会等待该线程结束完毕， 才会往下运行。</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    final Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 616;
    gareen.damage = 50;

    final Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 300;
    teemo.damage = 30;

    final Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 500;
    bh.damage = 65;

    final Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 455;
    leesin.damage = 80;

    Thread t1= new Thread(){
        public void run(){
            while(!teemo.isDead()){
                gareen.attackHero(teemo);
            }              
        }
    };

    t1.start();

    //代码执行到这里，一直是main线程在运行
    try {
        //t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走
        t1.join();
    } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    Thread t2= new Thread(){
        public void run(){
            while(!leesin.isDead()){
                bh.attackHero(leesin);
            }              
        }
    };
    //会观察到盖伦把提莫杀掉后，才运行t2线程
    t2.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> **线程优先级**   </span><br><span class="line">当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源 </span><br><span class="line">为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源 </span><br><span class="line">同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示 </span><br><span class="line">如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>import java.io.Serializable;</p>
<p>public class Hero{<br>    public String name;<br>    public float hp;</p>
<pre><code>public int damage;

public void attackHero(Hero h) {
    //把暂停时间去掉，多条线程各自会尽力去占有CPU资源
    //线程的优先级效果才可以看得出来
</code></pre><p>//        try {<br>//<br>//            Thread.sleep(0);<br>//        } catch (InterruptedException e) {<br>//            // TODO Auto-generated catch block<br>//            e.printStackTrace();<br>//        }<br>        h.hp-=damage;<br>        System.out.format(“%s 正在攻击 %s, %s的血变成了 %.0f%n”,name,h.name,h.name,h.hp);</p>
<pre><code>    if(h.isDead())
        System.out.println(h.name +&quot;死了！&quot;);
}

public boolean isDead() {
    return 0&gt;=hp?true:false;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    final Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 6160;
    gareen.damage = 1;

    final Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 3000;
    teemo.damage = 1;

    final Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 5000;
    bh.damage = 1;

    final Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 4505;
    leesin.damage = 1;

    Thread t1= new Thread(){
        public void run(){

            while(!teemo.isDead()){
                gareen.attackHero(teemo);
            }              
        }
    };

    Thread t2= new Thread(){
        public void run(){
            while(!leesin.isDead()){
                bh.attackHero(leesin);
            }              
        }
    };

    t1.setPriority(Thread.MAX_PRIORITY);
    t2.setPriority(Thread.MIN_PRIORITY);
    t1.start();
    t2.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> **临时暂停**   </span><br><span class="line">当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>import charactor.Hero;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    final Hero gareen = new Hero();
    gareen.name = &quot;盖伦&quot;;
    gareen.hp = 61600;
    gareen.damage = 1;

    final Hero teemo = new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 30000;
    teemo.damage = 1;

    final Hero bh = new Hero();
    bh.name = &quot;赏金猎人&quot;;
    bh.hp = 50000;
    bh.damage = 1;

    final Hero leesin = new Hero();
    leesin.name = &quot;盲僧&quot;;
    leesin.hp = 45050;
    leesin.damage = 1;

    Thread t1= new Thread(){
        public void run(){

            while(!teemo.isDead()){
                gareen.attackHero(teemo);
            }              
        }
    };

    Thread t2= new Thread(){
        public void run(){
            while(!leesin.isDead()){
                //临时暂停，使得t1可以占用CPU资源
                Thread.yield();

                bh.attackHero(leesin);
            }              
        }
    };

    t1.setPriority(5);
    t2.setPriority(5);
    t1.start();
    t2.start();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> **守护线程**  </span><br><span class="line">守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</span><br><span class="line"></span><br><span class="line">就好像一个公司有销售部，生产部这些和业务挂钩的部门。</span><br><span class="line">除此之外，还有后勤，行政等这些支持部门。</span><br><span class="line"></span><br><span class="line">如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</span><br><span class="line"></span><br><span class="line">守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</span><br><span class="line"></span><br><span class="line">守护线程通常会被用来做日志，性能统计等工作。</span><br></pre></td></tr></table></figure></p>
<p>package multiplethread;</p>
<p>public class TestThread {</p>
<pre><code>public static void main(String[] args) {

    Thread t1= new Thread(){
        public void run(){
            int seconds =0;

            while(true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.printf(&quot;已经玩了LOL %d 秒%n&quot;, seconds++);

            }              
        }
    };
    t1.setDaemon(true);
    t1.start();

}
</code></pre><p>}<br>```  </p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十四节网络编程]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%8A%82%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="IP地址和端口"><a href="#IP地址和端口" class="headerlink" title="IP地址和端口"></a>IP地址和端口</h3><p><strong>IP地址</strong><br>在计算机网络里面,每一台计算机都存在一个IP地址,并且这个地址是唯一的,是全世界唯一的.<br>前提:全世界的计算机都在一个网段内.<br>32位,四个字节.<br>192.168.1.103  </p>
<p>其中xxx代表0~255之间十进制数值。<br>常识：计算机中的数据信息都是用二进制来标示。<br>0~255 中最大数值为255，转换为二进制就是11111111，共计8位二进制数值。至于0，转换后为00000000，中间的数值则也在8位二进制的范围内。  </p>
<p>127.0.0.1指的是当前的计算机,也就是我们对象里面说的this.<br><img src="https://images.gitee.com/uploads/images/2018/0906/153248_b59e072c_87680.png" alt="输入图片说明" title="2018-09-06 15-32-41屏幕截图.png"><br> <strong>端口</strong><br>两台计算机之间如果进行通讯,必须得有一台是服务器,另外一台作为客户端.<br>其中,服务器和客户端之间需要使用端口进行数据通讯.<br>图示如下:<br><img src="https://images.gitee.com/uploads/images/2018/0906/154018_985909f7_87680.png" alt="输入图片说明" title="2018-09-06 15-39-44屏幕截图.png"><br> <strong>实例:获取本机IP</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"> </span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"> </span><br><span class="line">public class TestSocket &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">        InetAddress host = InetAddress.getLocalHost();</span><br><span class="line">        String ip =host.getHostAddress();</span><br><span class="line">        System.out.println(&quot;本机ip地址：&quot; + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> **ping命令**  </span><br><span class="line">确定某一个ip和自己是否在一个网段,是否能够跟指定ip设备进行通讯.  </span><br><span class="line">ping ip地址  </span><br><span class="line">实例: ping 192.168.1.101</span><br><span class="line"> **telnet命令**  </span><br><span class="line">确定指定ip地址设备的某一端口是否能通.  </span><br><span class="line">telnet ip 端口  </span><br><span class="line">实例: telnet 192.168.1.123 8080  </span><br><span class="line"> **使用java执行ping命令**</span><br></pre></td></tr></table></figure>
<p>package socket;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;</p>
<p>public class TestSocket {</p>
<pre><code>public static void main(String[] args) throws IOException {

    Process p = Runtime.getRuntime().exec(&quot;ping &quot; + &quot;192.168.2.106&quot;);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line = null;
    StringBuilder sb = new StringBuilder();
    while ((line = br.readLine()) != null) {
        if (line.length() != 0)
            sb.append(line + &quot;\r\n&quot;);
    }
    System.out.println(&quot;本次指令返回的消息是：&quot;);
    System.out.println(sb.toString());
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> **尝试练习:**  </span><br><span class="line">确定当前网段可以的所有ip.  </span><br><span class="line">思路:遍历当前网段的所以ip地址,每一个ip地址进行ping操作.  </span><br><span class="line">只要可以ping通,则可以将数据进行打印,或者将ip地址存储到一个集合里面.之后便利整个集合即可.  </span><br><span class="line"> </span><br><span class="line">### socket  </span><br><span class="line">使用socket进行不同程序之间的通讯.  </span><br><span class="line">我们可能使用的语言不同,使用的框架不同,但是可以使用通用的网络协议进行通讯,只要网络协议相同,即可进行通讯.  </span><br><span class="line">socket又叫做套接字,可以进行不同程序之间的通讯.  </span><br><span class="line">使用socket的步骤:  </span><br><span class="line">1. 建立连接  </span><br><span class="line">2. 收发数据  </span><br><span class="line"></span><br><span class="line"> **建立连接实例**  </span><br><span class="line">1. 服务端开启8888端口，并监听着，时刻等待着客户端的连接请求 </span><br><span class="line">2. 客户端知道服务端的ip地址和监听端口号，发出请求到服务端 </span><br><span class="line">客户端的端口地址是系统分配的，通常都会大于1024 </span><br><span class="line">一旦建立了连接，服务端会得到一个新的Socket对象，该对象负责与客户端进行通信。 </span><br><span class="line">注意： 在开发调试的过程中，如果修改过了服务器Server代码，要关闭启动的Server,否则新的Server不能启动，因为8888端口被占用了  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0906/162154_a50ecf4b_87680.png &quot;2018-09-06 16-11-43屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.IOException;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Server {</p>
<pre><code>public static void main(String[] args)  {
    try {
        //服务端打开端口8888
        ServerSocket ss = new ServerSocket(8888);

        //在8888端口上监听，看是否有连接请求过来
        System.out.println(&quot;监听在端口号:8888&quot;);
        Socket s =  ss.accept();

        System.out.println(&quot;有连接过来&quot; + s);

        s.close();
        ss.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端测试:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.IOException;<br>import java.net.Socket;<br>import java.net.UnknownHostException;</p>
<p>public class Client {</p>
<pre><code>public static void main(String[] args)  {

    try {
        //连接到本机的8888端口
        Socket s = new Socket(&quot;127.0.0.1&quot;,8888);
        System.out.println(s);
        s.close();
    } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> **数字收发**  </span><br><span class="line">服务端代码:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Server {</p>
<pre><code>public static void main(String[] args) {
    try {

        ServerSocket ss = new ServerSocket(8888);

        System.out.println(&quot;监听在端口号:8888&quot;);
        Socket s = ss.accept();

        //打开输入流
        InputStream is = s.getInputStream();

        //读取客户端发送的数据
        int msg = is.read();
        //打印出来
        System.out.println(msg);
        is.close();

        s.close();
        ss.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端代码:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.Socket;<br>import java.net.UnknownHostException;</p>
<p>public class Client {</p>
<pre><code>public static void main(String[] args) {

    try {
        Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);

        // 打开输出流
        OutputStream os = s.getOutputStream();

        // 发送数字110到服务端
        os.write(110);
        os.close();

        s.close();
    } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> **收发字符串**  </span><br><span class="line">直接使用字节流收发字符串比较麻烦，使用数据流对字节流进行封装，这样收发字符串就容易了 </span><br><span class="line">1. 把输出流封装在DataOutputStream中 </span><br><span class="line">使用writeUTF发送字符串 &quot;Legendary!&quot; </span><br><span class="line">2. 把输入流封装在DataInputStream </span><br><span class="line">使用readUTF读取字符串,并打印</span><br><span class="line">实例代码:  </span><br><span class="line">服务端:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.DataInputStream;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Server {</p>
<pre><code>public static void main(String[] args) {
    try {

        ServerSocket ss = new ServerSocket(8888);

        System.out.println(&quot;监听在端口号:8888&quot;);
        Socket s = ss.accept();

        InputStream is = s.getInputStream();

        //把输入流封装在DataInputStream
        DataInputStream dis = new DataInputStream(is);
        //使用readUTF读取字符串
        String msg = dis.readUTF();
        System.out.println(msg);
        dis.close();
        s.close();
        ss.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.DataOutputStream;<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.Socket;<br>import java.net.UnknownHostException;<br>import java.util.Scanner;</p>
<p>public class Client {</p>
<pre><code>public static void main(String[] args) {

    try {
        Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);

        OutputStream os = s.getOutputStream();

        //把输出流封装在DataOutputStream中
        DataOutputStream dos = new DataOutputStream(os);
        //使用writeUTF发送字符串
        dos.writeUTF(&quot;Legendary!&quot;);
        dos.close();
        s.close();
    } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> **使用scanner进行数据的接收**  </span><br><span class="line">服务端代码:</span><br></pre></td></tr></table></figure></p>
<p>package socket;</p>
<p>import java.io.DataOutputStream;<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.Socket;<br>import java.net.UnknownHostException;<br>import java.util.Scanner;</p>
<p>public class Client {</p>
<pre><code>public static void main(String[] args) {

    try {
        Socket s = new Socket(&quot;127.0.0.1&quot;, 8888);

        OutputStream os = s.getOutputStream();
        DataOutputStream dos = new DataOutputStream(os);

        //使用Scanner读取控制台的输入，并发送到服务端
        Scanner sc = new Scanner(System.in);

        String str = sc.next();
        dos.writeUTF(str);

        dos.close();
        s.close();
    } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>}<br>```  </p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>实现一个网络聊天室的功能</p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十三节Java的IO流]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82Java%E7%9A%84IO%E6%B5%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>IO操作大部分是对文件的操作  </p>
</blockquote>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象主要分为文件和文件夹<br>java对应文件对象的操作，其常用方法可以通过如下的练习进行简单的记忆和了解。<br>不需要记住，使用的时候可以及时的查出来就行。<br> <strong>文件对象操作api1</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class TestFile &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         //创建一个文件对象</span><br><span class="line">        File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);</span><br><span class="line">        System.out.println(&quot;当前文件是：&quot; +f);</span><br><span class="line">        //文件是否存在</span><br><span class="line">        System.out.println(&quot;判断是否存在：&quot;+f.exists());</span><br><span class="line">         </span><br><span class="line">        //是否是文件夹</span><br><span class="line">        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());</span><br><span class="line">          </span><br><span class="line">        //是否是文件（非文件夹）</span><br><span class="line">        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());</span><br><span class="line">          </span><br><span class="line">        //文件长度</span><br><span class="line">        System.out.println(&quot;获取文件的长度：&quot;+f.length());</span><br><span class="line">          </span><br><span class="line">        //文件最后修改时间</span><br><span class="line">        long time = f.lastModified();</span><br><span class="line">        Date d = new Date(time);</span><br><span class="line">        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);</span><br><span class="line">        //设置文件修改时间为1970.1.1 08:00:00</span><br><span class="line">        f.setLastModified(0);</span><br><span class="line">          </span><br><span class="line">        //文件重命名</span><br><span class="line">        File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);</span><br><span class="line">        f.renameTo(f2);</span><br><span class="line">        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line"> **文件对象操作2**</span><br></pre></td></tr></table></figure>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code>    File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;);

    // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
    f.list();

    // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
    File[]fs= f.listFiles();

    // 以字符串形式返回获取所在文件夹
    f.getParent();

    // 以文件形式返回获取所在文件夹
    f.getParentFile();
    // 创建文件夹，如果父文件夹skin不存在，创建就无效
    f.mkdir();

    // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹
    f.mkdirs();

    // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常
    f.createNewFile();
    // 所以创建一个空文件之前，通常都会创建父目录
    f.getParentFile().mkdirs();

    // 列出所有的盘符c: d: e: 等等
    f.listRoots();

    // 刪除文件
    f.delete();

    // JVM结束的时候，刪除文件，常用于临时文件的删除
    f.deleteOnExit();

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> **尝试练习：遍历c盘windows文件夹**   </span><br><span class="line"></span><br><span class="line">### 流</span><br><span class="line">什么流呢？ 通俗来说，就是一系列的数据。  </span><br><span class="line">当不同的介质之间有数据交互的时候，JAVA就使用流来实现。</span><br><span class="line">数据源可以是文件，还可以是数据库，网络甚至是其他的程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流</span><br><span class="line">输入流： InputStream</span><br><span class="line">输出流：OutputStream  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0831/135036_2e39e1a0_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"> _下面我们简单介绍几种流:_   </span><br><span class="line"> **文件输入流**  </span><br><span class="line">将文件数据进行输入，输入到程序里面，使用流  </span><br><span class="line">实例</span><br></pre></td></tr></table></figure>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    try {
        File f = new File(&quot;d:/lol.txt&quot;);
        // 创建基于文件的输入流
        FileInputStream fis = new FileInputStream(f);
        // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中

    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时代码只是建立了流,还没有对文件进行操作.  </span><br><span class="line"> **字节流**  </span><br><span class="line"> 使用字节流主要进行如下操作:  </span><br><span class="line">1. 文件的读取  </span><br><span class="line">2. 文件的写入  </span><br><span class="line">在计算机的认知中,一切均为字节.因此,使用字节可以进行任何数据的读取和写入.  </span><br><span class="line"> **使用字节流进行数据的读取**</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    try {
        //准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66
        File f =new File(&quot;d:/lol.txt&quot;);
        //创建基于文件的输入流
        FileInputStream fis =new FileInputStream(f);
        //创建字节数组，其长度就是文件的长度
        byte[] all =new byte[(int) f.length()];
        //以字节流的形式读取文件所有内容
        fis.read(all);
        for (byte b : all) {
            //打印出来是65 66
            System.out.println(b);
        }

        //每次使用完流，都应该进行关闭
        fis.close();

    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**使用字节流进行文件的写入**</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileOutputStream;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    try {
        // 准备文件lol2.txt其中的内容是空的
        File f = new File(&quot;d:/lol2.txt&quot;);
        // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y
        byte data[] = { 88, 89 };

        // 创建基于文件的输出流
        FileOutputStream fos = new FileOutputStream(f);
        // 把数据写入到输出流
        fos.write(data);
        // 关闭输出流
        fos.close();

    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">### 关闭流  </span><br><span class="line">目前存在三种方式,可以关闭java的io流.  </span><br><span class="line">1. 在try中进行流的关闭  </span><br><span class="line">try&#123;关闭流&#125;catch()&#123;&#125;  </span><br><span class="line">这样存在一个很大的问题,假如出现问题,那么代码会直接进入catch语句.这样就会导致流不能正常关闭,会产生对资源的浪费.  </span><br><span class="line">即-流一直开着,没人使用.这将会是计算机资源的一种浪费.  </span><br><span class="line">2.  在finally里面进行流的关闭  </span><br><span class="line">try&#123;&#125;catch()&#123;&#125;finally&#123;&#125;  </span><br><span class="line">finally无论如何都会进入,这样会关闭的非常准确.绝不会造成资源的浪费.  </span><br><span class="line">但是,这种做法会使得代码变得非常繁琐.  </span><br><span class="line">3. try()关闭  </span><br><span class="line">这种做法还有一种说法叫做try-with-resources  </span><br><span class="line">之前,我们使用过这种方法.现在我们一起回顾一下:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 字符流读取写入  </span><br><span class="line">专门进行字符的读取和写入.  </span><br><span class="line">读取使用reader  </span><br><span class="line">写入使用writer  </span><br><span class="line">字符读取文件,实例如下:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileReader;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    // 准备文件lol.txt其中的内容是AB
    File f = new File(&quot;d:/lol.txt&quot;);
    // 创建基于文件的Reader
    try (FileReader fr = new FileReader(f)) {
        // 创建字符数组，其长度就是文件的长度
        char[] all = new char[(int) f.length()];
        // 以字符流的形式读取文件所有内容
        fr.read(all);
        for (char b : all) {
            // 打印出来是A B
            System.out.println(b);
        }
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符写入文件,代码如下:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    // 准备文件lol2.txt
    File f = new File(&quot;d:/lol2.txt&quot;);
    // 创建基于文件的Writer
    try (FileWriter fr = new FileWriter(f)) {
        // 以字符流的形式把数据写入到文件中
        String data=&quot;abcdefg1234567890&quot;;
        char[] cs = data.toCharArray();
        fr.write(cs);

    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">### 尝试练习  </span><br><span class="line">我们可以采用给字符加减数的形式进行字符的加密操作.  </span><br><span class="line">各位可以尝试一下该代码的实现.  </span><br><span class="line">我们一起定义一个加密算法,加密算法如下:  </span><br><span class="line">加密算法： </span><br><span class="line">数字： </span><br><span class="line">如果不是9的数字，在原来的基础上加1，比如5变成6, 3变成4  </span><br><span class="line">如果是9的数字，变成0  </span><br><span class="line">字母字符：  </span><br><span class="line">如果是非z字符，向右移动一个，比如d变成e, G变成H  </span><br><span class="line">如果是z，z-&gt;a, Z-A。  </span><br><span class="line">字符需要保留大小写  </span><br><span class="line">非字母字符  </span><br><span class="line">比如&apos;,&amp;^ 保留不变，中文也保留不变     </span><br><span class="line"></span><br><span class="line">### 中文问题  </span><br><span class="line"> **编码概念**  </span><br><span class="line">计算机存放的数据只能存放数字,也就是我们所说的0和1.  </span><br><span class="line">假如我们现在有一个棋盘,在不同的位置放入不同的数字,表示不同的值.  </span><br><span class="line">最小的棋盘就是我们所说的标准棋盘,只能存放英文和数字.  </span><br><span class="line">再大一点的棋盘则可以存放下中文.  </span><br><span class="line">再大的话就可以存放下所以的数据了.  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0906/125309_3c8a67cb_87680.png &quot;2018-09-06 12-52-53屏幕截图.png&quot;)   </span><br><span class="line"> **用FileInputStream 字节流正确读取中文**</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    File f = new File(&quot;E:\\project\\j2se\\src\\test.txt&quot;);
    try (FileInputStream fis = new FileInputStream(f);) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);

        //文件中读出来的数据是
        System.out.println(&quot;文件中读出来的数据是：&quot;);

        System.out.println(&quot;把这个数字，放在GBK的棋盘上去：&quot;);
        String str = new String(all,&quot;GBK&quot;);
        System.out.println(str);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**用FileReader 字符流正确读取中文**</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileNotFoundException;<br>import java.io.FileReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.UnsupportedEncodingException;<br>import java.nio.charset.Charset;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException {
    File f = new File(&quot;E:\\project\\j2se\\src\\test.txt&quot;);
    System.out.println(&quot;默认编码方式:&quot;+Charset.defaultCharset());
    //FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了
    //而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK
    try (FileReader fr = new FileReader(f)) {
        char[] cs = new char[(int) f.length()];
        fr.read(cs);
        System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset());
        System.out.println(new String(cs));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替
    //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式
    try (InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) {
        char[] cs = new char[(int) f.length()];
        isr.read(cs);
        System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;);
        System.out.println(new String(cs));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### 缓存流  </span><br><span class="line">以介质是硬盘为例，字节流和字符流的弊端:  </span><br><span class="line">在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。  </span><br><span class="line"></span><br><span class="line">为了解决以上弊端，采用缓存流。   </span><br><span class="line">缓存流在读取的时候，会一次性读较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。   </span><br><span class="line"></span><br><span class="line">就好比吃饭，不用缓存就是每吃一口都到锅里去铲。用缓存就是先把饭盛到碗里，碗里的吃完了，再到锅里去铲   </span><br><span class="line"></span><br><span class="line">缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才把这些数据，一起写入到硬盘中去。按照这种操作模式，就不会像字节流，字符流那样每写一个字节都访问硬盘，从而减少了IO操作  </span><br><span class="line"></span><br><span class="line">** 使用缓存流进行数据的读取. **  </span><br><span class="line">第一个缓存流BufferReader</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.BufferedReader;<br>import java.io.File;<br>import java.io.FileReader;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    // 准备文件lol.txt其中的内容是
    // garen kill teemo
    // teemo revive after 1 minutes
    // teemo try to garen, but killed again
    File f = new File(&quot;d:/lol.txt&quot;);
    // 创建文件字符流
    // 缓存流必须建立在一个存在的流的基础上
    try (
            FileReader fr = new FileReader(f);
            BufferedReader br = new BufferedReader(fr);
        )
    {
        while (true) {
            // 一次读一行
            String line = br.readLine();
            if (null == line)
                break;
            System.out.println(line);
        }
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**使用缓存流进行数据的写入,BufferWriter**</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.io.PrintWriter;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    // 向文件lol2.txt中写入三行语句
    File f = new File(&quot;d:/lol2.txt&quot;);

    try (
            // 创建文件字符流
            FileWriter fw = new FileWriter(f);
            // 缓存流必须建立在一个存在的流的基础上              
            PrintWriter pw = new PrintWriter(fw);              
    ) {
        pw.println(&quot;garen kill teemo&quot;);
        pw.println(&quot;teemo revive after 1 minutes&quot;);
        pw.println(&quot;teemo try to garen, but killed again&quot;);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> **flush**</span><br><span class="line"></span><br><span class="line">此函数可以将数据瞬时写入进去.使得我们的流操作立即生效.  </span><br><span class="line">否则:需要等到流的内存用尽之后才会生效.  </span><br><span class="line">实例:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.io.PrintWriter;<br>public class TestStream {<br>    public static void main(String[] args) {<br>        //向文件lol2.txt中写入三行语句<br>        File f =new File(“d:/lol2.txt”);<br>        //创建文件字符流<br>        //缓存流必须建立在一个存在的流的基础上<br>        try(FileWriter fr = new FileWriter(f);PrintWriter pw = new PrintWriter(fr);) {<br>            pw.println(“garen kill teemo”);<br>            //强制把缓存中的数据写入硬盘，无论缓存是否已满<br>                pw.flush();<br>            pw.println(“teemo revive after 1 minutes”);<br>                pw.flush();<br>            pw.println(“teemo try to garen, but killed again”);<br>                pw.flush();<br>        } catch (IOException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> **数据流**  </span><br><span class="line">DataInputStream 数据输入流   </span><br><span class="line">DataOutputStream 数据输出流   </span><br><span class="line">可以直接进行字符串的读写:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.DataInputStream;<br>import java.io.DataOutputStream;<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    write();
    read();
}

private static void read() {
    File f =new File(&quot;d:/lol.txt&quot;);
    try (
            FileInputStream fis  = new FileInputStream(f);
            DataInputStream dis =new DataInputStream(fis);
    ){
        boolean b= dis.readBoolean();
        int i = dis.readInt();
        String str = dis.readUTF();

        System.out.println(&quot;读取到布尔值:&quot;+b);
        System.out.println(&quot;读取到整数:&quot;+i);
        System.out.println(&quot;读取到字符串:&quot;+str);

    } catch (IOException e) {
        e.printStackTrace();
    }

}

private static void write() {
    File f =new File(&quot;d:/lol.txt&quot;);
    try (
            FileOutputStream fos  = new FileOutputStream(f);
            DataOutputStream dos =new DataOutputStream(fos);
    ){
        dos.writeBoolean(true);
        dos.writeInt(300);
        dos.writeUTF(&quot;123 this is gareen&quot;);
    } catch (IOException e) {
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 对象流  </span><br><span class="line">即直接将java的一个对象以流的形式传输给其他介质,比如硬盘.  </span><br><span class="line">一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口  </span><br><span class="line">比如,我们有一个英雄对象,其代码如下:</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>import java.io.Serializable;</p>
<p>public class Hero implements Serializable {<br>    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号<br>    private static final long serialVersionUID = 1L;<br>    public String name;<br>    public float hp;</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试代码如下:</span><br></pre></td></tr></table></figure></p>
<p>package stream;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;</p>
<p>import charactor.Hero;</p>
<p>public class TestStream {</p>
<pre><code>public static void main(String[] args) {
    //创建一个Hero garen
    //要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口
    Hero h = new Hero();
    h.name = &quot;garen&quot;;
    h.hp = 616;

    //准备一个文件用于保存该对象
    File f =new File(&quot;d:/garen.lol&quot;);

    try(
        //创建对象输出流
        FileOutputStream fos = new FileOutputStream(f);
        ObjectOutputStream oos =new ObjectOutputStream(fos);
        //创建对象输入流              
        FileInputStream fis = new FileInputStream(f);
        ObjectInputStream ois =new ObjectInputStream(fis);
    ) {
        oos.writeObject(h);
        Hero h2 = (Hero) ois.readObject();
        System.out.println(h2.name);
        System.out.println(h2.hp);

    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br>```  </p>
<h3 id="复习知识点scanner"><a href="#复习知识点scanner" class="headerlink" title="复习知识点scanner"></a>复习知识点scanner</h3><p>我们最早曾经学过一个知识点,叫做获取用户输入的数据.<br>获取用户输入的数据,我们当时就使用的流的形式.<br>使用system.in进行流的输入.用户输入的数据,输入到了我们计算机流里面.<br>之后,我们使用jdk提供的读取类scanner直接进行数据的读取即可.  </p>
<p>关于io流的一个总体概览:<br><img src="https://images.gitee.com/uploads/images/2018/0906/152522_f4a45888_87680.png" alt="输入图片说明" title="2018-09-06 15-25-03屏幕截图.png"></p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十二节异常处理]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="一张图概括java异常"><a href="#一张图概括java异常" class="headerlink" title="一张图概括java异常"></a>一张图概括java异常</h3><p><img src="https://images.gitee.com/uploads/images/2018/0831/121557_2edaf1ba_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>定义</strong><br>导致程序的正常流程被中断的事件，叫做异常.<br>告诉编译器，自己的代码是可能存在问题的。不过，在可能出现问题的地方及时进行反馈，同时来一个急刹车。保证不会对整个系统造成根本上的影响。  </p>
<p>以前的一个实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package exception;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        File f= new File(&quot;d:/LOL.exe&quot;);</span><br><span class="line">          </span><br><span class="line">        //试图打开文件LOL.exe，会抛出FileNotFoundException，如果不处理该异常，就会有编译错误</span><br><span class="line">        new FileInputStream(f);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> **处理办法**  </span><br><span class="line"> _try catch_  </span><br><span class="line"> _语法结构：_  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0831/131805_7ce6f23b_87680.png &quot;屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure>
<p>package exception;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileNotFoundException;</p>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {

    File f= new File(&quot;d:/LOL.exe&quot;);

    try{
        System.out.println(&quot;试图打开 d:/LOL.exe&quot;);
        new FileInputStream(f);
        System.out.println(&quot;成功打开&quot;);
    }
    catch(FileNotFoundException e){
        System.out.println(&quot;d:/LOL.exe不存在&quot;);
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用FileNotFoundException 的父类也可以将异常进行补获取</span><br></pre></td></tr></table></figure></p>
<p>package exception;</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileNotFoundException;</p>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {

    File f= new File(&quot;d:/LOL.exe&quot;);

    try{
        System.out.println(&quot;试图打开 d:/LOL.exe&quot;);
        new FileInputStream(f);
        System.out.println(&quot;成功打开&quot;);
    }

    catch(Exception e){
        System.out.println(&quot;d:/LOL.exe不存在&quot;);
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时，我们还可以使用一个try配合多个catch完成多个异常的补获取。</span><br></pre></td></tr></table></figure></p>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {

    File f = new File(&quot;d:/LOL.exe&quot;);

    try {
        System.out.println(&quot;试图打开 d:/LOL.exe&quot;);
        new FileInputStream(f);
        System.out.println(&quot;成功打开&quot;);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date d = sdf.parse(&quot;2016-06-03&quot;);
    } catch (FileNotFoundException e) {
        System.out.println(&quot;d:/LOL.exe不存在&quot;);
        e.printStackTrace();
    } catch (ParseException e) {
        System.out.println(&quot;日期格式解析错误&quot;);
        e.printStackTrace();
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### final关键字  </span><br><span class="line">解释：无论是否出现异常，finally中的代码都会被执行  </span><br><span class="line">使用实例：</span><br></pre></td></tr></table></figure>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {

    File f= new File(&quot;d:/LOL.exe&quot;);

    try{
        System.out.println(&quot;试图打开 d:/LOL.exe&quot;);
        new FileInputStream(f);
        System.out.println(&quot;成功打开&quot;);
    }
    catch(FileNotFoundException e){
        System.out.println(&quot;d:/LOL.exe不存在&quot;);
        e.printStackTrace();
    }
    finally{
        System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### throw抛出而非截获异常</span><br></pre></td></tr></table></figure>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {
    method1();

}

private static void method1() {
    try {
        method2();
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}

private static void method2() throws FileNotFoundException {

    File f = new File(&quot;d:/LOL.exe&quot;);

    System.out.println(&quot;试图打开 d:/LOL.exe&quot;);
    new FileInputStream(f);
    System.out.println(&quot;成功打开&quot;);

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">不去截获处理异常，异常就可以通过throw不断的被抛出。  </span><br><span class="line">但是，异常终究需要处理的。就看推给谁去处理了。  </span><br><span class="line">做一个有高尚操守的程序员，主动处理异常，将得到所有人的尊重。  </span><br><span class="line">尽量去trycatch不要去throw。  </span><br><span class="line">### throw和throws的区别</span><br><span class="line">很简单：  </span><br><span class="line">1. throws 出现在方法声明上，而throw通常都出现在方法体内。  </span><br><span class="line">2. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。  </span><br><span class="line">### 异常的分类  </span><br><span class="line">可查异常和非可查异常。  </span><br><span class="line">同时，非可查异常又分为运行时异常和错误。  </span><br><span class="line"> **可查异常就是必须处理的异常**  </span><br><span class="line">如何处理呢？  trycatch或者throw  </span><br><span class="line"> **运行时异常不必进行trycatch，主要分为以下几种： **  </span><br><span class="line">1. 除数不能为0异常:ArithmeticException </span><br><span class="line">2. 下标越界异常:ArrayIndexOutOfBoundsException  </span><br><span class="line">3. 空指针异常:NullPointerException    </span><br><span class="line"></span><br><span class="line"> **错误指的是系统级别的异常，一般而言表示内存耗光了**  </span><br><span class="line">尝试一下以下代码：</span><br></pre></td></tr></table></figure>
<p>package exception;</p>
<p>public class TestException {</p>
<pre><code>public static void main(String[] args) {

    StringBuffer sb =new StringBuffer();

    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
        sb.append(&apos;a&apos;);
    }

}
</code></pre><p>```<br>异常分类总结图：<br><img src="https://images.gitee.com/uploads/images/2018/0831/133248_a509e457_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable是类，Exception和Error都继承了该类<br><img src="https://images.gitee.com/uploads/images/2018/0831/133352_954a8806_87680.png" alt="输入图片说明" title="屏幕截图.png"></p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十一节静态类和方法]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="静态方法和非静态方法的区别"><a href="#静态方法和非静态方法的区别" class="headerlink" title="静态方法和非静态方法的区别"></a>静态方法和非静态方法的区别</h3><p>我们之前说过类方法和对象方法，通过这两个概念的字面意思就可以很好的理解静态和非静态。<br>对象方法依赖于对象，也就是说必须有对象的实例，才可以使用对象方法。<br>类方法依赖于类，只要类存在，便可以使用类方法。<br>非静态方法的使用需要new对象，静态则不需要。<br><img src="https://images.gitee.com/uploads/images/2018/0816/162948_7b0e0e20_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0816/163015_14f970d6_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="静态方法的限制"><a href="#静态方法的限制" class="headerlink" title="静态方法的限制"></a>静态方法的限制</h3><ol>
<li>不可以调用非静态的变量  </li>
<li>不可以调用非静态的方法  <h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3>他的值对所有的对象而言都是相同的。<br>例子：<br>假如你想知道类在实例化的过程中究竟被实例化或者说被new了多少次，那么，需要如何实现呢？<br><img src="https://images.gitee.com/uploads/images/2018/0816/163440_f894550e_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>上述例子明显是不可以实现的。<br>因为，方法是一个非静态方法，变量是一个非静态的变量。<br>于是，他们的使用就必须依赖于对象。对象每一次进行new或者实例化都会新建新的变量。<br>因此，对上述例子而言，被new的次数永远是0<br>解决方案很简单：即使用静态变量进行实例化次数的存储。<br><img src="https://images.gitee.com/uploads/images/2018/0816/163714_20f3b41a_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>静态变量：被同类的所有实例变量所共享</strong><br><img src="https://images.gitee.com/uploads/images/2018/0816/163805_539a4d32_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>静态变量的初始化</strong>  </li>
<li>静态变量会在该类任何对象初始化之前就被实例化。  </li>
<li>静态变量会在该类任何静态方法执行之前初始化。<br><strong>final</strong><br>final修饰的变量表示其初始化之后就不会再被修改。<br>如果该变量又恰好是一个静态变量，就表示该变量在类加载完成后就一直存在，且一直不能被修改。<br>因此，被final修饰的静态变量是一个常量。<br><img src="https://images.gitee.com/uploads/images/2018/0816/164311_92d9b433_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0816/164556_4743dfdc_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>当然final不只作用在变量上面</strong><br>之前有个知识点，可以一起回忆一下：<br>final可以作用在变量上面，可以作用在方法上面，甚至可以作用在类上面。<br>final变量代表你不能改变他的值<br>final方法表示你不可以重写覆盖他<br>final类表示你不可以继承他<br><strong>Math的静态方法</strong><br>Math.random()<br>Math.abs()<br>获取传入数据的绝对值<br>Math.round()<br>返回四舍五入的值<br>Math.min()<br>比较大小，获取两个数里面最小值<br>Math.max()<br>比较大小，获取两个数里面的最大值 <h3 id="primitive基础数据类型的对象封装"><a href="#primitive基础数据类型的对象封装" class="headerlink" title="primitive基础数据类型的对象封装"></a>primitive基础数据类型的对象封装</h3>每一个主数据类型都对应一个对象。<br>int Interger<br>float Float<br>double Double<br>boolean Boolean…等<br>主数据类型对象对应常用方法如下：  </li>
<li>primitive数据类型转对象-&gt;new对象  </li>
<li>对象转primitive-&gt;parse  </li>
</ol>
<p><strong>假如，将主数据类型放入集合list会有什么反应呢？</strong>   </p>
<h3 id="知识点插入-操作日期"><a href="#知识点插入-操作日期" class="headerlink" title="知识点插入  操作日期"></a>知识点插入  操作日期</h3><p>取得当前日期使用new Date(),其他使用Calendar，因为Date的方法和构造函数基本上都已经弃用了。<br>当然，Calendar是无法new的，只能使用静态方法去构造，静态方法为getInstance().<br><img src="https://images.gitee.com/uploads/images/2018/0831/113729_b7b72933_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>我们一起来看一个范例：<br><img src="https://images.gitee.com/uploads/images/2018/0831/113754_160a4581_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>常用方法，API:<br><img src="https://images.gitee.com/uploads/images/2018/0831/113918_2b342424_87680.png" alt="输入图片说明" title="屏幕截图.png"></p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十节图书管理系统答疑与讨论]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E8%8A%82%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%AD%94%E7%96%91%E4%B8%8E%E8%AE%A8%E8%AE%BA/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第九节构造器和垃圾回收机制]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B9%9D%E8%8A%82%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="对象有生有死"><a href="#对象有生有死" class="headerlink" title="对象有生有死"></a>对象有生有死</h3><p>如果对于对象的创建毫无章法，那就代表着对象有被对象回收机制回收的可能．<br> <strong>堆与栈是我们编写程序的过程中需要关心的两大生存空间</strong><br> <img src="https://images.gitee.com/uploads/images/2018/0811/195116_abd272f4_87680.png" alt="输入图片说明" title="2018-08-11 19-50-47屏幕截图.png"><br>之前说的关于对象堆的概念说的比较多，关于栈的概念没有接触，那么什么栈呢？<br>数据结构学过，栈呢就是一个有顺序的，单口出的一个容器，数据容器，另外一个容器叫做队列．<br>先入先出，先入后出．<br><img src="https://images.gitee.com/uploads/images/2018/0811/195358_3410516a_87680.png" alt="输入图片说明" title="2018-08-11 19-51-05屏幕截图.png"><br> <strong>关于栈的一个使用场景</strong><br> <img src="https://images.gitee.com/uploads/images/2018/0811/195829_2e350d7f_87680.png" alt="输入图片说明" title="2018-08-11 19-56-56屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0811/195842_e570bbb6_87680.png" alt="输入图片说明" title="2018-08-11 19-57-13屏幕截图.png"><br>对于非基础数据类型的对象的引用都是引用的堆里面的内容，而对于栈内存放的数据仅仅只是一个变量的引用而已．<br><img src="https://images.gitee.com/uploads/images/2018/0811/201718_989f81ba_87680.png" alt="输入图片说明" title="2018-08-11 20-17-07屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0811/201838_4fd7f713_87680.png" alt="输入图片说明" title="2018-08-11 20-18-16屏幕截图.png"><br>局部变量是生存在栈上的，那么实例变量呢？实例变量即类的属性．<br>实例变量是生存在堆上的，也就是说，在堆上新建一个对象的时候，同时将类的属性进行了创建和使用．<br><img src="https://images.gitee.com/uploads/images/2018/0811/210511_e635fb29_87680.png" alt="输入图片说明" title="2018-08-11 20-21-16屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0811/210532_9eec56b9_87680.png" alt="输入图片说明" title="2018-08-11 21-04-57屏幕截图.png"></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>我们在使用new 对象的时候，比如new Hero(),看起来是在调用该类的构造函数。  </p>
<ol>
<li>构造函数与普通方法有哪些不同？  </li>
<li>构造函数有哪些注意事项？<br><strong>提供了一种途径，让你可以介入到整个对象new的过程中</strong><br>构造函数分为两种：<br>有参构造<br>无参构造<br>需要注意，在无参构造函数里面也可以进行一些业务逻辑的处理。<br><img src="https://images.gitee.com/uploads/images/2018/0813/114911_0fcb830a_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><em>还有一个注意的地方</em><br>编译器默认会构造一个无参数的构造函数。<br>当然，这一切发生于一个前提之下，即我们没有进行任何有参数的构造函数的创建。主要我们创建了任何一个有参数的构造函数，那么编译器便不会自动帮助我们去构建无参数的构造函数。我们必须去手动构造。  </li>
</ol>
<h3 id="继承与构造函数的关系"><a href="#继承与构造函数的关系" class="headerlink" title="继承与构造函数的关系"></a>继承与构造函数的关系</h3><p><img src="https://images.gitee.com/uploads/images/2018/0813/120148_081e896c_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>在创建对象的时候，所有继承下来的构造函数均会被执行。<br><img src="https://images.gitee.com/uploads/images/2018/0813/120358_a9498f2d_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>对象在执行构造函数的时候，第一件事情就是去执行其父类的构造函数。<br>执行对象new的时候，会发生一系列的连锁反应，从父类的构造函数开始逐步进行构造函数的构造，直到object为止。<br> <strong>典型实例（继承类之间的构造函数构造顺序）</strong><br><img src="https://images.gitee.com/uploads/images/2018/0813/144915_9c717115_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>通过堆和栈来看的话，对应的构造图如下：<br><img src="https://images.gitee.com/uploads/images/2018/0813/145017_6117ec89_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>如何调用父类的构造函数？</strong><br>使用super关键字。<br> 关于继承父子之间的构造函数执行顺序的问题，可以通俗一点去考虑。<br>没有父母的情况下可能产生孩子吗？<br><img src="https://images.gitee.com/uploads/images/2018/0813/145641_6b3d6a58_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>思考一个问题：假如父类的构造方法存在参数，如何进行构造函数的传参呢？</strong><br> <img src="https://images.gitee.com/uploads/images/2018/0813/150432_404c1e18_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>this关键字也可以调用构造函数，this可以调用当前类的任何属性、方法还有构造函数。<br><img src="https://images.gitee.com/uploads/images/2018/0813/165828_83c128e0_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>对象的生命周期主要看他的引用的生命周期，如果引用还活着，那么对象也会继续在这个世界上，否则对象会随着引用的消失而死亡。<br>对象能活多久取决于其引用能活多久。<br>如果该对象的引用类型为局部变量，那么该变量的作用范围仅仅是其作用方法内。当然，其对象也就仅仅生存或死亡在该作用方法内。<br><img src="https://images.gitee.com/uploads/images/2018/0815/140327_28ece998_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>如果对象的引用类型为成员变量，那么该变量的寿命和对象相同，对象活着，其实例变量也还活着。<br><img src="https://images.gitee.com/uploads/images/2018/0815/140440_c4612d55_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0815/140451_e032fd7d_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>典型实例：  </p>
<ol>
<li>引用死去，对象也会死去<br><img src="https://images.gitee.com/uploads/images/2018/0815/140711_2070aca6_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0815/140726_2a24d390_87680.png" alt="输入图片说明" title="屏幕截图.png">  </li>
<li>引用被赋值到其他对象上面<br><img src="https://images.gitee.com/uploads/images/2018/0815/140848_799b8ce2_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0815/140918_363a6ee0_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0815/140926_0a6d90ea_87680.png" alt="输入图片说明" title="屏幕截图.png">  </li>
<li>直接将引用设为null<br><img src="https://images.gitee.com/uploads/images/2018/0815/140955_dcec01d5_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0815/141003_c0fa14e7_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0815/141012_a49c5735_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>思考：实例变量和局部变量的区别和联系</strong>  </li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>完成图书管理系统。</p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第八节项目实战图书管理系统]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%85%AB%E8%8A%82%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h3 id="功能确定"><a href="#功能确定" class="headerlink" title="功能确定"></a>功能确定</h3><p>确定有哪些功能，明确最终的需求。<br>角色区分：管理员角色和普通用户角色  </p>
<h3 id="管理员功能列表"><a href="#管理员功能列表" class="headerlink" title="管理员功能列表"></a>管理员功能列表</h3><ol>
<li>登录登出  注册  修改密码  密码找回 身份证号   </li>
<li>电子借书卡办理  新建学生用户有初始密码  用户名用身份证号  </li>
<li>书籍维护（书籍增加、书籍信息修改，书籍删除、书籍查询）  分类维护  </li>
<li>借书功能（可以帮助普通用户完成借书流程，需要输入用户的身份证号、查询出书籍信息，最终完成书籍的借阅）  </li>
<li>还书功能（查询出指定书籍、输入普通借书用户的身份证号，完成书籍的入库）<br>－－－－－－－－－－－－－－－－－－－－陈航－－－－－－－－－－－－－－－－－－－－</li>
<li>报表（报表展示目前的图书藏书状况，根据分类展示一个各分类图书所占比例的饼状图、折线图展示每月图书借阅和归还曲线，按照月份以柱状图形式展示开通电子借书卡的学生数量）  </li>
<li>设置功能（最大借书量、借书期限） </li>
<li>破损书管理  </li>
<li>黑名单<br>－－－－－－－－－－－－－－－－－－－－杨明宇－－－－－－－－－－－－－－－－－－－－</li>
</ol>
<h3 id="普通用户（教师和学生）功能"><a href="#普通用户（教师和学生）功能" class="headerlink" title="普通用户（教师和学生）功能"></a>普通用户（教师和学生）功能</h3><ol>
<li>登录登出  注册  修改密码　密码找回<br>－－－－－－－－－－－－－－－－－－－－杨明宇－－－－－－－－－－－－－－－－－－－－</li>
<li>书籍查询  </li>
<li>书籍借阅  预约  </li>
<li>书籍归还  </li>
<li>借阅历史查询<br>－－－－－－－－－－－－－－－－－－－－高鸿宇－－－－－－－－－－－－－－－－－－－－<h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><h3 id="原型设计（界面设计）"><a href="#原型设计（界面设计）" class="headerlink" title="原型设计（界面设计）"></a>原型设计（界面设计）</h3><h3 id="实体类与DAO类设计"><a href="#实体类与DAO类设计" class="headerlink" title="实体类与DAO类设计"></a>实体类与DAO类设计</h3><h3 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h3></li>
</ol>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>需要用到图标资源，图标资源的下载地址，提供两个网址：  </p>
<ol>
<li><a href="https://fontawesome.com/icons" target="_blank" rel="noopener">https://fontawesome.com/icons</a>  </li>
<li><a href="http://iconfont.cn/" target="_blank" rel="noopener">http://iconfont.cn/</a>  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第七节　JDBC简介（二）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%83%E8%8A%82-JDBC%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务指的是一系列的sql操作，比如增加之后，再次操作数据库完成删除一条数据的操作。<br>那么，这里说的增加数据、删除数据两个sql语句结合在一起就可以称为一个事务.<br> <strong>不使用事务的情况</strong><br>假如我们的英雄表里面的一个英雄，加血之后马上又被队友补了一刀，那么两次操作之后，该英雄血量不变。<br>但是，如果我们在实际编码过程中，update第一次加血之后。第二次update的时候sql语句写错了。<br>这就会造成减血失败。<br>从而，使得我们的英雄血量比实际情况增加了。<br>显然，这和我们的业务需求是严重不符合的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//没有事务的前提下</span><br><span class="line">            //假设业务操作时，加血，减血各做一次</span><br><span class="line">            //结束后，英雄的血量不变</span><br><span class="line">              </span><br><span class="line">            //加血的SQL</span><br><span class="line">            String sql1 = &quot;update hero set hp = hp +1 where id = 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">              </span><br><span class="line">            //减血的SQL</span><br><span class="line">            //不小心写错写成了 updata(而非update)</span><br><span class="line">              </span><br><span class="line">            String sql2 = &quot;updata hero set hp = hp -1 where id = 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br></pre></td></tr></table></figure>
<p> <strong>使用事务</strong><br>对该事务中的多次sql操作保持一致性。<br>即-全部执行成功或者全部执行失败，假如其中一条sql执行失败，那么事务会进行回滚，即之前的加血操作也会自动回到原来的状态（不加血的状态）。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> // 有事务的前提下</span><br><span class="line">            // 在事务中的多个操作，要么都成功，要么都失败</span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(false);</span><br><span class="line">  </span><br><span class="line">            // 加血的SQL</span><br><span class="line">            String sql1 = &quot;update hero set hp = hp +1 where id = 22&quot;;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            // 减血的SQL</span><br><span class="line">            // 不小心写错写成了 updata(而非update)</span><br><span class="line">  </span><br><span class="line">            String sql2 = &quot;updata hero set hp = hp -1 where id = 22&quot;;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            // 手动提交</span><br><span class="line">            c.commit();</span><br><span class="line">```  </span><br><span class="line"> _使用事务需要一个前提条件，即开启INNODB引擎支持_  </span><br><span class="line"> **尝试练习：模拟借书，目前有两个表即图书表和用户表，借书的时候，需要修改图书的状态，同时借书人借书的数量也需要加一。如果实际的操作过程中，修改借书人借书的数量失败，则需要将图书的状态回滚至未出借的状态**  </span><br><span class="line">  </span><br><span class="line">### ORM  </span><br><span class="line">ORM=Object Relationship Database Mapping  </span><br><span class="line"></span><br><span class="line">对象和关系数据库的映射   </span><br><span class="line"></span><br><span class="line">简单说，一个对象，对应数据库里的一条记录  </span><br><span class="line">这是一种设计模式，相当于把数据对象化了，使得数据库的操作变得面向对象起来。  </span><br><span class="line">首先，把表变得面向对象，即一个表对应一个class类。</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class Hero {<br>    //增加id属性<br>    public int id;<br>    public String name;<br>    public float hp;<br>    public int damage;</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，在获取到数据库数据之后，将数据进行类对应属性的赋值。</span><br></pre></td></tr></table></figure></p>
<p>// 因为id是唯一的，ResultSet最多只能有一条记录<br>            // 所以使用if代替while<br>            if (rs.next()) {<br>                hero = new Hero();<br>                String name = rs.getString(2);<br>                float hp = rs.getFloat(“hp”);<br>                int damage = rs.getInt(4);<br>                hero.name = name;<br>                hero.hp = hp;<br>                hero.damage = damage;<br>                hero.id = id;<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">综上，我们完成了orm的面向对象操作数据库的操作。  </span><br><span class="line"> **尝试一下ORM来实现lol英雄的增删改查操作**  </span><br><span class="line">### DAO</span><br><span class="line">DAO=DataAccess Object   </span><br><span class="line">数据库访问对象   </span><br><span class="line"> **设计模式的再一次升华，通过dao将对数据库的操作再一次封装起来，放到一个特定的类里面，使得代码更容易理解，更容易扩展**  </span><br><span class="line">首先，提供一个DAO的接口，该接口封装数据库的所有操作接口。</span><br></pre></td></tr></table></figure></p>
<p>public interface DAO{<br>    //增加<br>    public void add(Hero hero);<br>    //修改<br>    public void update(Hero hero);<br>    //删除<br>    public void delete(int id);<br>    //获取<br>    public Hero get(int id);<br>    //查询<br>    public List<hero> list();<br>    //分页查询<br>    public List<hero> list(int start, int count);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二，添加实现类，可以有多个实现类，lol里面我们暂时实现HeroDAO类，图书管理系统呢？则需要添加BookDAO和AdminDAO。  </span><br><span class="line">也就是说，存在几个表就需要添加几个对象，当然也需要添加几个DAO的实现类。</span><br></pre></td></tr></table></figure></hero></hero></p>
<p> public HeroDAO() {<br>        try {<br>            Class.forName(“com.mysql.jdbc.Driver”);<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }</p>
<pre><code>public Connection getConnection() throws SQLException {
    return DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;, &quot;root&quot;,
            &quot;admin&quot;);
}

public int getTotal() {
    int total = 0;
    try (Connection c = getConnection(); Statement s = c.createStatement();) {

        String sql = &quot;select count(*) from hero&quot;;

        ResultSet rs = s.executeQuery(sql);
        while (rs.next()) {
            total = rs.getInt(1);
        }

        System.out.println(&quot;total:&quot; + total);

    } catch (SQLException e) {

        e.printStackTrace();
    }
    return total;
}

public void add(Hero hero) {

    String sql = &quot;insert into hero values(null,?,?,?)&quot;;
    try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql);) {

        ps.setString(1, hero.name);
        ps.setFloat(2, hero.hp);
        ps.setInt(3, hero.damage);

        ps.execute();

        ResultSet rs = ps.getGeneratedKeys();
        if (rs.next()) {
            int id = rs.getInt(1);
            hero.id = id;
        }
    } catch (SQLException e) {

        e.printStackTrace();
    }
}

public void update(Hero hero) {

    String sql = &quot;update hero set name= ?, hp = ? , damage = ? where id = ?&quot;;
    try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql);) {

        ps.setString(1, hero.name);
        ps.setFloat(2, hero.hp);
        ps.setInt(3, hero.damage);
        ps.setInt(4, hero.id);

        ps.execute();

    } catch (SQLException e) {

        e.printStackTrace();
    }

}

public void delete(int id) {

    try (Connection c = getConnection(); Statement s = c.createStatement();) {

        String sql = &quot;delete from hero where id = &quot; + id;

        s.execute(sql);

    } catch (SQLException e) {

        e.printStackTrace();
    }
}

public Hero get(int id) {
    Hero hero = null;

    try (Connection c = getConnection(); Statement s = c.createStatement();) {

        String sql = &quot;select * from hero where id = &quot; + id;

        ResultSet rs = s.executeQuery(sql);

        if (rs.next()) {
            hero = new Hero();
            String name = rs.getString(2);
            float hp = rs.getFloat(&quot;hp&quot;);
            int damage = rs.getInt(4);
            hero.name = name;
            hero.hp = hp;
            hero.damage = damage;
            hero.id = id;
        }

    } catch (SQLException e) {

        e.printStackTrace();
    }
    return hero;
}

public List&lt;Hero&gt; list() {
    return list(0, Short.MAX_VALUE);
}

public List&lt;Hero&gt; list(int start, int count) {
    List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();

    String sql = &quot;select * from hero order by id desc limit ?,? &quot;;

    try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql);) {

        ps.setInt(1, start);
        ps.setInt(2, count);

        ResultSet rs = ps.executeQuery();

        while (rs.next()) {
            Hero hero = new Hero();
            int id = rs.getInt(1);
            String name = rs.getString(2);
            float hp = rs.getFloat(&quot;hp&quot;);
            int damage = rs.getInt(4);
            hero.id = id;
            hero.name = name;
            hero.hp = hp;
            hero.damage = damage;
            heros.add(hero);
        }
    } catch (SQLException e) {

        e.printStackTrace();
    }
    return heros;
}
</code></pre><p>```  </p>
<p> <strong>尝试添加物品表item，添加其对应的类，添加其实现类</strong> </p>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>简单了解，数据库连接池的概念的前提是多线程。<br>对多线程的理解，现在大家暂时可以理解成同一时间多个工作同时进行。<br>假如，目前有一个多线程的连接连接我们的数据库，可能有100个连接或者更多同时跟我的数据库进行了连接。<br>这样的话，我们需要打开数据库100次，之后再进行数据库的相关操作。<br>打开关闭数据库本身就十分耗费资源，会造成cpu和内存的负载，造成整体的卡顿。<br>并且，目前多线程的连接的意思是说同一时间这100个连接跟我的数据库建立关系，肯定会卡顿上天了。<br>关键的问题是，数据库的连接是有数量限制的，超过限制就连接失败了，也就是说100个连接里面可能会有50或者90个连接连接失败，丢了。  </p>
<p>以上说的问题，我们是决不允许发生的，于是伴随着线程池的概念，数据库连接池也出现了。<br> <strong>数据库连接池原理</strong><br>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面借用，而不是自己重新创建.<br>使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。<br>整个过程，这些连接都不会被关闭，而是不断的被循环使用，从而节约了启动和关闭连接的时间。<br><img src="https://images.gitee.com/uploads/images/2018/0815/131936_5977fe97_87680.png" alt="输入图片说明" title="屏幕截图.png"></p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>通过orm来实现图书管理系统图书的增加修改删除和查询功能。 </li>
<li>针对图书管理系统，进行DAO设计的实现，增加对应的DAO实现类。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第六节JDBC简介（一）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%85%AD%E8%8A%82JDBC%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h3><p>JDBC (Java DataBase Connection) 是通过JAVA访问数据库  </p>
<h3 id="JDBC如何连接数据库？"><a href="#JDBC如何连接数据库？" class="headerlink" title="JDBC如何连接数据库？"></a>JDBC如何连接数据库？</h3><p> <strong>借助java提供的mysql操作的jar包进行jdbc的操作，该jar包属于第三方jar包，需要将该jar包引入项目之后才可以进行jar包的使用。也就是说可以使用该jar内对应类的方法和接口。</strong><br>分享一个下载jdk的网页，此网页为阿里的maven对外仓库。<br><a href="http://mvnrepository.com/artifact/com.aliyun" target="_blank" rel="noopener">http://mvnrepository.com/artifact/com.aliyun</a><br> <strong>导入mysql连接jar包的意义</strong><br>我们不必自己去考虑实际的连接，已有先人为我们写好，我们需要学习的是jar包对应的方法和接口，说白了就是调用方法以及如何传入实际的参数。<br> <strong>使用步骤</strong>  </p>
<ol>
<li>导入jar包<br>如下图所示，在project structure里面进行相关设置导入即可。<br><img src="https://images.gitee.com/uploads/images/2018/0814/140729_3b6798ef_87680.png" alt="输入图片说明" title="屏幕截图.png"></li>
<li>驱动初始化<br>使用反射原理，获取操作类即可，Class.forName()方法。<br>对应的类名为： com.mysql.jdbc.Driver<br>代码参考：  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        //初始化驱动</span><br><span class="line">        try &#123;</span><br><span class="line">            //驱动类com.mysql.jdbc.Driver</span><br><span class="line">            //就在 mysql-connector-java-5.0.8-bin.jar中</span><br><span class="line">            //如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">              </span><br><span class="line">            System.out.println(&quot;数据库驱动加载成功 ！&quot;);</span><br><span class="line">   </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">3. 建立数据库连接  </span><br><span class="line">建立与数据库的Connection连接  </span><br><span class="line">这里需要提供：  </span><br><span class="line">数据库所处于的ip:127.0.0.1 (本机)  </span><br><span class="line">数据库的端口号： 3306 （mysql专用端口号）  </span><br><span class="line">数据库名称 lol  </span><br><span class="line">编码方式 UTF-8  </span><br><span class="line">账号 root  </span><br><span class="line">密码 root  </span><br><span class="line">参考代码：</span><br></pre></td></tr></table></figure>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

        // 建立与数据库的Connection连接
        // 这里需要提供：
        // 数据库所处于的ip:127.0.0.1 (本机)
        // 数据库的端口号： 3306 （mysql专用端口号）
        // 数据库名称 how2java
        // 编码方式 UTF-8
        // 账号 root
        // 密码 admin

        Connection c = DriverManager
                .getConnection(
                        &quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,
                        &quot;root&quot;, &quot;admin&quot;);

        System.out.println(&quot;连接成功，获取连接对象： &quot; + c);

    } catch (ClassNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. 创建Statement  </span><br><span class="line">Statement是用于执行SQL语句的，比如增加，删除  </span><br><span class="line">参考代码：</span><br></pre></td></tr></table></figure></p>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

        Connection c = DriverManager
                .getConnection(
                        &quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,
                        &quot;root&quot;, &quot;admin&quot;);

        // 注意：使用的是 java.sql.Statement
        // 不要不小心使用到： com.mysql.jdbc.Statement;
        Statement s = c.createStatement();

        System.out.println(&quot;获取 Statement对象： &quot; + s);

    } catch (ClassNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 执行SQL语句  </span><br><span class="line">s.execute执行sql语句  </span><br><span class="line">参考代码：</span><br></pre></td></tr></table></figure></p>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

        Connection c = DriverManager
                .getConnection(
                        &quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,
                        &quot;root&quot;, &quot;admin&quot;);

        Statement s = c.createStatement();

        // 准备sql语句
        // 注意： 字符串要用单引号&apos;
        String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;
        s.execute(sql);

        System.out.println(&quot;执行插入语句成功&quot;);

    } catch (ClassNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6. 关闭连接  </span><br><span class="line">数据库的连接是有限资源，相关操作结束后，养成关闭数据库的好习惯  </span><br><span class="line">先关闭Statement  </span><br><span class="line">后关闭Connection  </span><br><span class="line">参考代码：</span><br></pre></td></tr></table></figure></p>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    Connection c = null;
    Statement s = null;
    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

        c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;, &quot;root&quot;,
                &quot;admin&quot;);

        s = c.createStatement();

        String sql = &quot;insert into hero values(null,&quot; + &quot;&apos;提莫&apos;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;

        s.execute(sql);

    } catch (ClassNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } finally {
        // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯
        // 先关闭Statement
        if (s != null)
            try {
                s.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        // 后关闭Connection
        if (c != null)
            try {
                c.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7. 使用try-with-resource的方式自动关闭连接  </span><br><span class="line">自jdk7开始，可以将需要关闭的连接放到try的括号内，这样可以不用再进行手动关闭。  </span><br><span class="line">语法结构：  </span><br><span class="line">try()&#123;&#125;catch(Exception e)&#123;&#125;  </span><br><span class="line">例子：</span><br></pre></td></tr></table></figure></p>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }

    try (
        Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,
            &quot;root&quot;, &quot;admin&quot;);
        Statement s = c.createStatement();             
    )
    {
        String sql = &quot;insert into hero values(null,&quot; + &quot;&apos;提莫&apos;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;
        s.execute(sql);

    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> **尝试练习：**  </span><br><span class="line">数据库内插入10条英雄数据。  </span><br><span class="line">### 增删改  </span><br><span class="line"> **增加**  </span><br><span class="line">往数据库表内插入一条数据  </span><br><span class="line">使用statement指向execute()即可．  </span><br><span class="line"> **修改**  </span><br><span class="line">和增加类似，需要自己构造一个修改的sql语句.  </span><br><span class="line">String sql = &quot;update hero set name = &apos;name 5&apos; where id = 3&quot;;  </span><br><span class="line"> **删除**  </span><br><span class="line">和增加类似，构建sql语句  </span><br><span class="line">String sql = &quot;delete from hero where id = 5&quot;;  </span><br><span class="line">### 查询  </span><br><span class="line">之所以将查询单独拿出来，和增删改区分开，是因为查询相对比较复杂，情况也比较多．  </span><br><span class="line">后期查询我们还会学习多表查询或者join连表查询,当然还有按组查询．  </span><br><span class="line">查询需要使用statement执行executeQuery方法，返回的数据放在了ResultSet里面．  </span><br><span class="line">之后，我们需要遍历ResultSet将数据全部打印或者去指向其他操作．</span><br></pre></td></tr></table></figure></p>
<p>while (rs.next()) {<br>                int id = rs.getInt(“id”);// 可以使用字段名<br>                String name = rs.getString(2);// 也可以使用字段的顺序<br>                float hp = rs.getFloat(“hp”);<br>                int damage = rs.getInt(4);<br>                System.out.printf(“%d\t%s\t%f\t%d%n”, id, name, hp, damage);<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ResultSet也需要去关闭，但是一般来说，关闭statement的时候，他也会随着自动关闭了．  </span><br><span class="line"> **尝试：使用查询语句完成一个登录页面的编写**  </span><br><span class="line"> **获取查询列表的总数**  </span><br><span class="line">1. 遍历以后自己计算  </span><br><span class="line">2. 直接使用sql语句查询  </span><br><span class="line">使用select count(*)  </span><br><span class="line"> **尝试进行分页查询，查询第一页，也就是前五条数据**  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 使用使用PreparedStatement进行数据查询  </span><br><span class="line">同样是查询语句，但是他相对于statement来说，需要使用方法进行参数的传入．  </span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure></p>
<p>String sql = “insert into hero values(null,?,?,?)”;<br>        try (Connection c = DriverManager.getConnection(“jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8”,”root”, “admin”);<br>            // 根据sql语句创建PreparedStatement<br>            PreparedStatement ps = c.prepareStatement(sql);<br>       　 ) {</p>
<pre><code>// 设置参数
ps.setString(1, &quot;提莫&quot;);
ps.setFloat(2, 313.0f);
ps.setInt(3, 50);
// 执行
ps.execute();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">优势：  </span><br><span class="line">1. 可读性比较好  </span><br><span class="line">2. 性能相对比较好查询速度比较快  </span><br><span class="line">3. 防止sql注入式攻击  </span><br><span class="line">第三点的话，注入式的攻击是由于整个sql语句都是传入式的，这就导致黑客或者别用用心的攻击者，对我们的程序传入一个恒成立的值，比如：  </span><br><span class="line">select * from hero where name = &apos;盖伦&apos; OR 1=1  </span><br><span class="line">这条语句就会把所以的数据查询出来  </span><br><span class="line">假如我们的数据是百万级别的,进行持续的查询，就会损耗内存和cpu，导致程序变得卡顿.  </span><br><span class="line">假如我们的参数式传入的,sql仅仅是传入一个骨架，就会将这种攻击避免掉.  </span><br><span class="line"> **尝试使用PreparedStatement进行英雄的查询** </span><br><span class="line"></span><br><span class="line">### execute与executeUpdate  </span><br><span class="line">这两个执行方法都可以进行sql语句的增加、修改和删除。  </span><br><span class="line">我们将之前例子中的execute方法修改为executeUpdate也是可以执行，并且正确运行出最终的执行结果的。  </span><br><span class="line">那么他们有什么区别呢？  </span><br><span class="line">区别1：  </span><br><span class="line">execute可以运行查询语句，并且最终将结果通过statement.getResultSet获取到，最终的结果放到了ResultSet结果集里面.  </span><br><span class="line">但是executeUpdate则不能执行查询语句。  </span><br><span class="line">区别2：  </span><br><span class="line">execute执行增删改之后，返回值为boolean类型，表示sql语句是否执行成功。  </span><br><span class="line">executeUpdate则返回int类型，表示受影响的数据有多少条。  </span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.ResultSet;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {<br>    public static void main(String[] args) {</p>
<pre><code>    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }

    try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);
        Statement s = c.createStatement();) {

        // 不同1：execute可以执行查询语句
        // 然后通过getResultSet，把结果集取出来
        String sqlSelect = &quot;select * from hero&quot;;

        s.execute(sqlSelect);
        ResultSet rs = s.getResultSet();
        while (rs.next()) {
            System.out.println(rs.getInt(&quot;id&quot;));
        }

        // executeUpdate不能执行查询语句
        // s.executeUpdate(sqlSelect);

        // 不同2:
        // execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等
        boolean isSelect = s.execute(sqlSelect);
        System.out.println(isSelect);

        // executeUpdate返回的是int，表示有多少条数据受到了影响
        String sqlUpdate = &quot;update Hero set hp = 300 where id &lt; 100&quot;;
        int number = s.executeUpdate(sqlUpdate);
        System.out.println(number);

    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> **尝试练习：分页查询，使用executeUpdate方法执行，而非execute方法**  </span><br><span class="line"> </span><br><span class="line">### 特殊操作  </span><br><span class="line"> **获取自增id**  </span><br><span class="line">在执行插入语句之后，可以获取到自增id的值，不过前提是该id是自动增长的字段。  </span><br><span class="line">获取方法：  </span><br><span class="line">使用statement的getGeneratedKeys()即可。  </span><br><span class="line">该方法获取到的数据会放入一个resultset集合。  </span><br><span class="line">使用next()方法便可依次去除该id值（当然，这个地方的值仅有一个）   </span><br><span class="line">示例：</span><br></pre></td></tr></table></figure></p>
<p>// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id<br>            // JDBC通过getGeneratedKeys获取该id<br>            ResultSet rs = ps.getGeneratedKeys();<br>            if (rs.next()) {<br>                int id = rs.getInt(1);<br>                System.out.println(id);<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 获取表的元数据  </span><br><span class="line">所谓的元数据就是跟数据库有关的相关配置数据。  </span><br><span class="line">获取方法是使用connect的getMetaData()获取到DatabaseMetaData元数据库的数据模型。  </span><br><span class="line">之后，获取元数据对应的成员变量（类属性）  </span><br><span class="line">示例：</span><br></pre></td></tr></table></figure></p>
<p>package jdbc;</p>
<p>import java.sql.Connection;<br>import java.sql.DatabaseMetaData;<br>import java.sql.DriverManager;<br>import java.sql.ResultSet;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TestJDBC {</p>
<pre><code>public static void main(String[] args) throws Exception {
    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }

    try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);) {

        // 查看数据库层面的元数据
        // 即数据库服务器版本，驱动版本，都有哪些数据库等等

        DatabaseMetaData dbmd = c.getMetaData();

        // 获取数据库服务器产品名称
        System.out.println(&quot;数据库产品名称:\t&quot;+dbmd.getDatabaseProductName());
        // 获取数据库服务器产品版本号
        System.out.println(&quot;数据库产品版本:\t&quot;+dbmd.getDatabaseProductVersion());
        // 获取数据库服务器用作类别和表名之间的分隔符 如test.user
        System.out.println(&quot;数据库和表分隔符:\t&quot;+dbmd.getCatalogSeparator());
        // 获取驱动版本
        System.out.println(&quot;驱动版本:\t&quot;+dbmd.getDriverVersion());

        System.out.println(&quot;可用的数据库列表：&quot;);
        // 获取数据库名称
        ResultSet rs = dbmd.getCatalogs();

        while (rs.next()) {
            System.out.println(&quot;数据库名称:\t&quot;+rs.getString(1));
        }

    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}<br>```<br> <strong>尝试练习：当插入一条数据之后，通过获取自增长id，得到这条数据的id，比如说是55，删除这条数据的前一条，54.如果54不存在，则删除53，以此类推直到删除上一条数据。</strong>  </p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>图书管理系统，在可视化界面里面，完成图书的增加、修改、删除和查询操作。</p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第五节mysql基础]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%BA%94%E8%8A%82mysql%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库"></a>关于数据库</h3><p>数据库是存储数据的仓库，通过数据库，可以将我们的数据持久化的存储起来。<br>到目前为止，我们接触的数据都是非持久化的数据，均是和我们的程序同生共死的，一个死了，另一个就得去殉情的那种。<br>这样做，会带来什么问题呢？<br>数据无法持久，随着软件的关闭，用户所有的操作数据一并消失。  </p>
<h3 id="关于MYSql"><a href="#关于MYSql" class="headerlink" title="关于MYSql"></a>关于MYSql</h3><p>My不是我的意思，是创始人女儿名字的缩写。   </p>
<h3 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装mysql服务</h3><p> <strong>需注意几点：</strong><br><img src="https://images.gitee.com/uploads/images/2018/0814/092227_9555c481_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>这个位置需要选择complete安装。<br><img src="https://images.gitee.com/uploads/images/2018/0814/092331_99aa0bc0_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>密码设置，一定要设置一个密码，并且需要勾选下面部分，表示允许其他用户访问数据库。<br>如果不勾选，就只能本机访问了，其他网络范围内的客户端无法进行本数据库的访问。  </p>
<h3 id="安装navicat"><a href="#安装navicat" class="headerlink" title="安装navicat"></a>安装navicat</h3><p>无需多说，全部默认安装即可。<br> <strong>连接本地mysql服务步骤如下：</strong><br>第一步：<br><img src="https://images.gitee.com/uploads/images/2018/0814/092845_6eabcfb6_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>第二步：<br><img src="https://images.gitee.com/uploads/images/2018/0814/092919_74485b83_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>此处的连接名随意起名，主机和ip输入本机ip，本机的话可以输入localhost或者127.0.0.1<br>端口号默认为3306，密码输入自己的密码即可。  </p>
<h3 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h3><p>语法结构：<br>create database 数据库名<br>例子：<br><img src="https://images.gitee.com/uploads/images/2018/0814/093442_501d8423_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>语法结构：<br>create table 表名 (字段名 字段类型)<br>例子：<br><img src="https://images.gitee.com/uploads/images/2018/0814/104349_f36ccc24_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0814/105524_70a0ef64_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h3><p>语法结构：<br>insert into 表名 values(数据1，数据2，…..);<br>例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into hero values (null, &apos;盖伦&apos;, 616, 100)</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>语法结构：<br>select 字段名或者* from 表名</p>
<ol>
<li>查询所有数据<br>例子：<br>select * from hero </li>
<li>统计表中有多少数据<br>例子：<br>select count(*) from hero  </li>
<li>分页查询，查询前多少条数据<br>例子：<br>select * from hero limit 0,5  <h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3>语法结构：<br>update 表名 set 字段名=字段值<br>例子：<br>update hero set hp = 818 where id = 1<br><img src="https://images.gitee.com/uploads/images/2018/0814/111852_3a4c6776_87680.png" alt="输入图片说明" title="屏幕截图.png">  <h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3>语法结构：<br>delete from 表名 where 条件<br>例子：<br>delete from hero where id = 1<br><img src="https://images.gitee.com/uploads/images/2018/0814/112045_e72f50f3_87680.png" alt="输入图片说明" title="屏幕截图.png">  <h3 id="备份和还原"><a href="#备份和还原" class="headerlink" title="备份和还原"></a>备份和还原</h3>使用navicat备份还原即可  <h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3>表示mysql的一个数据库引擎  </li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>构建自己的数据库  library  </li>
<li>新建数据库表，字段和字段类型自己去设计，主要需要几个表？  </li>
<li>练习数据库操作的主要语句，即增删改查。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第四节java的接口和抽象类]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%9B%9B%E8%8A%82java%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="温习一个接口的例子"><a href="#温习一个接口的例子" class="headerlink" title="温习一个接口的例子"></a>温习一个接口的例子</h3><ol>
<li>设计一个英雄类  </li>
<li>设计一个物理攻击的接口。  </li>
<li>设计一类英雄，能够使用物理攻击  </li>
<li>设计一个魔法攻击的接口  </li>
<li>设计一类英雄，能够使用魔法攻击  </li>
<li>设计一类应用，既能使用物理攻击，又可以使用魔法攻击  </li>
<li><p>思考一个问题，什么情况下使用接口呢？  </p>
<p><strong>对于第七个问题，我们暂时只有一个初步的感官，对接口仅仅理解其使用场景，真正意义上为什么使用接口现在还是一知半解</strong><br><strong>结合我们之前学习的多态的知识点，我们可以更加深入的认识接口</strong><br><em>尝试编写程序</em><br>新建一个英雄，盖伦。<br>新建三个英雄，分别为物理攻击英雄、魔法攻击英雄和物理魔法攻击英雄。<br>盖伦干掉三个英雄。  </p>
</li>
</ol>
<p>使用接口去实现：  </p>
<ol>
<li>设计一个接口<br>接口叫做Mortal,其中有一个方法叫做die  </li>
<li>实现接口<br>分别让ADHero,APHero,ADAPHero这三个类，实现Mortal接口，不同的类实现die方法的时候，都打印出不一样的字符串  </li>
<li>为Hero类，添加一个方法,在这个方法中调用 m的die方法。 </li>
<li>在主方法中测试  </li>
</ol>
<h3 id="接口的由来"><a href="#接口的由来" class="headerlink" title="接口的由来"></a>接口的由来</h3><p><img src="https://images.gitee.com/uploads/images/2018/0810/100957_103e8f8c_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0810/101012_22b07da3_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0810/101035_7fa6a33a_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>如何解决上述问题呢？  </p>
<p>限制只有他的子类才可以被初始化．通过这种限制来解决上述问题．<br>让类不可以被new出来，就实现了我们所说的需求．<br>使用abstract关键字进行抽象类的声明，语法结构如下：<br><img src="https://images.gitee.com/uploads/images/2018/0810/132126_12cc903e_87680.png" alt="输入图片说明" title="2018-08-10 13-21-16屏幕截图.png"><br> <strong>尝试练习，新建animal的抽象类，测试一下该抽象类是否可以被new</strong><br> <strong>尝试练习，新建animal的子类，观察其子类的特点，能否可以new一个子类之后，将new出来的地址指向父类的引用类型呢？</strong>  </p>
<blockquote>
<p>抽象类除了被继承过之外，是没有用途，没有值，没有目的的．  </p>
</blockquote>
<p> <img src="https://images.gitee.com/uploads/images/2018/0810/134327_5425df03_87680.png" alt="输入图片说明" title="2018-08-10 13-43-16屏幕截图.png">  </p>
<p> <strong>除此之外，方法也有抽象方法．抽象方法必须存在与抽象类里面，不可以出现在普通里面．</strong>  </p>
<p>抽象方法的语法结构：<br><img src="https://images.gitee.com/uploads/images/2018/0810/141934_f1faf645_87680.png" alt="输入图片说明" title="2018-08-10 14-19-23屏幕截图.png"><br> <em>继承了抽象类的子类，必须实现抽象类所有的抽象方法</em>  </p>
<h3 id="我们学习了抽象类，继承和接口，那么到底这么做有哪些好处呢？"><a href="#我们学习了抽象类，继承和接口，那么到底这么做有哪些好处呢？" class="headerlink" title="我们学习了抽象类，继承和接口，那么到底这么做有哪些好处呢？"></a>我们学习了抽象类，继承和接口，那么到底这么做有哪些好处呢？</h3><p> <strong>就是为了使用多态</strong><br>典型实例：<br>我们考虑一下arrayList这个类，他可以放置任何类型的对象或者任何类型的基础数据类型．<br>假如，我们从功能的角度触发，去开发一个arraylist类，那么需要怎么去做呢？  </p>
<ol>
<li>创建一个Dog专用的list<br>数据用来保存数据，nextIndex作为下标，只要下标小于数组长度便可以进行数据的存入<br><img src="https://images.gitee.com/uploads/images/2018/0810/145710_1259b59f_87680.png" alt="输入图片说明" title="2018-08-10 14-56-59屏幕截图.png"><br><strong>尝试根据上述类图进行代码的实现</strong>  </li>
</ol>
<p><img src="https://images.gitee.com/uploads/images/2018/0810/152955_4b4a41d8_87680.png" alt="输入图片说明" title="2018-08-10 15-29-44屏幕截图.png">  </p>
<ol>
<li>如果要求我们的list支持cat对象的存入呢？<br>有如下几种方案：<br>创建一个单独的MyCatList专门用来存放cat类<br>创建一个单独的MyCatAndDogList类，分别有两个方法，用来存放dog和cat<br>编写一个AnimalList类，可以处理当前animal对应的所以子类  </li>
</ol>
<p>选择第几种方案呢？第三种方案基于继承的原理，如何去实现呢？  </p>
<p> <img src="https://images.gitee.com/uploads/images/2018/0810/153318_c16bbcbb_87680.png" alt="输入图片说明" title="2018-08-10 15-33-09屏幕截图.png">  </p>
<p> <strong>思考一下，假如在整个动物的设计类里面，引入一个宠物类，我们需要如何进行相关设计呢？</strong><br>方法一：<br><img src="https://images.gitee.com/uploads/images/2018/0810/165748_e05f332b_87680.png" alt="输入图片说明" title="2018-08-10 16-57-20屏幕截图.png"><br>方法二：<br><img src="https://images.gitee.com/uploads/images/2018/0810/165947_0e4852d4_87680.png" alt="输入图片说明" title="2018-08-10 16-59-28屏幕截图.png"><br>方法三：<br><img src="https://images.gitee.com/uploads/images/2018/0810/170058_5b3ba05a_87680.png" alt="输入图片说明" title="2018-08-10 17-00-38屏幕截图.png"><br>我们是不是需要继承两个类呢？  </p>
<blockquote>
<p>显然，java没有这种设计，他有更好的设计，那就是接口.  </p>
</blockquote>
<p>接口是百分之百的抽象类，在其中没有任何的实现方法．  </p>
<p>接口的定义：<br><img src="https://images.gitee.com/uploads/images/2018/0810/171035_251c5333_87680.png" alt="输入图片说明" title="2018-08-10 17-07-48屏幕截图.png"><br>接口的实现：<br><img src="https://images.gitee.com/uploads/images/2018/0811/063147_5ba91b37_87680.png" alt="输入图片说明" title="2018-08-11 06-31-37屏幕截图.png"><br>设计和实现宠物接口：<br><img src="https://images.gitee.com/uploads/images/2018/0811/063309_940b52c6_87680.png" alt="输入图片说明" title="2018-08-11 06-32-37屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0811/063441_d279a3cc_87680.png" alt="输入图片说明" title="2018-08-11 06-34-33屏幕截图.png">  </p>
<p>总结：  </p>
<blockquote>
<p>extends只能有一个,implement可以有多个．类来自单亲家庭（supperclass），单可以扮演多种角色（implement）  </p>
</blockquote>
<h3 id="概念延伸"><a href="#概念延伸" class="headerlink" title="概念延伸"></a>概念延伸</h3><ol>
<li>隐藏<br>重写是子类覆盖父类的对象方法，隐藏则是子类覆盖父类的类方法．  </li>
<li>super<br>该关键字在子类中使用，表示子类去调用父类的属性或者方法．  </li>
<li>Object<br>该类是所有对象的父类<br>默认新建的所以子类均继承该类，该类提供一个默认的toString()方法．<br>finalize也是其默认提供的方法之一，实现类的回收，这个方法是jvm自动触发的．<br>equals(),==(非object的方法，进行两个对象引用的判断)  </li>
<li>final<br>为修饰符，当类为final的时候，该类不可以被继承<br>修饰方法的时候，表示该方法不可以被重写<br>修饰基本数据类型，该变量值可以被赋值一次．<br>修饰引用，则只可以被指向实际对象一次<br>可以设计一个常量，表示不会改变，始终确定的一个值  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int itemTotalNumber = 6;//物品栏的数量</span><br></pre></td></tr></table></figure>
<ol>
<li>内部类<br>非静态内部类<br>语法: new 外部类().new 内部类()  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private String name; // 姓名</span><br><span class="line"> </span><br><span class="line">    float hp; // 血量</span><br><span class="line"> </span><br><span class="line">    float armor; // 护甲</span><br><span class="line"> </span><br><span class="line">    int moveSpeed; // 移动速度</span><br><span class="line"> </span><br><span class="line">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    // 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    class BattleScore &#123;</span><br><span class="line">        int kill;</span><br><span class="line">        int die;</span><br><span class="line">        int assit;</span><br><span class="line"> </span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;= 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen = new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">        // 实例化内部类</span><br><span class="line">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        // 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">        BattleScore score = garen.new BattleScore();</span><br><span class="line">        score.kill = 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">静态内部类  </span><br><span class="line">与非静态内部类不同，静态内部类水晶类的实例化 不需要一个外部类的实例为基础，可以直接实例化  </span><br><span class="line">语法：  </span><br><span class="line">new 外部类.静态内部类();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;</p>
<pre><code>private static void battleWin(){
    System.out.println(&quot;battle win&quot;);
}

//敌方的水晶
static class EnemyCrystal{
    int hp=5000;

    //如果水晶的血量为0，则宣布胜利
    public void checkIfVictory(){
        if(hp==0){
            Hero.battleWin();

            //静态内部类不能直接访问外部类的对象属性
            System.out.println(name + &quot; win this game&quot;);
        }
    }
}

public static void main(String[] args) {
    //实例化静态内部类
    Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();
    crystal.checkIfVictory();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6. 默认方法  </span><br><span class="line">jdk8新增特性</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>public interface Mortal {<br>    public void die();</p>
<pre><code>default public void revive() {
    System.out.println(&quot;本英雄复活了&quot;);
}
</code></pre><p>}<br>```<br>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动.  </p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法  </p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类  </p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p><img src="https://images.gitee.com/uploads/images/2018/0811/072732_ef09e45a_87680.png" alt="输入图片说明" title="2018-08-11 07-27-07屏幕截图.png"><br> <strong>作业１</strong>  </p>
<ol>
<li>创建Animal类，它是所有动物的抽象父类。  </li>
<li>声明一个受保护的整数类型属性legs，它记录动物的腿的数目。  </li>
<li>定义一个受保护的构造器，用来初始化legs属性。  </li>
<li>声明抽象方法eat。  </li>
<li>声明具体方法walk来打印动物是如何行走的（包括腿的数目）。<br><strong>作业２</strong>  </li>
<li>Spider继承Animal类。  </li>
<li>定义默认构造器，它调用父类构造器来指明所有蜘蛛都是8条腿。  </li>
<li>实现eat方法<br><strong>作业３</strong><br>根据UML类创建pet（宠物）接口  </li>
<li>提供getName() 返回该宠物的名字  </li>
<li>提供setName(String name) 为该宠物命名  </li>
<li>提供 play()方法<br><strong>作业４</strong><br>Cat类  </li>
<li>该类必须包含String属性来存宠物的名字。  </li>
<li>定义一个构造器，它使用String参数指定猫的名字；该构造器必须调用超类构造器来指明所有的猫都是四条腿。  </li>
<li>另定义一个无参的构造器。该构造器调用前一个构造器（用this关键字）并传递一个空字符串作为参数  </li>
<li>实现Pet接口方法。  </li>
<li>实现eat方法。<br><strong>作业５</strong>  </li>
<li>创建Fish类，它继承Animal类  </li>
<li>重写Animal的walk方法以表明鱼不能走且没有腿。   </li>
<li>实现Pet接口  </li>
<li>无参构造方法  </li>
<li>提供一个private 的name属性  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第三节java多态]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%89%E8%8A%82java%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<h3 id="上节课的遗留问题"><a href="#上节课的遗留问题" class="headerlink" title="上节课的遗留问题"></a>上节课的遗留问题</h3><p>父类的private方法无法继承，那么private的属性是如何实现继承的呢？  </p>
<h3 id="知识点插入"><a href="#知识点插入" class="headerlink" title="知识点插入"></a>知识点插入</h3><p> <strong>类型转换</strong><br> <em>不同类型之间的数据可以互相转换，但是要满足一定的规则</em><br> <strong>转换规则:</strong>   </p>
<ol>
<li>精度高的数据类型就像容量大的杯子，可以放更大的数据 </li>
<li>精度低的数据类型就像容量小的杯子，只能放更小的数据 </li>
<li>小杯子往大杯子里倒东西，大杯子怎么都放得下 </li>
<li>大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出 </li>
<li>需要注意的一点是 </li>
<li>虽然short和char都是16位的，长度是一样的,但是彼此之间，依然需要进行强制转换<br><img src="https://images.gitee.com/uploads/images/2018/0807/171858_5242d1d9_87680.png" alt="输入图片说明" title="2018-08-07 17-18-49屏幕截图.png"><br><strong>低精度向高精度转换</strong>  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long l = 50;</span><br><span class="line">int i = 50;</span><br><span class="line">```  </span><br><span class="line">l 是long类型的，其类型长度是64位  </span><br><span class="line">i 是int类型的，其类型长度是32位  </span><br><span class="line">所以l的精度，比i的精度要高  </span><br><span class="line">l = i;  </span><br><span class="line">把i的值赋给l， 首先l和i彼此的类型是不一样的，那么能否转换就取决于彼此的精度  </span><br><span class="line">这个例子，是低精度向高精度转换 是可以正常转换的  </span><br><span class="line">换句话说，int比较小，要放进比较大的long,随便怎么样，都放的进去  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0807/173748_183b6ba4_87680.png &quot;2018-08-07 17-37-41屏幕截图.png&quot;)  </span><br><span class="line"> **高精度向低精度转换**</span><br></pre></td></tr></table></figure>
<p>byte b = 5;<br>int i1 = 10;<br>int i2 = 300;<br>b = i1;<br>b=i2;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">b的类型是byte,其长度是8，最大只能放127  </span><br><span class="line">i1 的类型是int, 其长度是32,最大，反正就是很大了，超过127  </span><br><span class="line">所以， 把int类型的数据转成为byte类型的数据，是有风险的  </span><br><span class="line">有的时候是可以转换的，比如 b = i1 (i1=10);  </span><br><span class="line">有的时候不可以转换 比如 b= i2 (i2=300) 因为放不下了  </span><br><span class="line">编译器就会提示错误  </span><br><span class="line">这个时候就只能采用强制转换，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0807/174003_b93f2b6e_87680.png &quot;2018-08-07 17-39-56屏幕截图.png&quot;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 对象转型  </span><br><span class="line"> **明确引用类型与对象类型的概念**  </span><br><span class="line">首先，明确引用类型与对象类型的概念  </span><br><span class="line">在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad  </span><br><span class="line">对象是有类型的， 是ADHero  </span><br><span class="line">引用也是有类型的，是ADHero  </span><br><span class="line">通常情况下，引用类型和对象类型是一样的  </span><br><span class="line">接下来要讨论的类型转换的问题，指的是引用类型和对象类型不一致的情况下的转换问题  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0807/170015_d6c21b42_87680.png &quot;2018-08-07 17-00-09屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;</p>
<pre><code>public static void main(String[] args) {

    ADHero ad = new ADHero();

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> **子类转父类(向上转型)**   </span><br><span class="line">&gt; 所谓的转型，是指当引用类型和对象类型不一致的时候，才需要进行类型转换</span><br><span class="line">类型转换有时候会成功，有时候会失败</span><br></pre></td></tr></table></figure></p>
<p>Hero h = new Hero();<br>ADHero ad = new ADHero();<br>h = ad;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">所有的子类转换为父类，都是说得通的  </span><br><span class="line">苹果手机 继承了 手机，把苹果手机当做普通手机使用  </span><br><span class="line">怡宝纯净水 继承了 饮品， 把怡宝纯净水 当做饮品来使用  </span><br><span class="line">苍老师 继承了动物， 把苍老师 。。。  </span><br><span class="line"> **父类转子类(向下转型)**   </span><br><span class="line">父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。  </span><br><span class="line">强制转换的意思就是 转换有风险，风险自担。  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0807/180052_96921437_87680.png &quot;2018-08-07 18-00-38屏幕截图.png&quot;)![输入图片说明](https://images.gitee.com/uploads/images/2018/0807/180113_03e85de9_87680.png &quot;2018-08-07 18-01-05屏幕截图.png&quot;)</span><br><span class="line"></span><br><span class="line"> **没有继承关系的两个类，互相转换**   </span><br><span class="line"> _没有继承关系的两个类，互相转换，一定会失败_  </span><br><span class="line">### 多态是如何运行的？  </span><br><span class="line"> **一般的声明引用和创建对象的方法**  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/083728_354ad95c_87680.png &quot;屏幕截图.png&quot;) ![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/083739_38c49d51_87680.png &quot;屏幕截图.png&quot;)![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/083750_cb56f085_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"> _重点是什么呢？_  </span><br><span class="line">引用类型和对象的类型必须相符，否则会编译错误！  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/083857_f264fe80_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"> **多态下，引用类型和对象类型则可以不相符**  </span><br><span class="line"> ![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/132402_9e5b732e_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"> 不过，满足以上多态下的引用类型和对象类型可以不相符的前提是引用类型是实际对象类型的父类。  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/132609_052738d5_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"> **不仅类可以多态，参数和返回类型也可以多态**  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/133232_64d0b3b6_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0809/133244_164aed57_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line">&gt; 通过多态，我们可以设计出引进新型子类时不必修改代码的程序。  </span><br><span class="line"></span><br><span class="line">### 深入理解多态  </span><br><span class="line"> **操作符的多态**  </span><br><span class="line"> _同一个操作符在不同情境下，具备不同的作用.如果+号两侧都是整型，那么+代表 数字相加.如果+号两侧，任意一个是字符串，那么+代表字符串连接_</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;</p>
<pre><code>public static void main(String[] args) {

    int i = 5;
    int j = 6;
    int k = i+j; //如果+号两侧都是整型，那么+代表 数字相加

    System.out.println(k);

    int a = 5;
    String b = &quot;5&quot;;

    String c = a+b; //如果+号两侧，任意一个是字符串，那么+代表字符串连接
    System.out.println(c);

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**类的多态**  </span><br><span class="line">_都是同一个类型，调用同一个方法，却能呈现不同的状态_</span><br></pre></td></tr></table></figure></p>
<p>package property;</p>
<p>public class LifePotion extends Item {<br>    public void effect(){<br>        System.out.println(“血瓶使用后，可以回血”);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>package property;</p>
<p>public class MagicPotion extends Item{</p>
<pre><code>public void effect(){
    System.out.println(&quot;蓝瓶使用后，可以回魔法&quot;);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>package property;</p>
<p>public class Item {<br>    String name;<br>    int price;</p>
<pre><code>public void buy(){
    System.out.println(&quot;购买&quot;);
}
public void effect() {
    System.out.println(&quot;物品使用后，可以有效果 &quot;);
}

public static void main(String[] args) {
    Item i1= new LifePotion();
    Item i2 = new MagicPotion();
    System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;);
    i1.effect();
    System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);
    i2.effect();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**使用多态和不使用多态的区别**  </span><br><span class="line">_不使用多态_</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>import property.LifePotion;<br>import property.MagicPotion;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;</p>
<pre><code>public void useLifePotion(LifePotion lp){
    lp.effect();
}
public void useMagicPotion(MagicPotion mp){
    mp.effect();
}

public static void main(String[] args) {

    Hero garen =  new Hero();
    garen.name = &quot;盖伦&quot;;

    LifePotion lp =new LifePotion();
    MagicPotion mp =new MagicPotion();

    garen.useLifePotion(lp);
    garen.useMagicPotion(mp);

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对应非常多的方法的实现，逻辑比较混乱  </span><br><span class="line"></span><br><span class="line"> **使用多态的情况**</span><br></pre></td></tr></table></figure></p>
<p>package charactor;</p>
<p>import property.Item;<br>import property.LifePotion;<br>import property.MagicPotion;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;</p>
<pre><code>public void useItem(Item i){
    i.effect();
}

public static void main(String[] args) {

    Hero garen =  new Hero();
    garen.name = &quot;盖伦&quot;;

    LifePotion lp =new LifePotion();
    MagicPotion mp =new MagicPotion();

    garen.useItem(lp);
    garen.useItem(mp);     

}
</code></pre><p>}<br>```<br>只使用一个方法即可。</p>
<p> <strong>类的多态实现条件</strong>  </p>
<ol>
<li>父类（接口）引用指向子类对象</li>
<li>调用的方法有重写  </li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>植物大战僵尸，模拟垃圾桶僵尸、防护网僵尸、飞天僵尸和棒球僵尸的攻击方法，分别使用多态（编写一个参数为父类的多态方法）和非多态模拟。</p>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第二节java的继承]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%BA%8C%E8%8A%82java%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h3><p><img src="https://images.gitee.com/uploads/images/2018/0806/112511_36a485f1_87680.png" alt="![输入图片说明](https://images.gitee.com/uploads/images/2018/0806/112512_52c82d3f_87680.png &quot;屏幕截图.png&quot;)" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/112656_4730b441_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p><img src="https://images.gitee.com/uploads/images/2018/0806/112821_8e7f59c3_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><p><img src="https://images.gitee.com/uploads/images/2018/0806/112937_33aa6f30_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/113001_28aa1d74_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>典型实例</strong><br> <em>医生、外科医生和家庭医生</em><br>这两类医生都属于医生的类型。<br>医生具有一个实例变量，一个方法<br>外科医生可以进行手术，但是和传统的医生对应的手术方法有所不同，另外他还可以进行截肢操作。<br>家庭医生可以给出建议，并且可以联系医院进行对应的咨询。<br><img src="https://images.gitee.com/uploads/images/2018/0806/120558_9ba30ac0_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>思考</strong><br><img src="https://images.gitee.com/uploads/images/2018/0806/121113_80684ebb_87680.png" alt="输入图片说明" title="屏幕截图.png">   </p>
<h3 id="设计动物仿真程序的继承树"><a href="#设计动物仿真程序的继承树" class="headerlink" title="设计动物仿真程序的继承树"></a>设计动物仿真程序的继承树</h3><p><img src="https://images.gitee.com/uploads/images/2018/0806/121223_176518f9_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/121256_b9c97174_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/121336_31def53b_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/121420_86d16712_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/132323_1e8097dc_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0806/132338_5dbf11b5_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/132417_1eb828ab_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/132446_23459acf_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/132625_3596fb5d_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0806/132748_2ba01a8b_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><ol>
<li>避免了重复代码  </li>
<li>定义出了共同的协议  <h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3></li>
<li>设计植物大战僵尸里面的植物类，使用继承关系来进行父类和子类的模拟。  </li>
<li>设计植物大战僵尸里面的僵尸类，使用继承关系来进行父类和子类的模拟。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第一节深入探索javaOOP]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%80%E8%8A%82%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2javaOOP/</url>
      <content type="html"><![CDATA[<h3 id="面向对象的类"><a href="#面向对象的类" class="headerlink" title="面向对象的类"></a>面向对象的类</h3><ol>
<li>属性<br>属性就是类的状态。（比如图书的定价、出版社、出版时间等）</li>
<li>方法<br>能做什么，就是类的方法。（比如…）<br>图书是一个无方法的类，其实，正常项目中，我们的建议是把属性全部设置成private的，然后使用set和get方法来获取和存放属性。<br><em>使用set和get方法有什么意义呢？</em>  <ol>
<li>灵活性<br>比如，我们在学生类里面，每次获取学生姓名的时候，都希望前面加上一段文字：我的名字是：。  </li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;我的名字叫&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">2. 最主要的是安全性，对于类是一个封闭的黑盒子，才能符合安全性的规范。使得我们的类可以自定义一些只读或者只能写的权限。  </span><br><span class="line">### 面向对象的知识点总览  </span><br><span class="line">1. 引用  </span><br><span class="line">2. 继承  </span><br><span class="line">3. 方法重载  </span><br><span class="line">4. 构造函数  </span><br><span class="line">5. this  </span><br><span class="line">6. 传参  </span><br><span class="line">7. 包  _注意import_    </span><br><span class="line">8. 访问修饰符  private public protected default  </span><br><span class="line">9. 类属性 和对象属性的区别。注意一下静态关键字static  属性一旦被该关键字修饰,那么该属性被所有的对象共享，使用同一个值。  </span><br><span class="line">10. 类方法  静态方法。访问该方法不必建立在对象上面，使用类便可直接进行方法的访问。  </span><br><span class="line">11. 属性初始化  </span><br><span class="line">对象属性初始化：  </span><br><span class="line">声明该属性的时候初始化，构造函数中进行初始化，初始化块</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name = “some hero”; //声明该属性的时候初始化<br>    protected float hp;<br>    float maxHP;</p>
<pre><code>{
    maxHP = 200; //初始化块
}    

public Hero(){
    hp = 100; //构造方法中初始化

}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能相同，但是执行顺序是什么样的呢？  </span><br><span class="line">类属性初始化：  </span><br><span class="line">声明该属性的时候初始化、静态初始化块</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp;<br>    float maxHP;</p>
<pre><code>//物品栏的容量
public static int itemCapacity=8; //声明的时候 初始化

static{
    itemCapacity = 6;//静态初始化块 初始化
}

public Hero(){

}

public static void main(String[] args) {
    System.out.println(Hero.itemCapacity);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">12. 单例模式  </span><br><span class="line"></span><br><span class="line">&gt; 单例模式又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。  </span><br><span class="line"></span><br><span class="line">比如说：  </span><br><span class="line">LOL里有一个怪叫大龙GiantDragon，只有一只，所以该类，只能被实例化一次  </span><br><span class="line"> **饿汉式单例模式**</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class GiantDragon {</p>
<pre><code>//私有化构造方法使得该类无法在外部通过new 进行实例化
private GiantDragon(){

}

//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个

private static GiantDragon instance = new GiantDragon();

//public static 方法，提供给调用者获取12行定义的对象
public static GiantDragon getInstance(){
    return instance;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class TestGiantDragon {</p>
<pre><code>public static void main(String[] args) {
    //通过new实例化会报错
</code></pre><p>//        GiantDragon g = new GiantDragon();</p>
<pre><code>    //只能通过getInstance得到对象

    GiantDragon g1 = GiantDragon.getInstance();
    GiantDragon g2 = GiantDragon.getInstance();
    GiantDragon g3 = GiantDragon.getInstance();

    //都是同一个对象
    System.out.println(g1==g2);
    System.out.println(g1==g3);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**懒汉式单例模式**</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class GiantDragon {</p>
<pre><code>//私有化构造方法使得该类无法在外部通过new 进行实例化
private GiantDragon(){        
}

//准备一个类属性，用于指向一个实例化对象，但是暂时指向null
private static GiantDragon instance;

//public static 方法，返回实例对象
public static GiantDragon getInstance(){
    //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
    if(null==instance){
        instance = new GiantDragon();
    }
    //返回 instance指向的对象
    return instance;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class TestGiantDragon {</p>
<pre><code>public static void main(String[] args) {
    //通过new实例化会报错
</code></pre><p>//        GiantDragon g = new GiantDragon();</p>
<pre><code>    //只能通过getInstance得到对象

    GiantDragon g1 = GiantDragon.getInstance();
    GiantDragon g2 = GiantDragon.getInstance();
    GiantDragon g3 = GiantDragon.getInstance();

    //都是同一个对象
    System.out.println(g1==g2);
    System.out.println(g1==g3);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> **什么时候使用饿汉式，什么时候使用懒汉式**   </span><br><span class="line">饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载.  </span><br><span class="line">如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。  </span><br><span class="line"></span><br><span class="line">懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。  </span><br><span class="line">使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。  </span><br><span class="line"></span><br><span class="line">看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式  </span><br><span class="line"></span><br><span class="line"> _什么是单例模式？_   </span><br><span class="line">1. 构造方法私有化  </span><br><span class="line">2. 静态属性指向实例  </span><br><span class="line">3. public static的 getInstance方法，返回第二步的静态属性  </span><br><span class="line"></span><br><span class="line">13. 枚举类型  </span><br><span class="line">&gt; 预先定义的常量  </span><br><span class="line"></span><br><span class="line">枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常量  </span><br><span class="line">比如设计一个枚举类型 季节，里面有4种常量</span><br></pre></td></tr></table></figure>
<p>public enum Season {<br>    SPRING,SUMMER,AUTUMN,WINTER<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于switch语句。</span><br></pre></td></tr></table></figure></p>
<p>public class HelloWorld {<br>    public static void main(String[] args) {<br>        Season season = Season.SPRING;<br>        switch (season) {<br>        case SPRING:<br>            System.out.println(“春天”);<br>            break;<br>        case SUMMER:<br>            System.out.println(“夏天”);<br>            break;<br>        case AUTUMN:<br>            System.out.println(“秋天”);<br>            break;<br>        case WINTER:<br>            System.out.println(“冬天”);<br>            break;<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 使用枚举类型的好处  </span><br><span class="line"></span><br><span class="line">假设在使用switch的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）</span><br></pre></td></tr></table></figure>
<p>public class HelloWorld {<br>    public static void main(String[] args) {<br>        int season = 5;<br>        switch (season) {<br>        case 1:<br>            System.out.println(“春天”);<br>            break;<br>        case 2:<br>            System.out.println(“夏天”);<br>            break;<br>        case 3:<br>            System.out.println(“秋天”);<br>            break;<br>        case 4:<br>            System.out.println(“冬天”);<br>            break;<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 枚举类型的遍历  </span><br><span class="line"></span><br><span class="line">使用增强型for循环：</span><br></pre></td></tr></table></figure>
<p>public class HelloWorld {<br>    public static void main(String[] args) {<br>        for (Season s : Season.values()) {<br>            System.out.println(s);<br>        }<br>    }<br>}</p>
<p>```</p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>用户输入一个日期，月份即可，计算出该日期属于哪个季节(使用枚举)。  </li>
<li>练习set和get方法，改造图书管理系统的类（图书类，学生类，教师类，图书管理员类）。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java深入探索 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第十节JFRAME图形界面简介]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%8D%81%E8%8A%82JFRAME%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="基础知识总结（第一阶段）"><a href="#基础知识总结（第一阶段）" class="headerlink" title="基础知识总结（第一阶段）"></a>基础知识总结（第一阶段）</h3><ol>
<li>Hello World  </li>
<li>面向对象  </li>
<li>变量及引用  </li>
<li>操作符　（算数，关系，逻辑，位，赋值，三目运算符）  </li>
<li>控制流程（条件判断和循环语句）  </li>
<li>集合（数组，list和map）  </li>
<li>类和对象  </li>
<li>接口和继承  </li>
<li>常用api(字符串相关操作以及日期相关)  <h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><strong>三目运算符</strong><br><img src="https://images.gitee.com/uploads/images/2018/0802/082705_b7497981_87680.png" alt="输入图片说明" title="2018-08-02 08-26-52屏幕截图.png"><br><strong>日期相关操作</strong><br><em>注意：是java.util.Date; 而非 java.sql.Date，此类是给数据库访问的时候使用的，引入的包名一定注意</em>  </li>
<li>时间原点（时间是一个具体到计算机里面是一个数字，通过数字的大小体现出当前的时间）,java里面的时间是从1970年1月1日 8点0分0秒开始的，时间原点呢就是1970年1月1日　8点0秒（东八区）．此时的时间是0，之后没过1毫秒，该时间就会加1．　　</li>
<li>使用Date类来获取当前时间  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package date;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class TestDate &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		// 当前时间</span><br><span class="line">		Date d1 = new Date();</span><br><span class="line">		System.out.println(&quot;当前时间:&quot;);</span><br><span class="line">		System.out.println(d1);</span><br><span class="line">		System.out.println();</span><br><span class="line">		// 从1970年1月1日 早上8点0分0秒 开始经历的毫秒数</span><br><span class="line">		Date d2 = new Date(5000);</span><br><span class="line">		System.out.println(&quot;从1970年1月1日 早上8点0分0秒 开始经历了5秒的时间&quot;);</span><br><span class="line">		System.out.println(d2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取当前时间原点对应的时间，使用getTime()  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package date;</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class TestDate &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //注意：是java.util.Date;</span><br><span class="line">        //而非 java.sql.Date，此类是给数据库访问的时候使用的</span><br><span class="line">        Date now= new Date();</span><br><span class="line">        //打印当前时间</span><br><span class="line">        System.out.println(&quot;当前时间:&quot;+now.toString());</span><br><span class="line">        //getTime() 得到一个long型的整数</span><br><span class="line">        //这个整数代表 1970.1.1 08:00:00:000，每经历一毫秒，增加1</span><br><span class="line">        System.out.println(&quot;当前时间getTime()返回的值是：&quot;+now.getTime());</span><br><span class="line">         </span><br><span class="line">        Date zero = new Date(0);</span><br><span class="line">        System.out.println(&quot;用0作为构造方法，得到的日期是:&quot;+zero);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">4. 使用System.currentTimeMillis()获取  </span><br><span class="line">5. 日期转字符串</span><br></pre></td></tr></table></figure>
<p>package date;</p>
<p>//<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>public class TestDate {</p>
<pre><code>public static void main(String[] args) {

    //y 代表年
    //M 代表月
    //d 代表日
    //H 代表24进制的小时
    //h 代表12进制的小时
    //m 代表分钟
    //s 代表秒
    //S 代表毫秒
    SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; );
    Date d= new Date();
    String str = sdf.format(d);
    System.out.println(&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;+str);

    SimpleDateFormat sdf1 =new SimpleDateFormat(&quot;yyyy-MM-dd&quot; );
    Date d1= new Date();
    String str1 = sdf1.format(d1);
    System.out.println(&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;+str1);

}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 字符串转日期</span><br></pre></td></tr></table></figure>
<p>package date;</p>
<p>//<br>import java.text.ParseException;<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>public class TestDate {</p>
<pre><code>public static void main(String[] args) {
    SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot; );

    String str = &quot;2016/1/5 12:12:12&quot;;

    try {
        Date d = sdf.parse(str);
        System.out.printf(&quot;字符串 %s 通过格式  yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s&quot;,str,d.toString());
    } catch (ParseException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre><p>}</p>
<p>```</p>
<h3 id="我们需要图形图像界面"><a href="#我们需要图形图像界面" class="headerlink" title="我们需要图形图像界面"></a>我们需要图形图像界面</h3><p><img src="https://images.gitee.com/uploads/images/2018/0801/074757_4e9dd9ba_87680.png" alt="输入图片说明" title="2018-08-01 07-47-26屏幕截图.png"><br> <strong>因为图形图形界面的存在，才使得我们的程序更像一个程序．才使得我们的程序带来更好的用户体验．</strong>  </p>
<h3 id="如何创建图形界面呢？"><a href="#如何创建图形界面呢？" class="headerlink" title="如何创建图形界面呢？"></a>如何创建图形界面呢？</h3><p>如果我们自己去写程序，涉及到图像的底层编码格式，图形图像的专业知识，我们的压力会很大．<br>然而，java在其jdk里面已经提供了一个相对完善的图形类库，也就是一系列的图形图像的类和接口．<br>从而使我们在不必搞清底层图形图形接口和专业知识的情况下，便可以很好的完成图形图形程序软件的编写工作．  </p>
<h3 id="如何去写呢？"><a href="#如何去写呢？" class="headerlink" title="如何去写呢？"></a>如何去写呢？</h3><p>我们只要关心接口的传参，对象的构造即可．<br>再底层的东西，我们就不去讨论了，也不必去涉猎，那些交给jdk的专业人员去处理就行了．<br>我们要做的是上层应用设计，有客户有需求，我们解决需求就是了.<br>专业的人做专业的事情，我们的专业是上层应用，上层用户体验．<br>所以，暂时来说，底层的实现跟我们无关．<br><img src="https://images.gitee.com/uploads/images/2018/0801/075453_f0d7c10d_87680.png" alt="输入图片说明" title="2018-08-01 07-54-39屏幕截图.png">  </p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p> <strong>常用的事件</strong><br>没有事件的交互，界面仅仅是个界面而已．只有有了与客户的互动，整个软件才有了意义．<br><img src="https://images.gitee.com/uploads/images/2018/0802/085422_0bd12b65_87680.png" alt="输入图片说明" title="2018-08-02 08-54-13屏幕截图.png">  </p>
<h3 id="Idea中的swing编程"><a href="#Idea中的swing编程" class="headerlink" title="Idea中的swing编程"></a>Idea中的swing编程</h3><p>操作步骤：  </p>
<ol>
<li><p>新建idea的GUI，如下图所示：<br><img src="https://images.gitee.com/uploads/images/2018/0802/162345_e2f7dfdb_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
</li>
<li><p>得到form界面还有对应的java文件。form界面可以进行直接拖拽，免去了原始的代码布局的尴尬境地。<br><img src="https://images.gitee.com/uploads/images/2018/0802/162511_d690e1a0_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
</li>
<li><p>自动生成main函数代码。右键选择自动生成代码选项，然后选择formmain即可：<br><img src="https://images.gitee.com/uploads/images/2018/0802/162652_a2695d8d_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0802/162717_e7cf2d51_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<p><strong>注意</strong>  </p>
</li>
<li>顶层的panel一定要指定name，否则会提示生成失败。  </li>
<li>绑定事件的代码一定要放在构造函数里面。 </li>
</ol>
<h3 id="课上实验"><a href="#课上实验" class="headerlink" title="课上实验"></a>课上实验</h3><p> <strong>增加和删除学生信息</strong>  </p>
<p><img src="https://images.gitee.com/uploads/images/2018/0802/163754_7eab6a37_87680.png" alt="输入图片说明" title="屏幕截图.png"> </p>
<h3 id="课下作业（周五）"><a href="#课下作业（周五）" class="headerlink" title="课下作业（周五）"></a>课下作业（周五）</h3><ol>
<li>实现简单的计算器。</li>
</ol>
<h3 id="课下作业（周六周天）"><a href="#课下作业（周六周天）" class="headerlink" title="课下作业（周六周天）"></a>课下作业（周六周天）</h3><ol>
<li>实现简单的抽奖软件<br><img src="https://images.gitee.com/uploads/images/2018/0802/172547_669f822c_87680.png" alt="输入图片说明" title="屏幕截图.png"></li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第九节java类之间的协作]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B9%9D%E8%8A%82java%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="知识点插入"><a href="#知识点插入" class="headerlink" title="知识点插入"></a>知识点插入</h3><p> <strong>Switch语句</strong><br> 语法结构  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch(变量)&#123;</span><br><span class="line">case 变量值1:</span><br><span class="line">    //;</span><br><span class="line">    break;</span><br><span class="line">case 变量值2:</span><br><span class="line">    //...;</span><br><span class="line">    break;</span><br><span class="line">  ...</span><br><span class="line">case default:</span><br><span class="line">    //...;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"> **注意：swtich()变量类型只能是int、short、char、byte和enum类型。当进行case判断时，JVM会自动从上到小扫描，寻找匹配的case，可能存在以下情况：**   </span><br><span class="line">1. 情况一：若未找到，则执行默认的case。</span><br></pre></td></tr></table></figure>
<p>int i = 5;<br>        switch(i){<br>        case 0:<br>            System.out.println(“0”);break;<br>        case 1:<br>            System.out.println(“1”);break;<br>        case 2:<br>            System.out.println(“2”);break;<br>        default:<br>            System.out.println(“default”);break;<br>        }</p>
<p>输出：default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 当每一个case都不存在break时，JVM并不会顺序输出每一个case对应的返回值，而是继续匹配，匹配不成功则返回默认case。</span><br></pre></td></tr></table></figure></p>
<p>  int i = 5;<br>        switch(i){<br>        case 0:<br>            System.out.println(“0”);<br>        case 1:<br>            System.out.println(“1”);<br>case 2:<br>            System.out.println(“2”);<br>        default:<br>            System.out.println(“default”);<br>        }<br>输出：default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 情况三：当每一个case都不存在break时，匹配成功后，从当前case开始，依次返回后续所有case的返回值。</span><br></pre></td></tr></table></figure></p>
<p> int i = 2;<br>        switch(i){<br>        case 0:<br>            System.out.println(“0”);<br>        case 1:<br>            System.out.println(“1”);<br>        case 2:<br>            System.out.println(“2”);<br>        default:<br>            System.out.println(“default”);<br>        }</p>
<p>输出：2<br>     default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 若当前匹配成功的case不存在break，则从当前case开始，依次返回后续case的返回值，直到遇到break，跳出判断。</span><br></pre></td></tr></table></figure></p>
<p> int i = 2;<br>        switch(i){<br>        case 0:<br>            System.out.println(“0”);<br>        case 1:<br>            System.out.println(“1”);<br>        case 2:<br>            System.out.println(“2”);<br>        case 3:<br>            System.out.println(“3”);break;<br>        default:<br>            System.out.println(“default”);<br>        }</p>
<p>输出：2<br>     3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 权限知识  </span><br><span class="line">public：  </span><br><span class="line"></span><br><span class="line">具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。  </span><br><span class="line"></span><br><span class="line">protected：  </span><br><span class="line"></span><br><span class="line">主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西  </span><br><span class="line"></span><br><span class="line">default：  </span><br><span class="line"></span><br><span class="line">有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。  </span><br><span class="line"></span><br><span class="line">private：  </span><br><span class="line"></span><br><span class="line">访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。  </span><br><span class="line"></span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0801/162026_4730aba4_87680.png &quot;屏幕截图.png&quot;)  </span><br><span class="line"></span><br><span class="line"> **区别**  </span><br><span class="line">public：可以被所有其他类所访问  </span><br><span class="line"></span><br><span class="line">private：只能被自己访问和修改  </span><br><span class="line"></span><br><span class="line">protected：自身、子类及同一个包中类可以访问  </span><br><span class="line"></span><br><span class="line">default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 面向对象的基本概念  </span><br><span class="line">- 类  </span><br><span class="line">- 抽象类  必须有一个abstract的方法，至少一个。该抽象方法不必在抽象类里面实现，但是必须在继承其类的子类里面实现。 </span><br><span class="line">- 接口    接口可以理解为一个纯抽象的类，可以有成员变量，但是必须是静态的。其中的类均不需实现方法。在其实现类里面进行方法的实现。  </span><br><span class="line">继承使用关键字extends  实现使用关键字implements。一个类只能继承一个父类，但是可以实现多个接口。  </span><br><span class="line">上述的继承和实现接口的特点使得java编程存在无数可能，存在无数种解决问题的方法。  </span><br><span class="line"> **注意：**  </span><br><span class="line">1. 子类可以覆盖父类的方法，但是子类无法覆盖父类的成员变量(field).  </span><br><span class="line">2. 如果父类的方法为static或者final则不能被覆盖。  </span><br><span class="line">### 类的初始化过程  </span><br><span class="line">父类-&gt;field-&gt;构造函数（子类不去调用父类构造函数，缺省调用无参构造函数）-&gt;子类-&gt;field-&gt;构造函数  </span><br><span class="line"> **一言以蔽之：**</span><br><span class="line">上节课讲到的所有的复杂功能，都是java自带的api里面的一些class或者interface的用法。  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 一起设计一下LOL  </span><br><span class="line">**首先，需要设计一下英雄这个类**  </span><br><span class="line">&gt; LOL有很多英雄，比如盲僧，团战可以输，提莫必须死，盖伦，琴女  </span><br><span class="line"></span><br><span class="line">所有这些英雄，都有一些共同的状态  </span><br><span class="line">比如，他们都有名字，hp，护甲，移动速度等等  </span><br><span class="line">这样我们就可以设计一种东西，叫做类，代表英雄这样一种事物  </span><br><span class="line"></span><br><span class="line">类： 英雄(Hero)  </span><br><span class="line">状态： 名字, 血量，护甲，移动速度  </span><br><span class="line">类图如下：  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0727/170521_9dc8ac15_87680.png &quot;2018-07-27 17-05-13屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure>
<p>public class Hero {</p>
<pre><code>String name; //姓名

float hp; //血量

float armor; //护甲

int moveSpeed; //移动速度
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> **创建具体的英雄**  </span><br><span class="line">类就像一个模板，根据这样一个模板，可以创建一个个的具体的英雄  </span><br><span class="line">一个个具体的英雄，就叫一个个的对象   </span><br><span class="line">new Hero() 就是java中创建一个英雄对象的意思   </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0727/170933_6ea2d6aa_87680.png &quot;2018-07-27 17-08-05屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure>
<p>public class Hero {</p>
<pre><code>String name; //姓名

float hp; //血量

float armor; //护甲

int moveSpeed; //移动速度

public static void main(String[] args) {
    Hero garen =  new Hero();
    garen.name = &quot;盖伦&quot;;
    garen.hp = 616.28f;
    garen.armor = 27.536f;
    garen.moveSpeed = 350;

    Hero teemo =  new Hero();
    teemo.name = &quot;提莫&quot;;
    teemo.hp = 383f;
    teemo.armor = 14f;
    teemo.moveSpeed = 330;
}    
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**创建消耗品Item类**  </span><br><span class="line">设计出物品这种类  </span><br><span class="line">类名：Item  </span><br><span class="line">物品有如下属性:   </span><br><span class="line">名字 name 类型是字符串String  </span><br><span class="line">价格 price 类型是整型 int  </span><br><span class="line"></span><br><span class="line">创建(实例化)3件具体物品  </span><br><span class="line">名称 价格  </span><br><span class="line">血瓶 50  </span><br><span class="line">草鞋 300  </span><br><span class="line">长剑 350  </span><br><span class="line">  </span><br><span class="line">&gt; 在设计LOL的时候，进攻类英雄有两种，一种是进行物理系攻击，一种是进行魔法系攻击  </span><br><span class="line">&gt; 这时候，就可以使用接口来实现这个效果.  </span><br><span class="line">&gt; 接口就像是一种约定，我们约定某些英雄是物理系英雄，那么他们就一定能够进行物理攻击。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 物理攻击接口  </span><br><span class="line">创建一个接口，声明一个方法，但是没有方法体的实现．</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public interface AD {<br>        //物理伤害<br>    public void physicAttack();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 设计一类英雄，能够使用物理攻击  </span><br><span class="line"></span><br><span class="line"> **这类英雄首先继承了Hero 类，所以继承了name,hp,armor等属性**  </span><br><span class="line">**实现某个接口，就相当于承诺了某种约定**  </span><br><span class="line">**该类英雄实现物理攻击接口，同时必须实现接口的方法**</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class ADHero extends Hero implements AD{</p>
<pre><code>@Override
public void physicAttack() {
    System.out.println(&quot;进行物理攻击&quot;);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 创建魔法攻击接口</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public interface AP {</p>
<pre><code>public void magicAttack();
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 设计一类英雄，只能使用魔法攻击</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class APHero extends Hero implements AP{</p>
<pre><code>@Override
public void magicAttack() {
    System.out.println(&quot;进行魔法攻击&quot;);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 设计一类英雄，既能进行物理攻击，又能进行魔法攻击</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>//同时能进行物理和魔法伤害的英雄<br>public class ADAPHero extends Hero implements AD,AP{</p>
<pre><code>@Override
public void magicAttack() {
    System.out.println(&quot;进行魔法攻击&quot;);
}

@Override
public void physicAttack() {
    System.out.println(&quot;进行物理攻击&quot;);
}
</code></pre><p>}</p>
<p>```<br> <strong>新建英雄，进行测试</strong> </p>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第八节常用api]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%85%AB%E8%8A%82%E5%B8%B8%E7%94%A8api/</url>
      <content type="html"><![CDATA[<h3 id="api定义"><a href="#api定义" class="headerlink" title="api定义"></a>api定义</h3><p> <strong>api是应用程序接口</strong><br>我们经常听到很多做软件的人挂在嘴边的一句话： <strong>接口对接</strong><br>接口对接呢，长见于多个系统之间的协作．<br>其实，严格意义上来说,jdk也是一个系统．我们和jdk的对接，也就称之为jdk的api．<br>根据jdk提供的接口，使得我们的程序符合api的规范，从而翻译成java可识别的格式,最终生成class文件并执行class文件．  </p>
<h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>我们在开始常用api讲解之前，先了解一下java的一些保留关键字．这些关键字不可被重新定义，因为其已经在jdk里面被定义了，再次定义的话将会二次定义，从而引发错误．<br>既然保留关键字是jdk的一部分，那么，可以说保留关键字也是api的一部分.<br>常见保留关键字如下：<br><img src="https://images.gitee.com/uploads/images/2018/0724/121441_dc72f7c6_87680.png" alt="输入图片说明" title="2018-07-24 12-14-25屏幕截图.png"><br> <strong>上节课我们所说的，打印还有随机数，都是java常用api的一部分．</strong><br> <strong>总结一下api的定义就是：java提供的开发工具包，因为他的存在使得一些底层比较复杂的业务逻辑变成了一些既有的方法，从而使得我们不必关心底层逻辑也能写出比较高效的功能，设计出优秀的软件程序．</strong><br> <em>大家可能此时会有一些疑问了，java是不是不关心底层呢？也就是说，我们学完java之后，我们的底层代码能力是不是得不到提高，一直非常弱呢？一般的程序设计确实不需要关系底层，然而对于jdk这种开源的开发工具包而言，其中的很多经典方法都是sun公司开源的．我们都可以看到，同时也能去修改，把jdk修改完善适配成适合我们软件开发需要的特色jdk</em><br> <strong>比如阿里，其jdk就是自己的，其中的高并发的一些逻辑实现，是原始的jdk不能比拟的．</strong><br>说到这里，我们的软件开发一定要遵循一个原则，站在巨人的肩膀上，也就是开源的思想．有些存在的工具，拿过来能用则用，不能用的话，修改修改也能用．总之呢，不要重复的去造轮子．  </p>
<h3 id="JDK-gt-JAVA函数库"><a href="#JDK-gt-JAVA函数库" class="headerlink" title="JDK-&gt;JAVA函数库"></a>JDK-&gt;JAVA函数库</h3><p><img src="https://images.gitee.com/uploads/images/2018/0725/063140_f9bf20ce_87680.png" alt="输入图片说明" title="2018-07-25 06-31-26屏幕截图.png"><br> <strong>System</strong>  </p>
<ol>
<li>输入输出流  </li>
</ol>
<ul>
<li>System.out  </li>
<li>System.err  </li>
<li>System.in<br>另外，可以指定输入输出流的位置，这也是早期的java日志设计的雏形，使用格式如下：  </li>
<li>System.setOut(PrintStream) 标准输出重定向  </li>
<li>System.setErr(PrintStream) 标准错误输出重定向  </li>
<li>System.setIn(InputStream) 标准输入重定向  (指定一个文件，读取其中的数据并输出)</li>
</ul>
<ol>
<li>获取当前时间<br>long beginTime = System. currentTimeMillis();<br>所取到的时间是从 1970/01/01 以来 1/1000 秒计算的 long 型值。这个值可以转换至 Date 或 Timestamp 值。 它一般还可以用来计算程序执行的时间。  </li>
<li>数组拷贝<br>System.arraycopy( Object src,int src_position,Object dst,int dst_position,int length)<br>源数组，源数组拷贝开始位置，目标数组，目标数组的开始位置，长度<br>说道数组拷贝，我们简单说一下数组，数组就是一个容器，这个容器呢只能装一类的东西。比如，茅台瓶子里面是不能装五粮液的，混了容易醉，醉了容易犯错误。<br>我们说的基础数据类型都可以放到数组里面。<br>main函数里面也有一个数组,String args[].<br>我们模仿一下数组的定义 int a[] = {1,2,3,4,5}<br>该方法的拷贝效率是最高的。  </li>
<li>获取系统属性  </li>
</ol>
<p>System.getProperties() ：取得当前所有的 Properties ， Properties 将在后面的集<br>合一节进行详细的论述。<br>System.setProperties(Properties props) ：设置系统的 Properties 。<br>System.getProperty(String key) ： 根据一个键值来取得一个 Property 。<br>System.setProperty(String key, String value) ： 设置系统的一个 Property</p>
<p><img src="https://images.gitee.com/uploads/images/2018/0725/115913_47363e36_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<ol>
<li><p>其他<br>System. loadLibrary(String libname)  jni加载类库。  </p>
<p><strong>String和StringBuffer</strong>  </p>
</li>
</ol>
<p><img src="https://images.gitee.com/uploads/images/2018/0725/120417_3d677fc4_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0725/120619_d0ad23a2_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0725/120703_37e9060d_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <em>StringBuffer</em><br><img src="https://images.gitee.com/uploads/images/2018/0725/120816_96372f09_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="数值，字符，布尔对象与简单类型的操作"><a href="#数值，字符，布尔对象与简单类型的操作" class="headerlink" title="数值，字符，布尔对象与简单类型的操作"></a>数值，字符，布尔对象与简单类型的操作</h3><p><img src="https://images.gitee.com/uploads/images/2018/0725/120930_62071556_87680.png" alt="输入图片说明" title="屏幕截图.png"><br>  <img src="https://images.gitee.com/uploads/images/2018/0725/120943_5cbbfb1f_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<p> <strong>Class, ClassLoader</strong><br>Java 是一种介于解释与编绎之间的语言，Java 代码首先编绎成字节码，在运行的时候再翻译成机器码。这样在运行的时候我们就可以通过Java提供的反射方法 (reflect) 来得到一个 Object的Class 的额外信息，灵活性很大，可以简化很多操作.<br>Class: 任何一个 Object 都能通过 getClass()这个方法得到它在运行期间的 Class。得到这个 Class之后可做的事情就多了,比如动态得到它的构造函数,成员变量,方法等等.还可以再生成一份新的实例.<br>下面只给出几个我们常用的方法， 更详细的用法参照 JavaAPIClass Class.forName(String className) throws ClassNotFoundException ：这是个静态方法，通过一个 Class 的全称来得到这个 Class.<br>String getName() 取得这个 Class 的全称， 包括 package 名.<br>Object newInstance() 得到一个实例， 调用缺省的构造函数.<br>例如我们有一个类： com.some.util.MyClass 如果得到它的一个实例呢？ 可能有以下两种方法:  </p>
<ol>
<li>MyClass myClass = new MyClass() ， 直接通过操作符 new 生成；  </li>
<li>MyClass myClass = (MyClass) Class.forName( “ com.some.util.MyClass ” ).newInstance();  </li>
</ol>
<p>也许有人就会怀疑第二种方法实际意义， 能够直接 new 出来干嘛绕弯。 但实际上它的用处却很大.<br>举个例子： 用过 struts 的人都知道， 在 action-config.xml 当中定义了一系列的 formBean 与actionBean， 当然每个 form 与 action 都具有同类型， 这样在一个 request 过来的时候我可以动态的生成一个 form 与 action 的实例进行具体的操作， 但在编码的时候我并不知道具体是何种的form 与 action， 我只调用它们父类的方法。 你如果要用第一种方法的话， 你得在编码的时候通过一个标志来判断每一次 request 需要具体生成的 form 与 action，代码的灵活性大大降低。<br>总的来说在面向接口的编程当中经常使用这种方法， 比如不同数据库厂家的 JDBC Driver 都是从标准的 JDBC 接口继承下去的， 我们在写程序的时候用不着管最终是何种的 Driver ， 只有在运行的时候确定.<br>还有 XML 的 Parser也是， 我们使用的只是标准的接口， 最后到底是谁来实现它的， 我们用不着去管。<br>ClassLoader: ClassLoader 是一个抽象类，一般的系统有一个缺省的 ClassLoader 用来装载Class， 用 ClassLoader.getSystemClassLoader() 可以得到。不过有时候为了安全或有其它的特殊需要我们可以自定义自己的 ClassLoader 来进行 loader 一些我们需要的 Class.<br>比如有的产品它用了自己的 ClassLoader 可以指定 Class 只从它指定的特定的 JAR 文件里面来 loader，如果你想通过覆盖 ClassPath 方法来想让它用你的 Class 是行不通的。 有兴趣的可以参照 JavaAPI 的更详细的用法</p>
<p><strong>Java IO 系统</strong><br>文件流相关的文件或接口：<br><img src="https://images.gitee.com/uploads/images/2018/0729/081223_f75889b0_87680.png" alt="输入图片说明" title="2018-07-29 08-11-39屏幕截图.png"><br>IO流类图结构：<br><img src="https://images.gitee.com/uploads/images/2018/0729/081320_85629243_87680.png" alt="输入图片说明" title="2018-07-29 08-13-06屏幕截图.png"><br> <strong>创建一个文件</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package file;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line"> </span><br><span class="line">public class TestFile &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 绝对路径</span><br><span class="line">        File f1 = new File(&quot;d:/LOLFolder&quot;);</span><br><span class="line">        System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath());</span><br><span class="line">        // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录</span><br><span class="line">        File f2 = new File(&quot;LOL.exe&quot;);</span><br><span class="line">        System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath());</span><br><span class="line"> </span><br><span class="line">        // 把f1作为父目录创建文件对象</span><br><span class="line">        File f3 = new File(f1, &quot;LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"> **文件常用方法**</span><br></pre></td></tr></table></figure>
<p>package file;</p>
<p>import java.io.File;<br>import java.util.Date;</p>
<p>public class TestFile {</p>
<pre><code>public static void main(String[] args) {

    File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);
    System.out.println(&quot;当前文件是：&quot; +f);
    //文件是否存在
    System.out.println(&quot;判断是否存在：&quot;+f.exists());

    //是否是文件夹
    System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());

    //是否是文件（非文件夹）
    System.out.println(&quot;判断是否是文件：&quot;+f.isFile());

    //文件长度
    System.out.println(&quot;获取文件的长度：&quot;+f.length());

    //文件最后修改时间
    long time = f.lastModified();
    Date d = new Date(time);
    System.out.println(&quot;获取文件的最后修改时间：&quot;+d);
    //设置文件修改时间为1970.1.1 08:00:00
    f.setLastModified(0);

    //文件重命名
    File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);
    f.renameTo(f2);
    System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);

    System.out.println(&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**文件常用方法2**</span><br></pre></td></tr></table></figure>
<p>package file;</p>
<p>import java.io.File;<br>import java.io.IOException;</p>
<p>public class TestFile {</p>
<pre><code>public static void main(String[] args) throws IOException {

    File f = new File(&quot;d:/LOLFolder/skin/garen.ski&quot;);

    // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
    f.list();

    // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
    File[]fs= f.listFiles();

    // 以字符串形式返回获取所在文件夹
    f.getParent();

    // 以文件形式返回获取所在文件夹
    f.getParentFile();
    // 创建文件夹，如果父文件夹skin不存在，创建就无效
    f.mkdir();

    // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹
    f.mkdirs();

    // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常
    f.createNewFile();
    // 所以创建一个空文件之前，通常都会创建父目录
    f.getParentFile().mkdirs();

    // 列出所有的盘符c: d: e: 等等
    f.listRoots();

    // 刪除文件
    f.delete();

    // JVM结束的时候，刪除文件，常用于临时文件的删除
    f.deleteOnExit();

}
</code></pre><p>}</p>
<p>```  </p>
<h3 id="Java-集合类"><a href="#Java-集合类" class="headerlink" title="Java 集合类"></a>Java 集合类</h3><p>在写程序的时候并不是每次只使用一个对象， 更多的是对一组对象进行操作， 就需要知道如何<br>组合这些对象， 还有在编码的时候我们有时并不知道到底有多少对象，它们需要进行动态的分<br>配存放。  </p>
<ol>
<li>List  常用方法有哪些？  </li>
<li>数组  </li>
<li>Map 是以键值对的形式存在。  </li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>目前存在一个字符串 “学生:高鸿宇,陈航,杨明宇|教师:王老师,赵老师,宋老师”.使用split方法进行字符串的拆分，并分别将学生姓名和老师姓名打印出来。  </li>
<li>“欢迎你的光临,你好,为你服务很高兴,”，去除最后一个,号字符，并打印出来。  </li>
<li>要求客户输入一行字符串，判断该字符串是否包含优派森三个字，如果包含，则将优派森前边和后面的字符串输出，否则要求客户一直输入。  </li>
<li>使用io流新建一个测试.txt文件夹，并且在该文件夹内输入“优派森”。  </li>
<li>要求老司机按照“女优名字,女优名字”的格式输入可以想到的所有女优名字，然后使用split将字符串进行分割。并且将该名字存入女优对象里面。需新建一个女优的类，包含name属性，并且存在一个返回绝活的方法，该绝活的方法需要传入一个map集合，map对应的键分别为罩杯、身材级别。同时，该方法需要返回一个list集合，集合里面存放绝活列表。主函数接收到该绝活列表以后，需要按照name有绝活：1,2,3的形式输出到控制台上。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第七节对象详解（四）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%83%E8%8A%82%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h3><p>对象有状态和行为两种属性，分别由实例变量和方法来表示。<br>听起来比较抽象，但是看一下下面的图，你就会瞬间明白了：<br><img src="https://images.gitee.com/uploads/images/2018/0730/165738_e6dd06d6_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>任何一类的实例（对象）都有相同的方法，但是方法可以根据实例变量的值来表示不同的行为</strong><br><img src="https://images.gitee.com/uploads/images/2018/0730/170422_4be2595d_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0730/170447_e12018da_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0730/170539_20766590_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <em>也就是说，根据我们传入的参数，公用的方法可以产生不同的指向，整个业务逻辑也可以在参数的参与下变得丰富多彩起来。</em><br><img src="https://images.gitee.com/uploads/images/2018/0730/170806_6ca6b5be_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0730/170822_ead7c2c9_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p> <strong>形参和实参</strong><br><img src="https://images.gitee.com/uploads/images/2018/0730/171001_4fa5e622_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>方法的返回值</strong><br><img src="https://images.gitee.com/uploads/images/2018/0730/171110_dd3aa3a2_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>可以向一个方法中传入多个参数</strong><br><img src="https://images.gitee.com/uploads/images/2018/0730/171238_94e73baf_87680.png" alt="输入图片说明" title="屏幕截图.png"><br> <strong>也可以将变量当做参数传给方法，只要类型相符就行</strong><br><img src="https://images.gitee.com/uploads/images/2018/0730/171330_68ac381c_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>当然，我们对象的属性也可以参与到方法中来</strong></p>
<h3 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h3><p> <strong>上一节中提到，如果使用面向对象的设计方法，设计类图如下：</strong><br><img src="https://images.gitee.com/uploads/images/2018/0723/171425_32a75f94_87680.png" alt="输入图片说明" title="2018-07-23 17-14-18屏幕截图.png"><br>上图我们会发现，存在一个软件设计中非常严重的设计问题： <strong>代码重复</strong><br>如何去规避代码重复呢？java引入了继承的概念.<br>什么是继承呢？<br><img src="https://images.gitee.com/uploads/images/2018/0723/172920_0902597a_87680.png" alt="输入图片说明" title="2018-07-23 17-29-11屏幕截图.png"><br> <strong>尝试一下改造图书管理系统的代码，观察哪些公共方法可以放到父类里面，通过继承来消除代码重复</strong>  </p>
<p> <strong>尝试练习：</strong><br> <em>滴滴打车</em>   </p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p><img src="https://images.gitee.com/uploads/images/2018/0723/174706_27a46343_87680.png" alt="输入图片说明" title="2018-07-23 17-46-59屏幕截图.png"><br> <strong>改造图书管理系统，重写特殊方法</strong>  </p>
<h3 id="实例变量和方法"><a href="#实例变量和方法" class="headerlink" title="实例变量和方法"></a>实例变量和方法</h3><p><img src="https://images.gitee.com/uploads/images/2018/0723/174932_1708710a_87680.png" alt="输入图片说明" title="2018-07-23 17-49-26屏幕截图.png">   </p>
<h3 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h3><p><img src="https://images.gitee.com/uploads/images/2018/0723/175021_ed0ffc5e_87680.png" alt="输入图片说明" title="2018-07-23 17-50-14屏幕截图.png">  </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>通过类去生成一个对象的函数叫做构造函数．  </p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>即多种状态，方法名可以相同，只要传参不一样即可．  </p>
<h3 id="对象部分要点总结"><a href="#对象部分要点总结" class="headerlink" title="对象部分要点总结"></a>对象部分要点总结</h3><p><img src="https://images.gitee.com/uploads/images/2018/0724/095320_057e545d_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<h3 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h3><p> <strong>常用java运算符如下：</strong>  </p>
<ul>
<li><ul>
<li>/ %  </li>
</ul>
</li>
</ul>
<p><strong>自增自减运算符如下：</strong><br>++ –<br> <strong>自增自减运算符可以放在变量左边，也可以放在变量右边．比如i++和++i，这两种方式有什么区别呢？自己动手做一下实验，总结出其区别．</strong>　　<br>  <em>想到一个历史遗留的问题，while和dowhile的区别，当时让大家做实验验证过？区别是什么呢？</em>   </p>
<h3 id="面向对象编程的一个小实验"><a href="#面向对象编程的一个小实验" class="headerlink" title="面向对象编程的一个小实验"></a>面向对象编程的一个小实验</h3><p><img src="https://images.gitee.com/uploads/images/2018/0726/142728_182cf59a_87680.png" alt="输入图片说明" title="2018-07-26 14-27-12屏幕截图.png"><br>定义一个学生类，具有身高，体重，年龄，姓名，BMI基本属性，和获取BMI评价的值的方法．<br>通过控制台要求学生输入自己的姓名体重年龄身高，调取类里面的获取BMI评价值的方法．<br>最终，打印出该学生的姓名年龄身高体重BMI得分和BMI评价．</p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>面向对象的编程方式实现两数相加  </li>
<li>面向对象的编程方式实现两数相减  </li>
<li>面向对象的编程方式实现两数相乘  </li>
<li>面向对象的编程方式实现两数相除  </li>
<li>面向对象的编程方式实现两数求余  </li>
<li>实现一个简单计算器，有基础的加减乘除求余功能，并且可以连续计算</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第六节对象详解（三）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%85%AD%E8%8A%82%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="知识回顾与总结"><a href="#知识回顾与总结" class="headerlink" title="知识回顾与总结"></a>知识回顾与总结</h3><blockquote>
<p>垃圾堆上的生活  </p>
</blockquote>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/144802_5d2bb6b0_87680.png" alt="输入图片说明" title="2018-07-27 14-47-52屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0727/144834_466e2ebc_87680.png" alt="输入图片说明" title="2018-07-27 14-48-23屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0727/144905_283459b5_87680.png" alt="输入图片说明" title="2018-07-27 14-48-55屏幕截图.png">  </p>
<blockquote>
<p>堆上的生与死  </p>
</blockquote>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/150117_c55fc10d_87680.png" alt="输入图片说明" title="2018-07-27 15-01-04屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0727/150220_705685a8_87680.png" alt="输入图片说明" title="2018-07-27 15-02-13屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0727/150256_16597d02_87680.png" alt="输入图片说明" title="2018-07-27 15-02-46屏幕截图.png">  </p>
<blockquote>
<p>引用和指向  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Hero();</span><br><span class="line">```  </span><br><span class="line">代表创建了一个Hero对象  </span><br><span class="line">但是也仅仅是创建了一个对象，没有办法访问它  </span><br><span class="line">为了访问这个对象，会使用引用来代表这个对象</span><br></pre></td></tr></table></figure>
<p>Hero h = new Hero();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h这个变量是Hero类型，又叫做引用  </span><br><span class="line">=的意思指的h这个引用代表右侧创建的对象  </span><br><span class="line">“代表” 在面向对象里，又叫做“指向”  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0727/142229_bb823123_87680.png &quot;2018-07-27 14-22-20屏幕截图.png&quot;)  </span><br><span class="line"> **分析一段代码**</span><br></pre></td></tr></table></figure></p>
<p>public class Hero {</p>
<pre><code>String name; //姓名

float hp; //血量

float armor; //护甲

int moveSpeed; //移动速度

public static void main(String[] args) {
    //创建一个对象
    new Hero();

    //使用一个引用来指向这个对象
    Hero h = new Hero();

}   
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 多个引用，一个对象　　</span><br><span class="line">引用有多个，但是对象只有一个。  </span><br><span class="line">在这个例子里，所有引用都指向了同一个对象。  </span><br><span class="line">对象就像 &quot;房产&quot;， 引用就像&quot;房产证&quot;  </span><br><span class="line">房产证的复印件可以有多张，但是真正的&quot;房产&quot; 只有这么一处  </span><br><span class="line"></span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0727/142602_ec74a9e0_87680.png &quot;2018-07-27 14-25-48屏幕截图.png&quot;)  </span><br><span class="line"> **分析一段代码**</span><br></pre></td></tr></table></figure>
<p>public class Hero {</p>
<pre><code>String name; //姓名

float hp; //血量

float armor; //护甲

int moveSpeed; //移动速度

public static void main(String[] args) {

    //使用一个引用来指向这个对象
    Hero h1 = new Hero();
    Hero h2 = h1;  //h2指向h1所指向的对象
    Hero h3 = h1;
    Hero h4 = h1;
    Hero h5 = h4;

    //h1,h2,h3,h4,h5 五个引用，都指向同一个对象

}   
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一个引用，多个对象  </span><br><span class="line">第8行，引用garen指向新创建的对象（对象1）  </span><br><span class="line">第9行，同一个引用garen指向新创建的对象（对象2）  </span><br><span class="line">这个时候，对象1，就没有任何引用指向了  </span><br><span class="line">换句话说，就没有任何手段控制和访问该对象，那么该对象就变得没有意义。  </span><br><span class="line">![输入图片说明](https://images.gitee.com/uploads/images/2018/0727/142818_77c0b5f7_87680.png &quot;2018-07-27 14-28-11屏幕截图.png&quot;)</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp; </p>
<pre><code>public static void main(String[] args) {
       Hero garen =  new Hero();
       garen =  new Hero();
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> **尝试解答**  </span><br><span class="line">h4所指向的对象和h2所指向的对象，是否是同一个对象？</span><br></pre></td></tr></table></figure>
<p>package charactor;</p>
<p>public class Hero {<br>    public String name;<br>    protected float hp; </p>
<pre><code>public static void main(String[] args) {
       Hero h1 =  new Hero();
       Hero h2 =  new Hero();
       Hero h3;
       Hero h4;
       h3 = h1;
       h4 = h3;
}
</code></pre><p>}</p>
<p>```</p>
<blockquote>
<p>数组的深入理解  </p>
</blockquote>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/162035_0af7c360_87680.png" alt="输入图片说明" title="2018-07-27 16-20-27屏幕截图.png">  </p>
<p> <strong>数组里面可以放对象吗？</strong>  </p>
<p><img src="https://images.gitee.com/uploads/images/2018/0727/162344_3ea8c522_87680.png" alt="输入图片说明" title="2018-07-27 16-23-26屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0727/162414_107e822a_87680.png" alt="输入图片说明" title="2018-07-27 16-24-06屏幕截图.png">  </p>
<p> <em>如何进行数组对象的存取呢？</em><br> <em>改造一下我们上一节的电影节计划，使用数组代替list．</em> </p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>设计一个电脑类，一个教师类，电脑类可以进行幻灯片文件的存放．教师类可以进行幻灯片文件的播放．通过电脑类的幻灯片存放方法存放五个幻灯片，分别为：java从入门到精通，网络基础，计算机原理，小黄片，大学英语．模拟三个老师进行幻灯片播放，播放的幻灯片是随机的．假如，其中一个老师不小心随机到了小黄片，那就给出严重警告，并且结束循环，否则，一直循环播放下去．  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第五节对象详解（二）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%BA%94%E8%8A%82%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>我们现在接触的变量主要有两种：  </p>
<ol>
<li>基础数据类型   primitive</li>
<li>对象<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><img src="https://images.gitee.com/uploads/images/2018/0724/085158_a38630ab_87680.png" alt="输入图片说明" title="屏幕截图.png"><br><strong>创建对象步骤总结</strong>  </li>
<li>编写类  </li>
<li>编写测试类  </li>
<li>在测试类中建立<strong>对象</strong>，并且调用对象的方法或者属性.<br><strong>尝试练习</strong><br>最近电影市场非常火爆，各大电影激战暑假档。分析电影的特性，设计一个电影的类。并且根据电影类，生成三部电影，分别为我不是药神、邪不压正和手机2.<br>并且使用for循环打印出他的所有属性。<br><img src="https://images.gitee.com/uploads/images/2018/0724/085924_f108b899_87680.png" alt="输入图片说明" title="屏幕截图.png">  <h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><strong>兄弟们，main函数已经物尽其用了，是时候抛弃他了！过河拆桥这件事儿，我们很在行的。现在！麻溜的！放弃main！成大事者….呵呵呵…</strong><br><strong>public static void main(String args[])</strong><br>多么熟悉的代码啊，是吧，是时候送别了。<br>main函数只有两种用途，如下所示：  </li>
</ol>
<ul>
<li>测试真正的类  </li>
<li><p>启动java程序<br><strong>尝试练习</strong><br>猜数字，系统随机产生一个0-9的随机数。三个人去猜，只要有一个人猜中数字结果，这个程序结束。猜数字的过程中，需要打印出三个人各自猜的数字，最终猜出数字的那个人需要重点提示一下，并打印出最终的数字。<br><img src="https://images.gitee.com/uploads/images/2018/0724/094130_09ea0f8b_87680.png" alt="输入图片说明" title="屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0724/094247_49425855_87680.png" alt="输入图片说明" title="屏幕截图.png">  </p>
<p><em>世界杯如火如荼的进行，额，已经结束了。我们就假如还在进行，天才如你们一定知道最终谁夺冠是吧？快来竞猜吧。模拟三个人猜冠军的游戏。</em><br><strong>小小的扩展</strong><br><img src="https://images.gitee.com/uploads/images/2018/0724/095207_0491a9c4_87680.png" alt="输入图片说明" title="屏幕截图.png"> </p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><p>我们的图书管理系统已经成型，并且在校方积极的推动下，此系统已经正式上线了。<br>上线之后，进入了测试阶段。图书管理员暂时先维护了十本书在数据库里面。<br>维护完课本数据，图书管理员长长舒了一口气，刚想休息一会。此时，有三个学生一起来借书了。<br>于是，图书管理员又一次忙碌了起来，帮助学生完成了借书。<br>借书流程我们如何去设计呢？首先验证学生的身份吗？刷卡获取学生的学号？<br>之后，我们如何去完成借书流程呢？书籍已经被借走和没被借走的状态是不是不一样？我们是不是需要设计一个标志位来标记这本书是不是被借走呢？<br>同时，学生是不是接到书了，接到了哪一本书呢？学生是不是应该有一个属性记录当前借书啊？<br>对了，学生是不是还得有一个属性来记录一共借了多少书呢？借书数量是不是应该有一个上限呢？<br>写到这里，你们是不是想把自己画的类图撕掉重新画了？<br>当然，还有还书功能？你们如何去模拟呢？<br><strong>说到这里，大家对于软件是不是应该有一个自己的理解呢？到底什么样的软件才是可用的软件呢？实现功能很简单，但是做到可用，软件可用是一件很不容易的事情。</strong> </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第四节对象详解（一）]]></title>
      <url>/2018/09/13/%E7%AC%AC%E5%9B%9B%E8%8A%82%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="从main函数说起"><a href="#从main函数说起" class="headerlink" title="从main函数说起"></a>从main函数说起</h3><p>第一节课，我们写的第一个程序，就已经接触到了class的概念．class是java特有的，我们可以称为类．java的所有操作都是依赖于类并且从类开始的．<br>我们使用java类，新建java类的时候需要注意什么？  </p>
<ol>
<li>命名规范  </li>
<li>类规则 <h3 id="让我们真正的开始吧"><a href="#让我们真正的开始吧" class="headerlink" title="让我们真正的开始吧"></a>让我们真正的开始吧</h3>其实，之前我们写的程序算不上面向对象的程序开发．我们只是遵循java的特定规则去实现功能，在实现功能的过程中，调用了一下java底层内置的对象．这些对象是java的一些底层设计，并不是我们自定义的对象，我们都没有自己定义自己的对象，当然算不上面向对象编程．<br>那么，什么才是面向对象编程呢？通过书上的例子，实地感受一下．<br><img src="https://images.gitee.com/uploads/images/2018/0722/080101_bca536d5_87680.png" alt="输入图片说明" title="2018-07-22 08-00-50屏幕截图.png"><br>下图，左边是传统的编程方式，右边是面向对象编程方式．<br><img src="https://images.gitee.com/uploads/images/2018/0722/080234_a2be4bbc_87680.png" alt="输入图片说明" title="2018-07-22 08-02-23屏幕截图.png"><br><strong>好戏开始了，客户新需求来了．PS：在今后我们会面临无数次的需求变更，对于需求变更，一定要习以为常．</strong><br><em>客户新加的需求是什么呢？</em><br><img src="https://images.gitee.com/uploads/images/2018/0722/080546_91f02765_87680.png" alt="输入图片说明" title="2018-07-22 08-05-36屏幕截图.png"><br>此时，两种编程思维的两个人需要做如下工作了：<br><img src="https://images.gitee.com/uploads/images/2018/0722/080651_47b726d9_87680.png" alt="输入图片说明" title="2018-07-22 08-06-43屏幕截图.png"><br><strong>好戏又来了，这次不是需求变更，是需求不符．PS：需求不符也是家常便饭．每天在这种残酷的变来变去的环境中生存，程序员能坚持活下来也算是一种奇迹了．</strong><br><em>需求不符的描述如下：</em><br><img src="https://images.gitee.com/uploads/images/2018/0722/081024_16035757_87680.png" alt="输入图片说明" title="2018-07-22 08-10-15屏幕截图.png"><img src="https://images.gitee.com/uploads/images/2018/0722/081128_79a6ab8a_87680.png" alt="输入图片说明" title="2018-07-22 08-11-20屏幕截图.png"><br>接下来，两人的工作分别如下：<br><img src="https://images.gitee.com/uploads/images/2018/0722/081306_a75676bd_87680.png" alt="输入图片说明" title="2018-07-22 08-12-56屏幕截图.png">  <h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3>假如，我们又有了一个新的需求变更 -&gt;梯形，他的旋转呢，需要以右上角的点为中心进行旋转．<br>面向对象的我们，需要如何设计和实现呢？  <h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3></li>
<li>我们需要做一个图书管理系统，主要实现借书和登记还书功能．实现其类图．</li>
<li>代码实现以上的两个功能．</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第三节条件语句和循环控制]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%89%E8%8A%82%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="java的常用语法"><a href="#java的常用语法" class="headerlink" title="java的常用语法"></a>java的常用语法</h3><p><img src="https://images.gitee.com/uploads/images/2018/0721/060158_cae17dd1_87680.png" alt="java语法" title="2018-07-21 06-01-02屏幕截图.png"><br> <strong>读代码</strong><br><img src="https://images.gitee.com/uploads/images/2018/0721/061837_75c773da_87680.png" alt="读代码" title="2018-07-21 06-18-20屏幕截图.png"></p>
<h3 id="功能实现需要哪些常用逻辑？"><a href="#功能实现需要哪些常用逻辑？" class="headerlink" title="功能实现需要哪些常用逻辑？"></a>功能实现需要哪些常用逻辑？</h3><ol>
<li>做某件事  </li>
<li>重复做某件事  </li>
<li>在指定条件下做某件事<br>举个例子：<br>吃饭-&gt;饿了么<br>吃饭<br>感觉鸡翅好吃，重复点鸡翅，重复吃鸡翅<br>早上喝稀饭，中午吃鸡腿，晚上吃酸菜鱼<br><img src="https://images.gitee.com/uploads/images/2018/0721/060128_64f9203f_87680.png" alt="语言逻辑" title="2018-07-21 06-00-24屏幕截图.png"><br>上图中，重复做某件事和在指定条件下做某件事就是说的循环控制和条件语句．<br>重复做某件事-&gt;循环控制<br>在指定条件下做某件事-&gt;条件语句<br>简单的循环控制实例:<br><img src="https://images.gitee.com/uploads/images/2018/0721/063403_91edc193_87680.png" alt="循环控制" title="2018-07-21 06-33-53屏幕截图.png"><br><img src="https://images.gitee.com/uploads/images/2018/0721/063456_745bbee2_87680.png" alt="条件语句" title="2018-07-21 06-34-48屏幕截图.png"><br>上面两个图可以看出，无论是循环控制还是条件语句，重点在条件部分，这个条件值也就是我们说的临界值是非常重要的．<br>条件也就是我们说的条件测试，条件测试最终的结果都是boolean类型的，通常通过比较运算符来获取最终的波尔值，常用比较运算符有：&gt; &lt; ==．<br>其中，=和==是存在区别的．  </li>
</ol>
<ul>
<li>=:</li>
<li>==:<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><strong>条件语句格式</strong>  <ol>
<li>if<br><img src="https://images.gitee.com/uploads/images/2018/0721/210759_803f48c2_87680.png" alt="输入图片说明" title="2018-07-21 21-07-46屏幕截图.png"><br>尝试写一个功能：<br>高总父亲在考试之前告诉他，考试成绩高于90分奖励一部粪叉．考试结束了，高总考了92分.其父奖励一部爱粪叉（打印出即可）．  </li>
</ol>
</li>
</ul>
<ol>
<li>if …else..<br><img src="https://images.gitee.com/uploads/images/2018/0721/211607_e6be5cb4_87680.png" alt="输入图片说明" title="2018-07-21 21-15-58屏幕截图.png"><br>尝试写一个功能：<br>书接上文，高总其父告诉高总，如果考不上90分，下学期的学费不给交了．高总考了89分….  </li>
<li>多重if<br><img src="https://images.gitee.com/uploads/images/2018/0721/211858_ab3d107c_87680.png" alt="输入图片说明" title="2018-07-21 21-18-40屏幕截图.png"><br>尝试写一个功能：<br>继续接上文，高总其父觉得之前的规矩有点严格，重新定了规矩．考不上90，但是80分以上还是会奖励，奖励一部小米略屌手机.否则，不仅下学期学费不交了，还得做500俯卧撑．高总考了79分．  </li>
<li>嵌套if<br><img src="https://images.gitee.com/uploads/images/2018/0721/212236_6f79290c_87680.png" alt="输入图片说明" title="2018-07-21 21-22-29屏幕截图.png"><br>尝试写一个功能：<br>接上文，番外篇．高总其父不舍得惩罚他，心里默念，如果高总认错态度好的话，那就既往不咎，否则，需要加100杀威棒．结果，高总认错态度非常差．  <h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3></li>
<li>while循环<br><img src="https://images.gitee.com/uploads/images/2018/0721/212605_3cacb2e1_87680.png" alt="输入图片说明" title="2018-07-21 21-25-58屏幕截图.png"><br>尝试写一个功能：<br>计算1-100的和  </li>
<li>do..while循环<br><img src="https://images.gitee.com/uploads/images/2018/0721/212729_af698201_87680.png" alt="输入图片说明" title="2018-07-21 21-27-21屏幕截图.png"><br>尝试写一个功能：<br>计算1-100的和  </li>
<li>for循环<br><img src="https://images.gitee.com/uploads/images/2018/0721/212829_af55ce11_87680.png" alt="输入图片说明" title="2018-07-21 21-28-22屏幕截图.png"><br>尝试写一个功能：<br>计算1-100的和  </li>
</ol>
<h3 id="一个故意遗漏的知识点"><a href="#一个故意遗漏的知识点" class="headerlink" title="一个故意遗漏的知识点"></a>一个故意遗漏的知识点</h3><p>java方法</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>到目前位置发现，无客户交互，只能写死一些数据．<br>我们提前学习一个彩蛋功能，获取用户的输入信息．<br>java内置api，内置类scanner类来获取键盘输入信息．<br>用法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">       System.out.println(&quot;请输入您的姓名：&quot;);</span><br><span class="line">       String name = scanner.nextLine();</span><br><span class="line">       System.out.println(&quot;您的名字：&quot;+name);</span><br><span class="line">       System.out.println(&quot;请输入您的年龄：&quot;);</span><br><span class="line">       int age = scanner.nextInt();</span><br><span class="line">       System.out.println(&quot;您的年龄：&quot;+age);</span><br><span class="line">       System.out.println(&quot;请输入您的工资：&quot;);</span><br><span class="line">       float salary = scanner.nextFloat();</span><br><span class="line">       System.out.println(&quot;您的工资：&quot;+salary);</span><br></pre></td></tr></table></figure>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>输出九九乘法表．</li>
<li>用星号画图形，菱形和三角形．根据用户的选择画出对应的图形，假如用户输入的非这两个图形则提示用户，暂不支持图形的绘制．</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第二节java的基本数据类型]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%BA%8C%E8%8A%82java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="剖析类"><a href="#剖析类" class="headerlink" title="剖析类"></a>剖析类</h3><p><img src="https://images.gitee.com/uploads/images/2018/0720/164246_17879cb2_87680.png" alt="剖析类" title="2018-07-20 16-42-17屏幕截图.png">  </p>
<p> <strong>解释</strong><br>main函数是一个java程序的开始，一个程序的入口，不管你的程序有多复杂，不管有多少个类，都需要从这个main函数作为入口进入程序.  </p>
<p>下面以图片的形式再次说明一下java的运行原理：<br><img src="https://images.gitee.com/uploads/images/2018/0720/173058_aefedbe6_87680.png" alt="java运行原理" title="2018-07-20 17-28-35屏幕截图.png"></p>
<h3 id="java的基本数据类型"><a href="#java的基本数据类型" class="headerlink" title="java的基本数据类型　"></a>java的基本数据类型　</h3><p>首先，需要明确一下java的主要特征，java是一种面向对象的编程语言，简称oop．对于java的一些底层设计，一定要从面向对象的角度出发并思考．然而，现在说面向对象的话，可能会显得比较突兀．我也担心大家不容易理解和接受．所以，我们先去讲解一下基本数据类型．说到基本数据类型呢？我们又不得不从面向对象介入讲解，因此，这里我们就简单的说一下面向对象．简单说明，浅尝辄止．<br> <strong>简单的面向对象</strong><br>传统的编程方式是纯粹的计算机语言，让人有点无从下手，一堆代码，一堆逻辑，导致难以理解．面向对象就是为了解决这些问题，他把抽象的计算机语言转换成了具体的对象语言.<br>比如:<br>学生，老师，鸟，花，书，电脑等都可以抽象成对象．<br>我要做一个图书管理系统，那么，其中涉及到的元素，我都可以抽象成指定对象．后续对于计算机的操作就变成了纯粹的对于对象的操作．<br>就是因为java的这个特性，导致java是非常依赖对象的．java的世界里全是对象.<br>因此，java去声明定义变量的时候就变成了如下的结构形式：<br><img src="https://images.gitee.com/uploads/images/2018/0720/180525_43c5dfae_87680.png" alt="结构定义" title="2018-07-20 18-00-33屏幕截图.png"><br> 前面的这个类型即我们通常所说的基本数据类型，当然这里也可以使用我们自定义的对象或者是java自带的内部对象去声明和定义．<br>java的基本数据类型如下：<br><img src="https://images.gitee.com/uploads/images/2018/0720/180813_7ab1541d_87680.png" alt="输入图片说明" title="2018-07-20 18-08-03屏幕截图.png"><br>简单实例:<br><img src="https://images.gitee.com/uploads/images/2018/0720/180928_2299240a_87680.png" alt="输入图片说明" title="2018-07-20 18-09-16屏幕截图.png"></p>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>输出1-9的数字，每个数字进行一次换行（不要使用数组，不要使用循环）<br><img src="https://images.gitee.com/uploads/images/2018/0721/071837_2bc1bcd0_87680.png" alt="输入图片说明" title="2018-07-21 07-18-23屏幕截图.png">  </li>
<li>输出F的ASIC码，输出ASIC码为70对应的字符．  </li>
<li>声明一个波尔型变量，定义为true，输出他的值．</li>
<li>声明一个byte类型的变量，定义值为128，并打印出他的值.</li>
<li>定义一个float类型的浮点数3.1415926667789，并输出其值．定义一个double型的浮点数3.1415926547788998855667,并输出其值．  </li>
<li>观察输出值，总结出float和double类型数的区别，占位数和精读.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第一节java简介及开发环境搭建]]></title>
      <url>/2018/09/13/%E7%AC%AC%E4%B8%80%E8%8A%82java%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li>计算机科学ＣＳ体系结构简介<br><img src="https://images.gitee.com/uploads/images/2018/0719/225221_7451d054_87680.jpeg" alt="CS体系结构" title="v2-5647f22580533d9ceec34e0c2fa30aff_r.jpg"></li>
<li>软件行业　　<br>目前软件行业主要区分为产品化和项目化软件，比如支付宝，微信等均为产品化的软件．而项目化的软件目前比较集中于外包项目．相对于传统行业，软件行业是一个颠覆性的行业．他的存在就是为了干掉其他的传统行业．所以，未来不懂软件即失业并不是危言耸听．　　</li>
<li>java简介　　<br>面向对象的高级语言．  </li>
<li>经典实例  </li>
<li>基本环境搭建<br>其中环境变量相关配置如下:<br>JAVA_HOME    jdk安装路径<br>path         %JAVA_HOME%\bin<br>classpath    %JAVA_HOME%\lib\tools.jar<br>安装配置完成之后，cmd里面分别输入javac和java命令进行校验.  </li>
<li>java学习路线　　<br><img src="https://images.gitee.com/uploads/images/2018/0719/232002_554762ae_87680.jpeg" alt="学习路线" title="v2-684b3ec73ee0046c72e03283dea9b750_r.jpg">　　</li>
</ol>
<h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ol>
<li>理解并掌握java运行机制  java编译器和jvm虚拟机　　</li>
<li>jdk jre和jvm的含义及区别 　</li>
<li>常用ide了解　　</li>
<li>配置java开发环境</li>
<li>使用编辑器配合java javac 运行HelloWorld程序　　</li>
<li>idea工具的安装以及简单配置  </li>
<li>git的简介以及使用</li>
</ol>
<h3 id="课下作业"><a href="#课下作业" class="headerlink" title="课下作业"></a>课下作业</h3><ol>
<li>安装并配置jdk，可以口述安装过程，下节课会让每个人口述．  </li>
<li>编辑器编写hello world程序，配合javac和java命令运行程序．  </li>
<li>下载并安装idea开发工具，使用该开发工具编写helloworld程序.  </li>
<li>下载git，根据使用说明配置idea的git环境，并且在我们的项目中新建com．姓名的包，并编写程序，将程序进行上传．</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[phpstorm+phpstudy+xdbug断点调试]]></title>
      <url>/2018/02/28/phpstorm-phpstudy-xdbug%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>大概用了一天的时间完成标题所说的功能。原因？百度到的问题几乎是一堆无效回答，明显不是我理解力的问题。因为，白纸黑字那么放着，按照其所说操作，确实是得不到正确答案。写技术博客不可面面俱到，一定要理论加实践，否则会是一堆笑谈。</p>
</blockquote>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="phptorm安装"><a href="#phptorm安装" class="headerlink" title="phptorm安装"></a>phptorm安装</h2><p>安装不多说，下载完成之后，按照步骤安装即可。</p>
<h2 id="phpstudy安装"><a href="#phpstudy安装" class="headerlink" title="phpstudy安装"></a>phpstudy安装</h2><p>下载解压版本，启动即可。这里需要注意的是mysql的版本，会和本机安装的mysql服务冲突。如何解决该问题，可参考我上一遍博客。</p>
<h2 id="phpstorm使用phpstudy"><a href="#phpstorm使用phpstudy" class="headerlink" title="phpstorm使用phpstudy"></a>phpstorm使用phpstudy</h2><p>安装完成的phpstorm是无法运行程序的，原因是没有php运行环境。运行环境是什么？在哪里？<br>其实，phpstudy就是一个运行环境。下面我们需要做的就是把将phpstudy配置到phpstorm里面来。  </p>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol>
<li>进入setting菜单，之后依次选择。最后点击箭头所指向的按钮。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-5f08d5caa9b9c112.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择CLI.png"></li>
<li><p>单击+按钮，name自定义即可。最后点击箭头所指按钮，选择phpstudy下的某一个php版本即可。这里我选择的是5.3.38的版本。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-19ba0f3977266b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置运行环境.png"></p>
</li>
<li><p>配置完成。</p>
<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><blockquote>
<p>此处也是该篇文章所重点介绍的。</p>
</blockquote>
</li>
</ol>
<h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><p>我使用的chrome浏览器，插件为xdebug helper-1.4.3，版本为1.4.3。<br>安装该插件，具体步骤如下：</p>
<ol>
<li>下载xdebug插件。我上传到了百度云盘，可自行下载。下载地址为：<br>链接：<a href="https://pan.baidu.com/s/1c3Sodvq" target="_blank" rel="noopener">https://pan.baidu.com/s/1c3Sodvq</a> 密码：zp1w</li>
<li>打开谷歌浏览器，选择更多工具&gt;扩展程序。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-a7a82f792e413e8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装扩展程序.png"></p>
<ol>
<li>在扩展程序下，将下载好的插件直接拖入浏览器即可完成安装。</li>
</ol>
<h3 id="phpstudy配置"><a href="#phpstudy配置" class="headerlink" title="phpstudy配置"></a>phpstudy配置</h3><ol>
<li>打开phpstudy的Xdebug扩展功能。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-1e2a818b2658d07a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开Xdebug功能.png"></p>
<ol>
<li>修改php.ini配置文件<br>这里需要注意：在phpstorm里面配置的哪一个版本，就需要修改哪一个版本的配置文件。比如，我配置的5.3.38的版本，我就需要到相对于的php目录下找到该文件夹下面的php.ini文件。之后做如下配置（直接拖到文件底部即可）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line">xdebug.profiler_enable=off</span><br><span class="line">xdebug.profiler_enable_trigger=off</span><br><span class="line">xdebug.profiler_output_name=cachegrind.out.%t.%p</span><br><span class="line">xdebug.profiler_output_dir=&quot;D:\phpStudy\tmp\xdebug&quot;</span><br><span class="line">xdebug.show_local_vars=0</span><br><span class="line">xdebug.idekey=PHPSTORM</span><br><span class="line">xdebug.remote_enable = On</span><br><span class="line">xdebug.remote_host=localhost</span><br><span class="line">xdebug.remote_port=9000</span><br><span class="line">xdebug.remote_handler=dbgp</span><br><span class="line">xdebug.remote_autostart=off</span><br><span class="line">zend_extension=&quot;D:\phpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;</span><br></pre></td></tr></table></figure>
<p>注意最后一个配置项zend_extension，这是xdebug的对应dll。phpstudy已经做了集成。</p>
<ol>
<li><p>配置server信息。按照下图所示进行配置，name自定义即可。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-965baf53f4efac23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="server信息配置.png"></p>
</li>
<li><p>配置debug和DBGp proxy。debug需要注意端口号（需要和php.ini里面的端口号一致），proxy按照下图配置即可。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-9574219197be8620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debug配置注意端口号.png"></p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-6e9339a4d6698421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dbGp配置.png"></p>
<ol>
<li>配置浏览器插件。打开chrome，进入xdebug配置项，参考下图进入方法。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-fe3daf674a7013d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>之后需要修改两个地方。第一，idekey，修改为phpstorm。第二，白名单（Domain filter），将localhost和127.0.0.1配置进来。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-db6731d317e1e390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>启动phpstudy。</li>
</ol>
<p>完成以上配置，打开chrome，输入localhost。如果出现php探针界面，就证明我们的配置成功了。php探针界面如下。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-e72af1bb79cf44b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="php探针.png"></p>
<p><strong>到了这里，不需要再去配置什么服务器了！！！直接在你的php代码上面加断点，再选择浏览器打开，就可以调试你的代码了。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-2f098e03112fa21b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点此出运行.png"></p>
]]></content>
      
        <categories>
            
            <category> php </category>
            
        </categories>
        
        
        <tags>
            
            <tag> phpstudy </tag>
            
            <tag> phpstorm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[phpstudy安装后将原有的mysql服务卸载]]></title>
      <url>/2018/02/27/phpstudy%E5%AE%89%E8%A3%85%E5%90%8E%E5%B0%86%E5%8E%9F%E6%9C%89%E7%9A%84mysql%E6%9C%8D%E5%8A%A1%E5%8D%B8%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>安装phpstudy之后，原有的mysql服务无法找到。无法进入原有的数据库。</p>
<ul>
<li>phpstudy的安装很傻瓜，我下载的非lite版本，也是解压版本，解压之后，直接将服务启动。</li>
<li>此时，我用navicat连接数据库看到的是一个全新的数据库。</li>
<li>出了一身冷汗，我曹，原来我的数据库哪去了？里面有很多数据啊！涉及到很多项目！不过，此时还不慌。发现端口是3306，肯定是原来的服务被停掉了，重启一遍不就行了！</li>
<li>于是，我将phpstudy自带的mysql关掉。然后打开windows服务，然后没有然后了！！原来的mysql竟然消失了！慌了！</li>
</ul>
<p>#解决过程</p>
<ol>
<li>首先我先去mysql安装目录下看了一下，万幸，还在！</li>
<li>然后我进入mysql的bin目录，此处使用控制台进入。</li>
<li>命令mysql一下，报错了！进入不了，那就是服务没启动？</li>
<li>使用命令： mysqld –install安装一下试试。报错了：Install/Remove of the Service Denied!看来是权限不够。</li>
<li>使用管理员身份登录一下，然后重新进行一下安装。服务安装成功！一切问题也就解决了。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-7e5b072f6ac1dd3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决过程.png"></p>
<p>#后续</p>
<blockquote>
<p>修改了一下phpstudy自带的mysql端口号，将原来的3306修改为3309。然后，用navicat再连接一下3309。这样，内置数据库和原始数据库均可以正常连接了。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-9187ebb8c08dc881.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改端口号.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-7034a30cf78661b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库连接图.png"></p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> phpstudy </tag>
            
            <tag> mysql服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo-d提交报错问题解决]]></title>
      <url>/2018/02/26/hexo-d%E6%8F%90%E4%BA%A4%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>写完一遍博客以后，照例hexo -g hexo -d生成和提交。但是在成功生成之后，进行提交的时候报错了！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nothing to commit, working directory clean</span><br><span class="line">bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;[GitHub · Where software is built](https://link.zhihu.com/?target=https%3A//github.com)&apos;: No error</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: [Troubleshooting](https://link.zhihu.com/?target=http%3A//hexo.io/docs/troubleshooting.html)</span><br><span class="line">Error: bash: /dev/tty: No such device or address</span><br><span class="line">error: failed to execute prompt script (exit code 1)</span><br><span class="line">fatal: could not read Username for &apos;[GitHub · Where software is built](https://link.zhihu.com/?target=https%3A//github.com)&apos;: No error</span><br><span class="line"></span><br><span class="line">at ChildProcess.&lt;anonymous&gt; (E:\SwuComputer\HTML5\hexo\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:42:17)</span><br><span class="line">at emitTwo (events.js:87:13)</span><br><span class="line">at ChildProcess.emit (events.js:172:7)</span><br><span class="line">at maybeClose (internal/child_process.js:818:16)</span><br><span class="line">at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)</span><br></pre></td></tr></table></figure>
<p>关注主要的报错信息：<br><strong>fatal: could not read Username for ‘[GitHub · Where</strong></p>
<p>按照以下步骤进行操作，解决了以上问题：</p>
<blockquote>
<p>修改配置文件：根目录下的_config.yml，修改deploy节点。<br>原来的配置为：<br>deploy:<br>type: git<br>repo: <a href="https://github.com/{yourname}/{yourname}.github.io.git" target="_blank" rel="noopener">https://github.com/{yourname}/{yourname}.github.io.git</a><br>branch: master<br>修改为如下：<br>deploy:<br>type: git<br>repo: <a href="https://{yourname}:{yourpassword}@github.com/{yourname}/{yourname}.github.io.git" target="_blank" rel="noopener">https://{yourname}:{yourpassword}@github.com/{yourname}/{yourname}.github.io.git</a><br>branch: master</p>
</blockquote>
<p>亲测可行。</p>
<p><strong>原因分析：</strong><br>如果在使用hexo d命令的前提下，直接修改.git下面的config文件是无法成功的。原因是：使用该命令之后，会根据_config.yml下面的deploy节点进行cofig文件的覆盖。也就是说，_config.yml如果不做修改，无论如何修改.git下面的配置文件都是无效的，都会被覆盖。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 提交报错 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot进行文件上传（一）]]></title>
      <url>/2018/02/26/SpringBoot%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h1><p>首先，必须明确几个问题：</p>
<ul>
<li>如果是ajax进行表单提交或者数据请求，就不要考虑文件上传的问题了。ajax做的是数据提交，压根就不能进行文件的输出。</li>
<li>文件上传，必须注意一下请求类型，需要是文件请求并且必须是POST形式。参照：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;baseForm&quot;  action=&quot;/admin/saveOrUpdatePageInfo&quot; class=&quot;form-horizontal&quot; role=&quot;form&quot;</span><br><span class="line">                      enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong>两个属性enctype和method，其中method记得一定指定一下post。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="后台业务实现"><a href="#后台业务实现" class="headerlink" title="后台业务实现"></a>后台业务实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;saveOrUpdatePageInfo&quot;)</span><br><span class="line">    public String saveOrUpdatePageInfo(ModelMap model,@RequestParam(&quot;file&quot;) MultipartFile file, PageInfo pageInfo,HttpServletRequest request)&#123;</span><br><span class="line">        //首先进行文件上传</span><br><span class="line">        String contentType = file.getContentType();</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        /*System.out.println(&quot;fileName--&gt;&quot; + fileName);</span><br><span class="line">        System.out.println(&quot;getContentType--&gt;&quot; + contentType);*/</span><br><span class="line">//        String filePath = request.getSession().getServletContext().getRealPath(&quot;imgupload/&quot;);</span><br><span class="line">//        String filePath = location+&quot;/&quot;+fileName;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileUtil.uploadFile(file.getBytes(), location, fileName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        pageInfo.setUrl(fileName);</span><br><span class="line">        //查询业务编号是否存在</span><br><span class="line">        PageInfo samePageInfo = pageInfoService.selectByName(pageInfo.getName());</span><br><span class="line">        if(samePageInfo!=null)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pageInfoService.saveOrUpdate(pageInfo);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return toPageSetting(model,request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上需要注意文件元素的传入：使用RequestParam注解进行该元素的传入操作<strong>@RequestParam(“file”) MultipartFile file</strong>，其中file表示html页面中文件对应的name标签值。</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 上传文件</span><br><span class="line">     * @param file  文件对应的byte数组流   使用file.getBytes()方法可以获取</span><br><span class="line">     * @param filePath  上传文件路径，不包含文件名</span><br><span class="line">     * @param fileName 上传文件名</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static void uploadFile(byte[] file, String filePath, String fileName) throws Exception &#123;</span><br><span class="line">        File targetFile = new File(filePath);</span><br><span class="line">        if(!targetFile.exists())&#123;</span><br><span class="line">            targetFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream out = new FileOutputStream(filePath+&quot;/&quot;+fileName);</span><br><span class="line">        out.write(file);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;baseForm&quot;  action=&quot;/admin/saveOrUpdatePageInfo&quot; class=&quot;form-horizontal&quot; role=&quot;form&quot;</span><br><span class="line">                      enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;label class=&quot;col-md-2 control-label&quot;&gt;资源名称&lt;/label&gt;</span><br><span class="line">                        &lt;div class=&quot;col-md-10&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot;&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h2 id="上传文件路径"><a href="#上传文件路径" class="headerlink" title="上传文件路径"></a>上传文件路径</h2><p>以上实现了文件的上传过程，但是我们使用springboot进行开发过程中，最终打包生成的是一个jar包。那么问题来了，文件上传到了什么地方呢？大家知道，jar包启动的时候，会默认生成一个tomcat运行文件夹。上传到该文件夹下面明显是不合适的，因为每次运行jar包都会新生成一遍。那么，之前上传的文件都不存在了，明显不是我们期望的结果。<br>如何去指定一个文件夹作为默认的文件上传路径呢？<br>配置文件配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img.location = d:/mypicture</span><br><span class="line">spring.mvc.static-path-pattern=/**</span><br><span class="line">spring.resources.static-locations=file:$&#123;img.location&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用@Value标签获取到文件上传路径。之后将路径传入到上传文件的方法里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> @Value(&quot;$&#123;img.location&#125;&quot;)</span><br><span class="line">  private String location;</span><br><span class="line"></span><br><span class="line">FileUtil.uploadFile(file.getBytes(), location, fileName);</span><br></pre></td></tr></table></figure></p>
<p>以上，完成了一个指定文件路径上传的功能。</p>
<h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>上传文件完成之后，就可以进行图片的访问了。但是，对于springboot而言，已经对请求进行了拦截。并且，假如是绝对路径的话，该图片是存在于服务端的，服务端下的某个绝对地址，如何从客户端进行访问？<br>配置文件配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img.location = d:/mypicture</span><br><span class="line">spring.mvc.static-path-pattern=/**</span><br><span class="line">spring.resources.static-locations=file:$&#123;img.location&#125;</span><br></pre></td></tr></table></figure></p>
<p>什么意思呢？我们指定了一个静态资源，并且指定所有的请求都会经过该静态资源的过滤。假如此时我请求一个资源，比如localhost:8080/test.jpg。我们就会对该路径进行拦截，拦截之后做什么呢？会去spring.resources.static-locations对应的路径下面查找该资源。当然，如果配置多个的话，会进行路径的逐个查询。此时，会从d:/mypicture下满查找test.jpg。找到之后，就进行了资源的显示。</p>
<p>以上，即为简单的基于springboot的文件上传说明。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java实现图形验证码]]></title>
      <url>/2018/02/08/java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>首先img的src可以使用远程图片，也就是说他同样是可以请求后端的，这也就是实现图形验证码随机显示的原理。</p>
</blockquote>
<h1 id="配置html页面"><a href="#配置html页面" class="headerlink" title="配置html页面"></a>配置html页面</h1><ul>
<li>使用img组件，src请求一个后台地址。</li>
<li>点击图片，传递随机数，获取随机验证码。</li>
<li>下面代码基于Thymeleaf，因此使用了th:src属性。普通的页面的话，可以直接使用src属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;span class=&quot;yzm-pic&quot;&gt;</span><br><span class="line">&lt;img th:src=&quot;@&#123;/ran/random&#125;&quot; th-alt=&quot;验证码，点击图片更换&quot; onclick=&quot;this.src=&apos;/ran/random?random=&apos;+Math.random();&quot; /&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong><br><strong>其实，onclick是一个难点，点击之后传递一个随机数。使用this.src重新给该图片赋值。</strong></p>
<h1 id="实现后台控制方法"><a href="#实现后台控制方法" class="headerlink" title="实现后台控制方法"></a>实现后台控制方法</h1><blockquote>
<p>最终是使用ImageIO方法进行验证码的绘制。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&#123;&quot;/ran/random&quot;&#125;)</span><br><span class="line">    public void genericRandomCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;private,no-cache,no-store&quot;);</span><br><span class="line">        response.setContentType(&quot;image/png&quot;);</span><br><span class="line">        byte width = 85;</span><br><span class="line">        byte height = 28;</span><br><span class="line">        BufferedImage image = new BufferedImage(width, height, 2);</span><br><span class="line">        Graphics2D g = image.createGraphics();</span><br><span class="line">        g.setComposite(AlphaComposite.getInstance(3, 1.0F));</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        g.setColor(new Color(231, 231, 231));</span><br><span class="line">        g.fillRect(0, 0, width, height);</span><br><span class="line">        g.setFont(new Font(&quot;Microsoft YaHei&quot;, 2, 24));</span><br><span class="line">        String sRand = &quot;&quot;;</span><br><span class="line">        for(int responseOutputStream = 0; responseOutputStream &lt; 4; ++responseOutputStream) &#123;</span><br><span class="line">            String rand = String.valueOf(random.nextInt(10));</span><br><span class="line">            sRand = sRand + rand;</span><br><span class="line">            g.setColor(new Color(121, 143, 96));</span><br><span class="line">            g.drawString(rand, 13 * responseOutputStream + 16, 23);</span><br><span class="line">        &#125;</span><br><span class="line">        g.dispose();</span><br><span class="line">        ServletOutputStream var12 = response.getOutputStream();</span><br><span class="line">        ImageIO.write(image, &quot;png&quot;, var12);</span><br><span class="line">        var12.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for循环里面控制了一下随机数的位数，这里为4位。</li>
</ul>
<p>通过以上方法，实现了随机校验码。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图形验证码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot整合UEditor]]></title>
      <url>/2018/02/05/SpringBoot%E6%95%B4%E5%90%88UEditor/</url>
      <content type="html"><![CDATA[<blockquote>
<p>当前开发项目涉及到富文本框，了解了不少富文本编辑器之后，最终决定使用度娘的UEditor。原因：功能强大，并且自带适配java后端的图片和视频上传。</p>
</blockquote>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p>不多说，上一下该项目的地址：<a href="http://ueditor.baidu.com/website/" target="_blank" rel="noopener">http://ueditor.baidu.com/website/</a><br><strong>简书不支持markdown其他站点的外链很遗憾</strong></p>
<h1 id="整合过程"><a href="#整合过程" class="headerlink" title="整合过程"></a>整合过程</h1><h2 id="后端改造"><a href="#后端改造" class="headerlink" title="后端改造"></a>后端改造</h2><p>因为项目使用的springboot框架，而UEditor对于java后端的支持仅仅是给了一个jsp文件。因此，需要对该文件进行一下处理，修改为面向springboot的统一controller。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@Transactional</span><br><span class="line">@RequestMapping(&quot;/static/common/ueditor/jsp&quot;)</span><br><span class="line">public class JSPController &#123;</span><br><span class="line">    @RequestMapping(&quot;/controller&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void getConfigInfo(HttpServletRequest request,HttpServletResponse response)&#123;</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        String rootPath = request.getSession().getServletContext()</span><br><span class="line">                .getRealPath(&quot;/&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            String exec = new ActionEnter(request, rootPath).exec();</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            writer.write(exec);</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; catch (IOException | JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所述，该项目即支持来自/static/common/ueditor/jsp/controller的上传请求了。</p>
<h2 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h2><p>在前端添加UEditor支持。即：将整个uediotr包进行项目引入，并且在使用该控件的地方进行js的导入。</p>
<ul>
<li>项目引入，我的对应代码结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-7d00396fb8eee3f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码结构.png"></li>
<li><p>页面引入，引入对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; th:src=&quot;@&#123;/static/common/ueditor/ueditor.config.js&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; th:src=&quot;@&#123;/static/common/ueditor/ueditor.all.js&#125;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化UEditor编辑器即可，下面是我的初始化参数，仅做参考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//实例化编辑器</span><br><span class="line">	var ue = UE.getEditor(&apos;&apos;+id,&#123;</span><br><span class="line">		toolbars: [</span><br><span class="line">			[</span><br><span class="line">				&apos;fontfamily&apos;, //字体</span><br><span class="line">				&apos;fontsize&apos;, //字号</span><br><span class="line">				&apos;undo&apos;, //撤销</span><br><span class="line">				&apos;redo&apos;, //重做</span><br><span class="line">				&apos;|&apos;,</span><br><span class="line">				&apos;emotion&apos;, //表情</span><br><span class="line">				&apos;forecolor&apos;, //字体颜色</span><br><span class="line">				&apos;backcolor&apos;, //背景色</span><br><span class="line">				&apos;bold&apos;, //加粗</span><br><span class="line">				&apos;underline&apos;, //下划线</span><br><span class="line">				&apos;strikethrough&apos;, //删除线</span><br><span class="line">				&apos;|&apos;,</span><br><span class="line">				&apos;justifyleft&apos;, //居左对齐</span><br><span class="line">				&apos;justifyright&apos;, //居右对齐</span><br><span class="line">				&apos;justifycenter&apos;, //居中对齐</span><br><span class="line">				&apos;|&apos;,</span><br><span class="line">				&apos;link&apos;, //超链接</span><br><span class="line">				&apos;unlink&apos;, //取消链接</span><br><span class="line">				&apos;simpleupload&apos;, //单图上传</span><br><span class="line">				&apos;insertimage&apos;, //多图上传</span><br><span class="line">				//&apos;music&apos;, //音乐</span><br><span class="line">				//&apos;insertvideo&apos;, //视频</span><br><span class="line">				&apos;removeformat&apos;, //清除格式</span><br><span class="line">				&apos;formatmatch&apos;, //格式刷</span><br><span class="line">				&apos;source&apos;, //源代码</span><br><span class="line">			]</span><br><span class="line">		],</span><br><span class="line">		enableAutoSave:false,</span><br><span class="line">		autoHeightEnabled: true,</span><br><span class="line">		autoFloatEnabled: true,</span><br><span class="line">		initialFrameWidth:width,</span><br><span class="line">		initialFrameHeight:height,</span><br><span class="line">		scaleEnabled:true//滚动条</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，访问我们的页面就会看到富文本框了。<br><strong>不过，此时会提示我们后台配置文件出错，无法实现上传功能</strong></p>
<h2 id="实现上传功能"><a href="#实现上传功能" class="headerlink" title="实现上传功能"></a>实现上传功能</h2><ul>
<li>修改config.js文件，对应的全局请求路径。该请求是为了获取config.json对应的配置数据。可以在Controller里面直接返回配置信息或者在controller里面进行json文件的读取。我这里使用的是读取配置文件的方式，使用UEditor自带的方法，文章开头已经实现，这里贴一下需要修改的请求：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-00778fe0078d9b6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>完成以上配置之后，再次加载UEditor的页面，其中上传图片的按钮即可完成图片的上传了。<br><strong>注意：如果开始调试模式，加入断点，测试加载json串的时候。会出现超时错误。暂时没从配置文件里面找到配置字段。所有，这里需要注意，假如一切配置均无问题，但是依然返回后台配置错误的话，可以把断点全部取消掉试一试。</strong></p>
<p><strong>注意：上传需要加入上传组件，此处使用fileuoload</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.3&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用servlet实现上传"><a href="#使用servlet实现上传" class="headerlink" title="使用servlet实现上传"></a>使用servlet实现上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尝试使用servlet来实现UEditor</span><br><span class="line"> *</span><br><span class="line"> * @author OnyWang</span><br><span class="line"> * @create 2018-02-05 2:40</span><br><span class="line"> **/</span><br><span class="line">@WebServlet(name = &quot;UEditorServlet&quot;, urlPatterns = &quot;/static/common/ueditor/UEditor&quot;)</span><br><span class="line">public class UEditorControllerServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding( &quot;utf-8&quot; );</span><br><span class="line">        response.setHeader(&quot;Content-Type&quot; , &quot;text/html&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        ServletContext application=this.getServletContext();</span><br><span class="line">        String rootPath = application.getRealPath( &quot;/&quot; );</span><br><span class="line"></span><br><span class="line">        String action = request.getParameter(&quot;action&quot;);</span><br><span class="line">        String result = new ActionEnter( request, rootPath+&quot;WEB-INF/classes&quot; ).exec();</span><br><span class="line">        if( action!=null &amp;&amp;</span><br><span class="line">                (action.equals(&quot;listfile&quot;) || action.equals(&quot;listimage&quot;) ) )&#123;</span><br><span class="line">            rootPath = rootPath.replace(&quot;\\&quot;, &quot;/&quot;);</span><br><span class="line">            result = result.replaceAll(rootPath, &quot;/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write( result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用servlet的方式，新建一个注解式的servlet即可。</li>
<li>需要在main方法里面加入@ServletComponentScan注解。</li>
<li>修改ueditor默认访问路径。</li>
</ul>
<p><strong>注意：springboot下面，所有的资源文件都是放在classes下面的，所有，对于路径的处理一定要加倍小心。放在增加路径web-inf/classes</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> ueditor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thymeleaf如何控制表格对于TR样式]]></title>
      <url>/2018/01/31/Thymeleaf%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E8%A1%A8%E6%A0%BC%E5%AF%B9%E4%BA%8ETR%E6%A0%B7%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>首先，吐槽一下。这个问题搞得我很无语。最后有种撞了南墙的感觉。</p>
</blockquote>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>众所周知，Thymeleaf框架的th:each标签很好用，相较于freemaker而言，更加简练。但是如果遇到，表格对应tr隔行变色的问题，就显得有些力不从心了。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div th:if=&quot;$&#123;typeList!=null &amp;&amp; typeList.size()&gt;0&#125;&quot;&gt;</span><br><span class="line">  &lt;div th:each=&quot;type,index:$&#123;typeList&#125;&quot; &gt;</span><br><span class="line">  &lt;tr th:if=&quot;$&#123;index.odd&#125;&quot; class=&quot;odd&quot;&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeId&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeName&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot;&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:window.location.href=\&apos;/admin/website/imagesPage?websiteImages.typeId=&apos;+$&#123;type.typeId&#125;+&apos;\&apos;&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;查看广告图&lt;/button&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:updateType(&apos;+$&#123;type.typeId&#125;+&apos;,this)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;修改名称&lt;/button&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:deleteType(&apos;+$&#123;type.typeId&#125;+&apos;)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">                           &lt;/td&gt;</span><br><span class="line">                       &lt;/tr&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> &lt;tr th:unless=&quot;$&#123;index.odd&#125;&quot; class=&quot;odd&quot;&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeId&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeName&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                           &lt;td align=&quot;center&quot;&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:window.location.href=\&apos;/admin/website/imagesPage?websiteImages.typeId=&apos;+$&#123;type.typeId&#125;+&apos;\&apos;&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;查看广告图&lt;/button&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:updateType(&apos;+$&#123;type.typeId&#125;+&apos;,this)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;修改名称&lt;/button&gt;</span><br><span class="line">                               &lt;button th:onclick=&quot;&apos;javascript:deleteType(&apos;+$&#123;type.typeId&#125;+&apos;)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">                           &lt;/td&gt;</span><br><span class="line">                       &lt;/tr&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>如上代码可以实现隔行变色吗？<br>答案好像不是很乐观。报错了。提示index为null。  </p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>分析代码，感觉没有问题。<br>可是，经过尝试，发现：<strong>如果th:each标签搭配tr和td出现的话，必须作用在tr之前，不可加在div上。</strong></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>将th:each标签加在tr上之后，可以直接取值index，即行状态。然后搭配th:class标签即可实现上述功能。<br>该问题折腾了整整一晚上，完全没想到会有这种操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:if=&quot;$&#123;typeList!=null &amp;&amp; typeList.size()&gt;0&#125;&quot;&gt;</span><br><span class="line">                     &lt;tr th:class=&quot;$&#123;index.odd&#125;?&apos;odd&apos;&quot; th:each=&quot;type,index:$&#123;typeList&#125;&quot;&gt;</span><br><span class="line">                         &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeId&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                         &lt;td align=&quot;center&quot; th:text=&quot;$&#123;type.typeName&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">                         &lt;td align=&quot;center&quot;&gt;</span><br><span class="line">                             &lt;button th:onclick=&quot;&apos;javascript:window.location.href=\&apos;/admin/website/imagesPage?websiteImages.typeId=&apos;+$&#123;type.typeId&#125;+&apos;\&apos;&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;查看广告图&lt;/button&gt;</span><br><span class="line">                             &lt;button th:onclick=&quot;&apos;javascript:updateType(&apos;+$&#123;type.typeId&#125;+&apos;,this)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;修改名称&lt;/button&gt;</span><br><span class="line">                             &lt;button th:onclick=&quot;&apos;javascript:deleteType(&apos;+$&#123;type.typeId&#125;+&apos;)&apos;&quot; class=&quot;ui-state-default ui-corner-all&quot; type=&quot;button&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">                         &lt;/td&gt;</span><br><span class="line">                     &lt;/tr&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Thymeleaf </tag>
            
            <tag> 表格 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis插入相关问题（insert、InsertSelective）]]></title>
      <url>/2018/01/31/MyBatis%E6%8F%92%E5%85%A5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%88insert%E3%80%81InsertSelective%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="自动生成代码insert和insertSelective的区别"><a href="#自动生成代码insert和insertSelective的区别" class="headerlink" title="自动生成代码insert和insertSelective的区别"></a>自动生成代码insert和insertSelective的区别</h1><p>自动生成的mybatis对应配置文件里面，有两个方法，分别为insert和insertSelective。这两个方法均是插入对象的方法。这里说一下两者的区别。<br>首先看一下两者代码：</p>
<ul>
<li><p>insert</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;com.cx.elearnning.model.SysSubject&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">    --&gt;</span><br><span class="line">    insert into sys_subject (SUBJECT_ID, SUBJECT_NAME, STATUS, </span><br><span class="line">      CREATE_TIME, PARENT_ID, sort</span><br><span class="line">      )</span><br><span class="line">    values (#&#123;subjectId,jdbcType=INTEGER&#125;, #&#123;subjectName,jdbcType=VARCHAR&#125;, #&#123;status,jdbcType=BIT&#125;, </span><br><span class="line">      #&#123;createTime,jdbcType=TIMESTAMP&#125;, #&#123;parentId,jdbcType=INTEGER&#125;, #&#123;sort,jdbcType=INTEGER&#125;</span><br><span class="line">      )</span><br><span class="line">  &lt;/insert&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>insertSelective</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.cx.elearnning.model.SysSubject&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">    --&gt;</span><br><span class="line">    insert into sys_subject</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line">      &lt;if test=&quot;subjectId != null&quot; &gt;</span><br><span class="line">        SUBJECT_ID,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;subjectName != null&quot; &gt;</span><br><span class="line">        SUBJECT_NAME,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        STATUS,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;createTime != null&quot; &gt;</span><br><span class="line">        CREATE_TIME,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;parentId != null&quot; &gt;</span><br><span class="line">        PARENT_ID,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sort != null&quot; &gt;</span><br><span class="line">        sort,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line">      &lt;if test=&quot;subjectId != null&quot; &gt;</span><br><span class="line">        #&#123;subjectId,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;subjectName != null&quot; &gt;</span><br><span class="line">        #&#123;subjectName,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        #&#123;status,jdbcType=BIT&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;createTime != null&quot; &gt;</span><br><span class="line">        #&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;parentId != null&quot; &gt;</span><br><span class="line">        #&#123;parentId,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;sort != null&quot; &gt;</span><br><span class="line">        #&#123;sort,jdbcType=INTEGER&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>分析</strong><br>看完代码大体上就能区分两者的区别了吧？<br>insertSelective对应的sql语句加入了NULL校验，即只会插入数据不为null的字段值。<br>insert则会插入所有字段，会插入null。</p>
<h1 id="如何在执行插入数据之后返回新增数据的ID（自增）"><a href="#如何在执行插入数据之后返回新增数据的ID（自增）" class="headerlink" title="如何在执行插入数据之后返回新增数据的ID（自增）"></a>如何在执行插入数据之后返回新增数据的ID（自增）</h1><p>这里我们需要使用几个属性，分别为：useGeneratedKeys、keyColumn、keyProperty。<br>上面所说的两个插入方法，均不会返回新增数据的ID。原因就是没有配置这三个属性。  </p>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>首先，需要配置useGeneratedKeys属性，设置为true。说明将自动生成的主键值进行了获取。<br>之后，设置keyColumn（对应数据表字段）、keyProperty（对应对象属性）。即将自动生成的主键值赋值给那个属性！<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;createSubject&quot; parameterType=&quot;com.cx.elearnning.model.SysSubject&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;SUBJECT_ID&quot; keyProperty=&quot;subjectId&quot;&gt;</span><br><span class="line">        INSERT INTO SYS_SUBJECT (</span><br><span class="line">        &lt;include refid=&quot;sys_subject_columns&quot; /&gt;</span><br><span class="line">        )</span><br><span class="line">        VALUES (</span><br><span class="line">        &lt;include refid=&quot;sys_subject_properties&quot; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>表示将自增值赋值给了sunjectId属性</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> insert </tag>
            
            <tag> insertSelective </tag>
            
            <tag> mybatis插入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学会jquery插件开发]]></title>
      <url>/2018/01/29/%E5%AD%A6%E4%BC%9Ajquery%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JQUERY插件是很多jquery开发者耳熟能详的字眼。太熟悉了！原因无他，百度的次数太多了。他解决了我们日常开发中的很多痛点。写不出漂亮的date控件怎么办？jquery插件！写不出好用的分页组件怎么办？jquery插件！图片放大器？视频播放器？统统可以jquery插件！</p>
</blockquote>
<h1 id="何为JQUERY插件？"><a href="#何为JQUERY插件？" class="headerlink" title="何为JQUERY插件？"></a>何为JQUERY插件？</h1><p>本着前人种树后人乘凉的原则，本着linux创造轮子的核心思想。jquery插件的思想应用而生。简单点说，就是代码重复利用。</p>
<h1 id="何为优秀的JQUERY插件？"><a href="#何为优秀的JQUERY插件？" class="headerlink" title="何为优秀的JQUERY插件？"></a>何为优秀的JQUERY插件？</h1><ul>
<li>低耦合<br>即尽可能的对项目代码不产生影响，可以独立运行。</li>
<li>多场景<br>可以适用于不同的场景，高效使用。</li>
</ul>
<h1 id="如何写一个JQUERY插件？"><a href="#如何写一个JQUERY插件？" class="headerlink" title="如何写一个JQUERY插件？"></a>如何写一个JQUERY插件？</h1><blockquote>
<p>我们在享受着使用轮子的便利的权利时，也要尽可能的发挥自己的光和热，创造出轮子。或者去优化一些轮子，让这些轮子质量更好跑的更快。这就要求我们对jquery插件的原理有一定的理解。</p>
</blockquote>
<p><strong>本文仅对插件做一些基础的解释，后续如何写一个优秀的插件，还需要各位在实际项目中实际联系，尽可能多的考虑实际情况，创造出优秀的轮子</strong></p>
<h2 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h2><p>编写一个插件非常简单，和我们平时新建一个js方法类似。即：新建js文件，编写js方法，导入js文件，调用js方法。参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.fn.changeStyle = function (style) &#123;</span><br><span class="line">    this.css(&quot;color&quot;,style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，完成了一个简单js插件的编写。在我们需要使用的地方，直接调取方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.testPlugin&apos;).changeStyle(&apos;red&apos;);</span><br></pre></td></tr></table></figure></p>
<p><strong>和我们平时所见JS方法有何不同呢？</strong><br>主要的不同在于fn参数。该参数其实是指明我们定义的方法作用于所有jquery对象。所有的jqery对象可以直接使用该方法。为了更好的说明情况，我们来看一下实现上面的功能，普通的JS方法是如何实现的。<br>同样，首先定义一个js方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function (obj,style) &#123;</span><br><span class="line">    obj.css(&quot;color&quot;,style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，需要在html页面里面去调取该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeStyle($(&quot;.testPlugin&quot;),&apos;red&apos;);</span><br></pre></td></tr></table></figure></p>
<p><strong>SO，大家发现不同了吗？</strong></p>
<p>对，普通的JS方法需要传入操作的jquery对象。而采用fn定义的方法不需要传入操作的jquery对象，因为他定义在了所有的jquery对象上，任何jquery对象都可以使用！</p>
<h2 id="加入JQUERY特色（链式调用）"><a href="#加入JQUERY特色（链式调用）" class="headerlink" title="加入JQUERY特色（链式调用）"></a>加入JQUERY特色（链式调用）</h2><blockquote>
<p>jquery之所以效率高，原因之一就是链式调用。何为链式调用？比如：<code>$(&#39;.testPlugin&#39;).addClass(&#39;XX&#39;).val(&#39;XX&#39;).removeClass(&#39;XX&#39;)</code>，感觉是不是很爽？</p>
</blockquote>
<p><strong>加入链式调用的方法很简单，直接将对象返回即可</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.fn.changeStyle = function (style) &#123;</span><br><span class="line">    this.css(&quot;color&quot;,style);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在调用的时候，我们就可以肆意妄为随心所欲了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.testPlugin&apos;).changeStyle(&apos;red&apos;).html(&apos;很爽&apos;);</span><br></pre></td></tr></table></figure></p>
<h2 id="对于-符号的规避"><a href="#对于-符号的规避" class="headerlink" title="对于$符号的规避"></a>对于$符号的规避</h2><p>上述JS，我用肆意妄为来概括。为何呢？因为使用了$来操作属性和变量。大家知道，在jquery里面。$符号是很吊的，几乎可以做任何事情，作用范围也是无限大。<br><strong>那么，问题来了！</strong><br>假如大家都使用$符号来定义插件，会不会引起代码内部的社会恐慌呢？答案是肯定的！假如大家定义的内部属性或者方法都叫做’iamniubi’，作用在了全局$下面，那么不得了了！你去调用该方法的时候，即便你很牛逼，jquery也蒙圈了，因为牛逼的人太多了，不知道去找哪一个好了！如何解决该问题呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function ($) &#123;</span><br><span class="line">   $.fn.changeStyle = function (style) &#123;</span><br><span class="line">        this.css(&quot;color&quot;,style);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure></p>
<p>OK，使用(function ($) {}(jQuery));将插件代码包裹起来，表示，你定义于$内的属性和方法仅仅作用于该作用域，出了该作用域即无效。<br>你走你的阳关道，我过我的独门。大家同名不同主，互不影响。</p>
<h2 id="对象传参"><a href="#对象传参" class="headerlink" title="对象传参"></a>对象传参</h2><blockquote>
<p>上面的插件方法，我们已经传入了一个参数。仅仅是一个参数，假如有无数个参数呢？我可如何是好？在方法里面定义无数个参数吗？当然可以，但是不够聪明！</p>
</blockquote>
<p>聪明的做法是怎样的呢？看以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.changeStyle = function (option) &#123;</span><br><span class="line">        this.css(&quot;color&quot;,option.colorStr).css(&quot;fontSize&quot;,option.fontSize+&quot;px&quot;);</span><br><span class="line">        //添加链式调用</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure></p>
<p>使用如下方式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;p&apos;).changeStyle(&#123;colorStr:&quot;red&quot;,fontSize:54&#125;).html(&quot;很好&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>怎么样，是不是聪明了很多？</strong><br>另外，jquery提供了一个很好用的方法：$.extend。怎样？继承！也就是说，我们可以提供默认值啊！可以让使用者不传入任何参数，就可以表现出很漂亮的效果！比如Date插件。我们不需要传入任何样式，即可出现很漂亮的插件效果了！对不对？  </p>
<p><strong>好的，在上述插件基础上，我再尝试一下升级！</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.changeStyle = function (option) &#123;</span><br><span class="line">        var defaultSetting = &#123; colorStr:&quot;green&quot;,fontSize:182&#125;;</span><br><span class="line">        var setting = $.extend(defaultSetting,option);</span><br><span class="line">        this.css(&quot;color&quot;,setting.colorStr).css(&quot;fontSize&quot;,setting.fontSize+&quot;px&quot;);</span><br><span class="line">        //添加链式调用</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure></p>
<p>默认值为绿色，182px字体！然后我使用了$.extend方法，增加了默认属性的赋值！<br><strong>这里有个问题：</strong><br>$.extend(defaultSetting,option)是将option赋值给defaultSetting，最后是<strong>option覆盖defaultSetting</strong>。<br>如此以后，我调用插件的方式如下，可以做到不传参即可实现基本功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;p&apos;).changeStyle().html(&quot;这才是最好的效果嘛！&quot;);</span><br></pre></td></tr></table></figure></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>$.extend方法和$.fn.extend方法都可以用来扩展jQuery功能，通过阅读jQuery源码我们可以发现这两个方法的本质区别，那就是$.extend方法是在jQuery全局对象上扩展方法，$.fn.extend方法是在$选择符选择的jQuery对象上扩展方法。所以扩展jQuery的公共方法一般用$.extend方法，定义插件一般用$.fn.extend方法。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Springboot里面如何定义拦截器]]></title>
      <url>/2018/01/25/Springboot%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一下子转入springboot的怀抱之后，对于之前通过xml进行的一些配置。转成完全基于注解式，可能都有些不习惯吧。此次面对一个这样的需求，计划将公用的基础信息进行查询，可以直接给页面使用。</p>
</blockquote>
<h1 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h1><p>页面使用的Thymeleaf框架，使用框架的模板，将整体页面布局进行拆分。其中，页面头作为公用的模板引入到了每一个页面。页面里面使用Thymeleaf标签进行后台动态数据的取值。这样做就会产生一个问题：即动态数据变量如何每次都获取到值？</p>
<p>总结到如下两种解决方案：</p>
<ol>
<li>使用缓存技术。之前写过一篇springboot和Ehcache集成的文章。<a href="https://www.jianshu.com/p/05f3ede0b389" target="_blank" rel="noopener">springboot整合EHCache</a>，可以参考该文章。但是，这样的话需要每一次都进行缓存的取值，比较繁琐。上次说过，使用springboot的缓存技术去查询，定义拦截器，然后每次都去查询数据库（会自动识别，第一次才会查询数据库，之后不再查询数据库）。但是，无论这种方式如何去优化，总之都要进行缓存的取值。</li>
<li>使用拦截器拦截，之后存入servlet的attribute。这样的话，公用的Thymeleaf模板直接去servlet下面取值就好了。</li>
</ol>
<blockquote>
<p>相对于第一种方案，第二种比较简洁，不必每次都去查询。可以说是，一次拦截，终身受益。针对于第二种方案，下面重点介绍一下，说一下整体的实现过程。</p>
</blockquote>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>实现思路很简单，定义拦截器，拦截我们制定的请求。之后将数据存入request。页面直接从request里面取值。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>定义拦截器</li>
</ul>
<p>这个不必多说，继承HandlerInterceptorAdapter，之后重写preHandle即可。代码如下以供参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 网站信息拦截器，将网站的基础信息进行拦截</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class LimitIntercepterForWebsite extends HandlerInterceptorAdapter&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(LimitIntercepterForWebsite.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private EduWebsiteProfileService eduWebsiteProfileService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EduWebsiteNavigateService eduWebsiteNavigateService;</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        super.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        super.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //获取配置信息</span><br><span class="line">        Map&lt;String,Object&gt; websitemap = eduWebsiteProfileService.getWebsiteProfileByType(&quot;web&quot;);</span><br><span class="line">        request.setAttribute(&quot;websitemap&quot;,websitemap);</span><br><span class="line">        Map&lt;String,Object&gt; logomap = eduWebsiteProfileService.getWebsiteProfileByType(&quot;logo&quot;);</span><br><span class="line">        request.setAttribute(&quot;logomap&quot;,logomap);</span><br><span class="line">        Map&lt;String, Object&gt; navigateMap =  eduWebsiteNavigateService.getWebNavigate();</span><br><span class="line">        request.setAttribute(&quot;navigateList&quot;,navigateMap.get(&quot;INDEX&quot;));</span><br><span class="line">        return super.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：上面定义的拦截器，需要注解为component组件</strong></p>
<ul>
<li>注解配置该拦截器</li>
</ul>
<p>这里，需要在配置类里面进行拦截器的配置，配置类定义为Configuration，同时继承WebMvcConfigurerAdapter类。重写addInterceptors方法，在该方法里面实现对指定请求的拦截。代码如下以供参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //添加拦截器</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //多个拦截器组成一个拦截器链</span><br><span class="line">        // addPathPatterns用于添加拦截规则</span><br><span class="line">        // excludePathPatterns用户排除拦截</span><br><span class="line">//        super.addInterceptors(registry);</span><br><span class="line">        registry.addInterceptor(limitIntercepterForWebsite()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里对所有的请求实现了拦截</strong></p>
<ul>
<li>在Thmeleaf框架对于的html页面，进行request变量的取值。</li>
</ul>
<p>使用内置变量httpServletRequest进行取值即可。代码如下以供参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li th:each=&quot;nav:$&#123;#httpServletRequest.getAttribute(&apos;navigateList&apos;)&#125;&quot;&gt;</span><br><span class="line">                        &lt;a th:href=&quot;$&#123;nav.url&#125;&quot; th:title=&quot;$&#123;nav.name&#125;&quot;&gt;</span><br><span class="line">                            &lt;span th:text=&quot;$&#123;nav.name&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">                        &lt;/a&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上，完成了一个在springboot下面拦截器的实现。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery+ajaxform+springboot控件实现数据更新操作]]></title>
      <url>/2018/01/19/jquery-ajaxform-springboot%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h1><p>使用springboot架构在如下图所示的界面布局中，实现数据的保存或者更新，务必需要提交到后台，如何进行成功或失败的提示呢？如果使用传统的springmvc的模式，势必要传一个页面给前端，这个页面仅仅是提示操作是否成功了！提示之后还得更新一下数据，就好比我们浏览某些网站的时候给出的一些提示<strong>操作成功，5秒后返回</strong>。<br>比较傻，客户体验也比较差劲。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-3ed542e6bb3886fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="改造历程"><a href="#改造历程" class="headerlink" title="改造历程"></a>改造历程</h1><p>使用ajax能否解决上述的问题呢？<br>答案是肯定的，点击保存之后，一个ajax请求到后台，使用ResponseBody标签，限制返回的仅仅是数据。然后根据返回的数据给出相应的提示信息就可以了。<br>传统的ajax请求数据，需要将form里面的数据重组，全部放到我们的请求体里面。如下代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type: &apos;POST&apos;,</span><br><span class="line">  url: url,</span><br><span class="line">  data: data,</span><br><span class="line">  success: success,</span><br><span class="line">  dataType: dataType</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果，我提交的form数据比较多的话，那么data就相对比较庞大了。代码比较臃肿。同时，form表单也丧失了其存在的意义了。<br>有没有一种比较优雅的方式实现form表单的ajax提交呢？当然。<br>jquery的ajaxform插件是一个比较不错的选择。  </p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul>
<li>第一步。当然是引入我们强大的插件了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;static/assets/js/jquery.form.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>该js下载，我提供一下github的地址吧：<a href="https://github.com/jquery-form/form。" target="_blank" rel="noopener">https://github.com/jquery-form/form。</a></p>
<ul>
<li>第二步。在我们想要发送请求的地方进行ajax+form请求的发送。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function insert() &#123;</span><br><span class="line">               var options = &#123;</span><br><span class="line">                   // target:        &apos;#output1&apos;,   // 用服务器返回的数据 更新 id为output1的内容.</span><br><span class="line">                   // beforeSubmit:  showRequest,  // 提交前</span><br><span class="line">                   success:       showResponse,  // 提交后</span><br><span class="line">                   //另外的一些属性:</span><br><span class="line">                   //url:       url         // 默认是form的action，如果写的话，会覆盖from的action.</span><br><span class="line">                   //type:      type        // 默认是form的method，如果写的话，会覆盖from的method.(&apos;get&apos; or &apos;post&apos;).</span><br><span class="line">                   //dataType:  null        // &apos;xml&apos;, &apos;script&apos;, or &apos;json&apos; (接受服务端返回的类型.)</span><br><span class="line">                   //clearForm: true        // 成功提交后，清除所有的表单元素的值.</span><br><span class="line">                   resetForm: false        // 成功提交后，重置所有的表单元素的值.</span><br><span class="line">                   //由于某种原因,提交陷入无限等待之中,timeout参数就是用来限制请求的时间,</span><br><span class="line">                   //当请求大于3秒后，跳出请求.</span><br><span class="line">                   //timeout:   3000</span><br><span class="line">               &#125;;</span><br><span class="line"></span><br><span class="line">               //&apos;ajaxForm&apos; 方式的表单 .</span><br><span class="line">               $(&apos;#baseForm&apos;).ajaxSubmit(options);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理一下提交后返回的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//  提交后</span><br><span class="line">          function showResponse(responseText, statusText)  &#123;</span><br><span class="line">              alert(&apos;状态: &apos; + statusText + &apos;\n 返回的内容是: \n&apos; + responseText);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后台实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/basicSave&quot;)</span><br><span class="line">   @ResponseBody</span><br><span class="line">   public String BasicSave(PointInfo pi)&#123;</span><br><span class="line">       if(!pi.getSaddress().equals(&quot;&quot;))&#123;</span><br><span class="line">           pi.setType(&quot;1&quot;);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           pi.setType(&quot;0&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int newId = pointInfoService.saveorupdate(pi);</span><br><span class="line">       return newId+&quot;&quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>逻辑自行定义</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>提交的时候一定要使用ajaxSubmit方法</li>
<li>提交的action，请求方式（post还是get）、dataType（json、xml）等默认都采用的form里面的数据，如果在参数里面进行了修改，那么就会覆盖掉。</li>
</ul>
<h1 id="后续研究"><a href="#后续研究" class="headerlink" title="后续研究"></a>后续研究</h1><h2 id="关于提示框"><a href="#关于提示框" class="headerlink" title="关于提示框"></a>关于提示框</h2><p>使用alert？我费尽心思用上了bootstrap，你这里搞一个alert出来，简直就是往一盘美味里面吐唾沫。有没有美观一点的提示框？当然，答案是肯定的！<br><strong>使用notifications插件来完成提示框的美化</strong><br>先上个效果图：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-c272e6161508a982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>导入notifications所需js和css</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script src=&quot;static/assets/plugins/notifyjs/dist/notify.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;static/assets/plugins/notifications/notify-metro.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;static/assets/plugins/notifications/notifications.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;static/assets/plugins/notifications/notification.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用接口即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.Notification.notify(&apos;success&apos;,&apos;top center&apos;, &apos;温馨提示&apos;, &apos;保存成功！&apos;);</span><br></pre></td></tr></table></figure>
<p>完毕！实现了jquery+ajaxform的表单提交过程。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> jquery </tag>
            
            <tag> ajaxform </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bootstrap的toggles开关的使用]]></title>
      <url>/2018/01/17/bootstrap%E7%9A%84toggles%E5%BC%80%E5%85%B3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>第一次使用，总结一下使用方法。</p>
</blockquote>
<ol>
<li><p>引入css</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;static/assets/plugins/toggles/toggles.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;static/assets/plugins/toggles/toggles.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">         &lt;label class=&quot;col-md-2 control-label&quot;&gt;是否联网&lt;/label&gt;</span><br><span class="line">         &lt;div class=&quot;col-md-10 control-label&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;toggle toggle-success&quot;&gt;&lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>script里面进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> $(function () &#123;</span><br><span class="line">   // Form Toggles</span><br><span class="line">   $(&apos;.toggle&apos;).toggles(&#123;on: true&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bootstrap </tag>
            
            <tag> toggles </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot整合EHCache]]></title>
      <url>/2018/01/17/springboot%E6%95%B4%E5%90%88EHCache/</url>
      <content type="html"><![CDATA[<blockquote>
<p>用户登录之后，几乎之后展示任何页面都需要显示一下用户信息。可以在用户登录成功之后将用户信息进行缓存，之后直接取缓存数据即可。  </p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>对于SpringBoot而言，内置了属于自己的缓存框架，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>如何使用该框架进行缓存，网上一大堆资料。但是绝大多数都是描述如何在service层进行缓存，之后从数据库取数据的时候直接拿缓存数据，不再进行二次查询了。<strong>但是我目前的需求仅仅是缓存登录用户，下次直接用代码取出来。而不是再调一次service方法！貌似搜到任何资料！可能大家都没遇到过吧。</strong>  </p>
<h1 id="探索方案"><a href="#探索方案" class="headerlink" title="探索方案"></a>探索方案</h1><p>在之前的项目中，曾经用到过EHcache，当然也有对应的EHCacheUtils方法。下面就说一下springboot和ehcache的整合。  </p>
<p>真实操作之后，发现整合ehcache非常简单，三步即可：</p>
<ol>
<li><p>导入maven包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;2.10.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类开启缓存机制<br><img src="http://upload-images.jianshu.io/upload_images/9493059-d304793edb7400c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li>添加ehcache配置文件，直接在resources下面新建ehcache.xml文件即可。文件配置如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;ehcache&gt;</span><br><span class="line">    &lt;cache name=&quot;objectCache&quot; maxElementsInMemory=&quot;1000&quot;&gt;&lt;/cache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h1><p>此时，springboot已经为ehcacheManager生成了一个Bean。我们在自己需要的地方直接注入即可。下面是我的简单utils文件和存数据取数据的地方，仅供参考。有不对的地方，欢迎指正。  </p>
<p>util如下，只提供set和get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class EHCacheUtils &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 设置缓存对象</span><br><span class="line">     * @param cacheManager</span><br><span class="line">     * @param key</span><br><span class="line">     * @param object</span><br><span class="line">     */</span><br><span class="line">    public static void setCache(CacheManager cacheManager,String key,Object object)&#123;</span><br><span class="line"></span><br><span class="line">        Cache cache = cacheManager.getCache(&quot;objectCache&quot;);</span><br><span class="line">        Element element = new Element(key,object);</span><br><span class="line">        cache.put(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从缓存中取出对象</span><br><span class="line">     * @param cacheManager</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Object getCache(CacheManager cacheManager,String key)&#123;</span><br><span class="line">        Object object = null;</span><br><span class="line">        Cache cache = cacheManager.getCache(&quot;objectCache&quot;);</span><br><span class="line">        if(cache.get(key)!=null &amp;&amp; !cache.get(key).equals(&quot;&quot;))&#123;</span><br><span class="line">            object = cache.get(key).getObjectValue();</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>存入缓存方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private CacheManager cacheManager;</span><br><span class="line">//部分关键代码</span><br><span class="line">EHCacheUtils.setCache(cacheManager,&quot;op&quot;,searchOP);</span><br></pre></td></tr></table></figure></p>
<p>取出缓存方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private CacheManager cacheManager;</span><br><span class="line">Operator searchOP = (Operator) EHCacheUtils.getCache(cacheManager,&quot;op&quot;);</span><br></pre></td></tr></table></figure></p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>个人觉得，springboot提供的基于注解的方式进行缓存更加适合拦截器的方式去处理。对应指定的请求均去走设置了缓存机制的service方法，该sevice会根据实际情况去直接取缓存或者查询数据库。<br>后续再做研究，可能比目前的方法更好。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> EHCache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈bootstrapvalidator(基于Thymeleaf)]]></title>
      <url>/2018/01/17/%E6%B5%85%E8%B0%88bootstrapvalidator-%E5%9F%BA%E4%BA%8EThymeleaf/</url>
      <content type="html"><![CDATA[<blockquote>
<p>因为最近开发的项目前端使用了bootstrap框架，在前台数据校验的时候就考虑了bootstrapvalidator，整体效果不错，基本上可以快速的实现校验功能。</p>
</blockquote>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://upload-images.jianshu.io/upload_images/9493059-2569766da15bf26e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前台校验.png"><br><img src="http://upload-images.jianshu.io/upload_images/9493059-5f462c227f5bae28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台数据校验.png"></p>
<h1 id="前端校验"><a href="#前端校验" class="headerlink" title="前端校验"></a>前端校验</h1><ol>
<li>导入所需css和js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;static/assets/bootstrapvalidator/css/bootstrapValidator.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;static/assets/bootstrapvalidator/js/bootstrapValidator.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所需资源可以去官方下载，嫌麻烦的话，可以直接从我提供的百度云盘进行下载：链接：<a href="https://pan.baidu.com/s/1mjhovjy" target="_blank" rel="noopener">https://pan.baidu.com/s/1mjhovjy</a> 密码：atwy</p>
<ol>
<li>进行前端校验，实现代码如下，仅供参考。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#loginForm&quot;).bootstrapValidator(&#123;</span><br><span class="line">                   submitHandler: function (valiadtor, loginForm, submitButton) &#123;</span><br><span class="line"></span><br><span class="line">                       valiadtor.defaultSubmit();</span><br><span class="line">                   &#125;,</span><br><span class="line">                   fields:&#123;</span><br><span class="line">                       username:&#123;</span><br><span class="line">                           validators:&#123;</span><br><span class="line">                               notEmpty: &#123;</span><br><span class="line">                                   message: &apos;用户名不能为空&apos;</span><br><span class="line">                               &#125;,</span><br><span class="line">                               stringLength: &#123;</span><br><span class="line">                                   /*长度提示*/</span><br><span class="line">                                   min: 4,</span><br><span class="line">                                   max: 30,</span><br><span class="line">                                   message: &apos;用户名长度必须在4到30之间&apos;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;,</span><br><span class="line">                       password:&#123;</span><br><span class="line">                           validators:&#123;</span><br><span class="line">                               notEmpty: &#123;</span><br><span class="line">                                   message: &apos;密码不能为空&apos;</span><br><span class="line">                               &#125;,</span><br><span class="line">                               stringLength: &#123;</span><br><span class="line">                                   /*长度提示*/</span><br><span class="line">                                   min: 4,</span><br><span class="line">                                   max: 30,</span><br><span class="line">                                   message: &apos;密码长度必须在4到30之间&apos;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="后台数据校验"><a href="#后台数据校验" class="headerlink" title="后台数据校验"></a>后台数据校验</h1><blockquote>
<p>这里基于Thymeleaf，点击确认的时候会将一个表单数据整体提交给后台controller，进行数据处理之后，将数据存放到modelmap里面返回给前台，前台根据具体的返回数据做出对应的校验展示。</p>
</blockquote>
<h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><p>mybatis和spring的整合，先进行service层的实现：根据登录名进行查询，能查询到则返回对象的详细信息，否则返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OperatorSereviceImpl implements OperatorSerevice&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OperatorMapper operatorMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询操作员详细信息</span><br><span class="line">     * @param op 传入的操作员查询信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Operator queryOperator(Operator op) &#123;</span><br><span class="line">        //通过username查询操作员</span><br><span class="line">        String username = op.getUsername();</span><br><span class="line">        OperatorExample example = new OperatorExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(username);</span><br><span class="line">        List&lt;Operator&gt; operatorList = operatorMapper.selectByExample(example);</span><br><span class="line">        if(operatorList!=null &amp;&amp; operatorList.size()&gt;0)&#123;</span><br><span class="line">            return operatorList.get(0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于注解的相关知识暂不多说。之后，则需要在controller层进行逻辑的处理，这里我们约定错误返回数据分为错误码和错误信息两个属性。其中错误码为1表示用户不存在，错误码为2表示密码错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/main&quot;)</span><br><span class="line">    public String main(ModelMap model, HttpServletRequest request, Operator op)&#123;</span><br><span class="line">        Operator searchOP = operatorSerevice.queryOperator(op);</span><br><span class="line">        if(searchOP==null)&#123;</span><br><span class="line">            model.put(&quot;error&quot;,&quot;该用户不存在！&quot;);</span><br><span class="line">            model.put(&quot;code&quot;,&quot;1&quot;);</span><br><span class="line">            return &quot;admin/login&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(searchOP.getPassword().equals(op.getPassword()))&#123;</span><br><span class="line">                //比较输入密码，此时表示密码正确，跳转到主页面</span><br><span class="line">                return &quot;admin/index&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                model.put(&quot;error&quot;,&quot;输入密码错误！&quot;);</span><br><span class="line">                model.put(&quot;code&quot;,&quot;2&quot;);</span><br><span class="line">                return &quot;admin/login&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="前台处理"><a href="#前台处理" class="headerlink" title="前台处理"></a>前台处理</h2><blockquote>
<p>前台需要接收modelmap里面的两个属性，在js代码里面进行属性的接收，之后直接进行数据的展示处理。</p>
</blockquote>
<ul>
<li>逻辑处理js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 登录异常信息显示</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function LoginValidator(config) &#123;</span><br><span class="line">    this.code = config.code;</span><br><span class="line">    this.message = config.message;</span><br><span class="line">    this.userName = config.userName;</span><br><span class="line">    this.password = config.password;</span><br><span class="line">    this.initValidator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0 未授权 1 账号问题 2 密码错误  3 账号密码错误</span><br><span class="line">LoginValidator.prototype.initValidator = function () &#123;</span><br><span class="line">    if (!this.code)</span><br><span class="line">        return;</span><br><span class="line">    if(this.code==0)&#123;</span><br><span class="line">        this.addPasswordErrorMsg();</span><br><span class="line">    &#125;else if(this.code==1)&#123;</span><br><span class="line">        this.addUserNameErrorStyle();</span><br><span class="line">        this.addUserNameErrorMsg();</span><br><span class="line">    &#125;else if(this.code==2)&#123;</span><br><span class="line">        this.addPasswordErrorStyle();</span><br><span class="line">        this.addPasswordErrorMsg();</span><br><span class="line">    &#125;else if(this.code==3)&#123;</span><br><span class="line">        this.addUserNameErrorStyle();</span><br><span class="line">        this.addPasswordErrorStyle();</span><br><span class="line">        this.addPasswordErrorMsg();</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addUserNameErrorStyle = function () &#123;</span><br><span class="line">    this.addErrorStyle(this.userName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addPasswordErrorStyle = function () &#123;</span><br><span class="line">    this.addErrorStyle(this.password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addUserNameErrorMsg = function () &#123;</span><br><span class="line">    this.addErrorMsg(this.userName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addPasswordErrorMsg = function () &#123;</span><br><span class="line">    this.addErrorMsg(this.password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addErrorMsg=function(field)&#123;</span><br><span class="line">    $(&quot;input[name=&apos;&quot;+field+&quot;&apos;]&quot;).parent().append(&apos;&lt;small  data-bv-validator=&quot;notEmpty&quot; data-bv-validator-for=&quot;&apos;+field+&apos;&quot; class=&quot;help-block&quot;&gt;&apos; + this.message + &apos;&lt;/small&gt;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginValidator.prototype.addErrorStyle=function(field)&#123;</span><br><span class="line">    $(&quot;input[name=&apos;&quot; + field + &quot;&apos;]&quot;).parent().addClass(&quot;has-error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用js接收modelmap数据，需要注意th:inline标签。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class="line">        var message=[[$&#123;error&#125;]];</span><br><span class="line">        var code=[[$&#123;code&#125;]];</span><br><span class="line">        if(message!=&quot;&quot;)&#123;</span><br><span class="line">            new LoginValidator(&#123;</span><br><span class="line">                code:code,</span><br><span class="line">                message:message,</span><br><span class="line">                userName:&apos;username&apos;,</span><br><span class="line">                password:&apos;password&apos;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>综上，实现了基于bootstrapvalidator和thymeleaf框架的登录校验。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Thymeleaf </tag>
            
            <tag> bootstrapvalidator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thymeleaf中js调取变量、模板化及静态资源拦截]]></title>
      <url>/2018/01/16/Thymeleaf%E4%B8%ADjs%E8%B0%83%E5%8F%96%E5%8F%98%E9%87%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%8F%8A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%A6%E6%88%AA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>公司项目，使用springboot开发，今天在后台与前台通讯过程中，发现几个问题，做简单整理，加深一下印象。</p>
</blockquote>
<h1 id="js调取变量"><a href="#js调取变量" class="headerlink" title="js调取变量"></a>js调取变量</h1><p>后台返回变量之后，在前端进行接收，之后需要在js里面对该变量继续处理，如何在js里面进行变量的接收呢？</p>
<ul>
<li>使用th:inline属性进行javascript的标记。</li>
<li>使用如下方式进行变量数据接收：[[${example}]]</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script th:inline=&quot;javascript&quot;&gt;</span><br><span class="line">        var message=[[$&#123;error&#125;]];</span><br><span class="line">        var code=[[$&#123;code&#125;]];</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意：<br>在使用script的标签的时候，一定要使用th:inline属性进行标记，否则不会引用到。</p>
<h1 id="静态资源路径"><a href="#静态资源路径" class="headerlink" title="静态资源路径"></a>静态资源路径</h1><blockquote>
<p>由于默认springmvc对所有的请求都做了拦截。因此，当我们访问一个本地静态资源的话，springmvc拦截器依旧会将请求拦截到。从而造成数据的访问失败。很显然，这不是我们希望的结果。  </p>
</blockquote>
<p>万幸的是，早在springmvc的时候就spring团队就已经给我们提供了方案。即—在配置的时候将静态资源的请求进行重新定位。两步走：  </p>
<ol>
<li>继承WebMvcConfigurerAdapter类。</li>
<li>重写addResourceHandlers方法。  </li>
</ol>
<p>在springboot里面怎么去设置呢？其实是一样的，不过，由于springboot完全基于注解，无法从web.xml里面进行配置，只能新建配置类。如下为我的配置类，仅供参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfiguration extends WebMvcConfigurerAdapter&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/admin/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意，需要加入Configuration注解，告诉spring框架这是一个配置类。<br>如上代码表示，假如收到以admin/static开头的url请求，会将该请求定位到classess/static文件夹。</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>我们在使用jsp编写前端页面的时候，会采用分模块的形式，将一个页面里面重复的头和尾部代码提取出来。使用include标签将该页面进行引入，这样做是整个页面的后期修改和完善更加的灵活。那么，对于Thymeleaf而言，存在这种神器吗？  </p>
<p>答案当然是肯定的。  </p>
<ol>
<li>使用th:fragment标签进行模板的定义</li>
<li>使用th:include标签进行模板的引入。</li>
</ol>
<p>示例代码如下：<br>mainfragment.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:fragment=&quot;top&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;chl-poster simple&quot; id=&quot;header&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面进行该模板的引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:include=&quot;mainfragment ::nav&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中，mainfragment 为引入文件名，nav为模板名。<br>需要注意：文件名需要带路径，假如mainfragment 存在上级文件夹，将文件夹路径全部写入才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:include=&quot;base/mainfragment ::nav&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring和MyBatis整合自动生成代码里面text类型坑]]></title>
      <url>/2018/01/15/Spring%E5%92%8CMyBatis%E6%95%B4%E5%90%88%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2text%E7%B1%BB%E5%9E%8B%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>Spring和MyBatis整合以后，使用自动生成代码工具生成dao和mapper配置文件，生成步骤如下（以Intelli idea为例）。</p>
<ol>
<li><p>编写生成代码配置文件generatorConfig.xml。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;classPathEntry location=&quot;D:\dev\maven\repository\mysql\mysql-connector-java\5.1.39\mysql-connector-java-5.1.39.jar&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot; defaultModelType=&quot;flat&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://localhost:3306/mycollege?characterEncoding=utf-8&quot;</span><br><span class="line">                        userId=&quot;root&quot;</span><br><span class="line">                        password=&quot;root&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line"></span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 生成模型的包名和位置  --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.cx.elearnning.model&quot;</span><br><span class="line">                            targetProject=&quot;src/main/java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- generate xml --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;/&quot;</span><br><span class="line">                         targetProject=&quot;src/main/resources/mapper&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- generate Mapper --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.cx.elearnning.dao&quot;</span><br><span class="line">                             targetProject=&quot;src/main/java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">      &lt;!--需要自动生成的表名和对应的model名--&gt;</span><br><span class="line">        &lt;table tableName=&quot;sys_user&quot; domainObjectName=&quot;SysUser&quot;&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置如下maven运行命令。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-beb480ae437a803a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="maven运行命令.png"></p>
</li>
<li>运行generatorcode即可。<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1>假如数据库表里面存在text或者blob字段。自动生成的数据库配置文件如下，会多出几个以withBlobs结尾的方法和resultMap：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--仅仅贴上不一样的部分--&gt;</span><br><span class="line">&lt;resultMap extends=&quot;BaseResultMap&quot; id=&quot;ResultMapWithBLOBs&quot; type=&quot;com.cx.elearnning.model.EduWebsiteProfile&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;result column=&quot;DESCIPTION&quot; jdbcType=&quot;LONGVARCHAR&quot; property=&quot;desciption&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectByExampleWithBLOBs&quot; parameterType=&quot;com.cx.elearnning.model.EduWebsiteProfileExample&quot; resultMap=&quot;ResultMapWithBLOBs&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">    --&gt;</span><br><span class="line">    select</span><br><span class="line">    &lt;if test=&quot;distinct&quot;&gt;</span><br><span class="line">      distinct</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    ,</span><br><span class="line">    &lt;include refid=&quot;Blob_Column_List&quot; /&gt;</span><br><span class="line">    from edu_website_profile</span><br><span class="line">    &lt;if test=&quot;_parameter != null&quot;&gt;</span><br><span class="line">      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;orderByClause != null&quot;&gt;</span><br><span class="line">      order by $&#123;orderByClause&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>假如此时查询数据或者更新数据的使用仍然使用selectByExample或者updateByExample，得到的text或者blob数据是null。  </p>
<h1 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h1><p>应该使用selectByExampleWithBLOBs或者updateByExampleWithBLOBs这两个方法。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> mybatis </tag>
            
            <tag> 自动生成代码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java扫盲（二）说equals和双等]]></title>
      <url>/2018/01/14/java%E6%89%AB%E7%9B%B2%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AF%B4equals%E5%92%8C%E5%8F%8C%E7%AD%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>请说一下equals和==的区别  </p>
</blockquote>
<p>根据我几次换工作的经验，无数次面试的经验。假如，你去面java，该问题属于必问题。那么，他们之间到底有啥区别呢？<br>先上一段代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a =1;</span><br><span class="line">int b=1;</span><br><span class="line">String c = &quot;aaa&quot;;</span><br><span class="line">String d = &quot;aaa&quot;;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">System.out.println(c==d);</span><br><span class="line">System.out.println(c.equals(d));</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下： true/true/false/true</p>
<p>跟你想象的结果是否一致呢？</p>
<h1 id=""><a href="#" class="headerlink" title="=="></a>==</h1><p>其实，==作用于基础数据类型，比如int、long、float等。<br>这些数据类型的共同点即基础数据类型。而Strng、Integer为java提供给我们的一组对象。<br>说到对象，在进行比较的时候如果使用==运算符，那么比较的就不仅仅是对象的值了，还需要比较对象的内存地址。因为上述例子中的两个string均是new出来的一个对象，也就是说对于的内存地址是不一致的，因此得到的结果是false。</p>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>equals用于比较两个对象的值，上述例子中，使用equals去比较两个对象的值，均为aaa，因此返回值为false。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>在java编码过程中，有时候需要用一个对象给另外一个对象赋值。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student a  = new Student();</span><br><span class="line">Student b = a;</span><br></pre></td></tr></table></figure></p>
<p>这时候，就把a整个赋值给了b，包括内存地址。<br>这样做的后果是，假如在其他地方对a对象进行了操作，b对象对应的也会发生改变。<br>正确做法应该是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student a  = new Student();</span><br><span class="line">Student b = new Studnet();</span><br><span class="line">b.setXXX(a.getXXX());</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> equals </tag>
            
            <tag> 双等 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础扫盲（一）字节字符和位]]></title>
      <url>/2018/01/12/java%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E5%92%8C%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h1 id="历史问题"><a href="#历史问题" class="headerlink" title="历史问题"></a>历史问题</h1><p>大家都知道计算机这东西是洋鬼子搞出来的，他的底层实现是二进制。也就是说，计算机里面，二进制，简简单单的0和1可以表示世间万物，可以创造世间万物。</p>
<blockquote>
<p>一生二，二生三，三生万物。</p>
</blockquote>
<p>不知道创造者是否参考过我大中华博大精深的文化。</p>
<h2 id="位"><a href="#位" class="headerlink" title="位"></a>位</h2><p>这里说的位就是指的二进制位了，也就是说的0或者1。他们都可以表示一位。英文名就是bit了。</p>
<h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字节其实就是一个单位，我们通过单位知道文件的大小。这就好比你上菜市场卖肉的时候问店家猪肉多少钱一斤一样，在计算机的世界里面，我们经常会问猪肉多少钱一字节。如果你知道一斤猪肉大体上有多大，够炒几个菜。那么你就大概了解一字节的文件大体上有多大，能装的下几个字儿了！<br>其实，我们平时接触的比较多的是M，K还有G。是吧？<br>其实，他们都是计量单位。字节的英文表示为byte（为什么我输入byt的时候，搜狗给我提示的避孕套呢？）。他们之间的转化关系如下：</p>
<ul>
<li>1G=1024M</li>
<li>1M=1024K</li>
<li>1K=1024byte</li>
</ul>
<p>好了，大家清楚他们之间的关系了吧？我们平时的流量套餐呢？1G？大概就是1<em>1024</em>1024=1048576KB了。假如，我们平时浏览一篇文章用20k，看一张图片用40K，听一首歌用3M，看一部电影用100M。能用多少流量，大家自己算去吧！<br>那么，字节和位之间存在关系吗？<br>当然存在，只要在计算机的世界里面出现的任何东西，都和位存在关系！<br>一个字节等于8位。就是说8个0和1的组合表示一个字节。<br>00000000    11111111  都可以表示一个字节。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符简单了！就是我们平时看到的一切字母、符号、中文、法文、日文等等。c是个字符、中也是个字符。<br>说到字符呢，就不得不说一下编码格式了。这里只说一下比较常用的编码格式，其他的编码格式，大家可以自行百度理解研究。</p>
<ol>
<li>ASCII<br>洋鬼子最早搞出来的编码格式。该编码下，一个字符需要一个字节表示，也就是说占8位。这样的话有256中0和1的组合方式，可以表示256个不同的字母。对于，英文而言就绰绰有余了。</li>
<li>UNICODE<br>显然，洋鬼子在设计ASCII码的时候没有考虑到遥远的东方，存在博大精深的文化。新华字典里面的汉字有多少个？显然256是远远不够的！那平方呢？65535？够了吧？还不够？<br>这里就说到一个网络上经常出现的一个问题，UNICODE编码里面，一个汉字占几位的问题。很多老程序员会这么说：“一个汉字占两个字节！”<br>在GBK编码里面是2个字节，但是在unicode编码里面是不对的！其实，很多时候，汉字占几个自己完全取决于编码格式。编码格式也不难写，因此对于汉字的编码有多种说法：ubuntu12.04里面一个汉字是三个字节！  </li>
</ol>
<blockquote>
<p>它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。  </p>
</blockquote>
<p>如上，unicode编码的描述。<br>就是说，在unicode编码下，一个汉字可能是2个字节，也可能是3个或者是4个字节。  </p>
<ol>
<li>utf8<br>该编码格式我们是不是经常用到呢？<br>该编码格式其实是基于unicode。确实，unicode被很多编码格式拿来做基础编码。<br>在utf8编码格式下，英文字母占一个字节，和ascii完全相同。<br>汉字或者是其他字符占1-4个字节。  </li>
</ol>
<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p>这里我们说一下java中的char类型。<br>在java中，char类型占2个字节，16位。<br>可以采取如下方式为char类型变量赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char a=&apos;a&apos;;  //任意单个字符，加单引号。</span><br><span class="line"></span><br><span class="line">char a=&apos;中&apos;;//任意单个中文字，加单引号。</span><br><span class="line"></span><br><span class="line">char a=111;//整数。0~65535。十进制、八进制、十六进制均可。输出字符编码表中对应的字符。</span><br><span class="line"></span><br><span class="line">注：只能放单个字符。</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字节 </tag>
            
            <tag> 字符 </tag>
            
            <tag> 位 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring中autowired和resource注解的区别]]></title>
      <url>/2018/01/10/spring%E4%B8%ADautowired%E5%92%8Cresource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>autowired和resource注解都可以将bean注入。<br>最大的不同之处在于：<br>autowired：</p>
<ol>
<li>该注解由spring提供。</li>
<li>该注解通过类型来查找bean。<br>resource</li>
<li>该注解由java提供。</li>
<li>该注解通过name来查找bean。</li>
</ol>
<h1 id="resource注解举例："><a href="#resource注解举例：" class="headerlink" title="resource注解举例："></a>resource注解举例：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">Test t;</span><br></pre></td></tr></table></figure>
<p>该bean注入过程如下：<br>先查找name为test的bean，如果查询不到，则会查询类型为Test的bean。<br>假如指定了name，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name=&quot;test123&quot;)</span><br><span class="line">Test t;</span><br></pre></td></tr></table></figure></p>
<p>只要此处指定了name属性，那么只会查询name为test123的bean，查询不到即查询不到，报找不到bean的错误。</p>
<h1 id="autowired注解举例"><a href="#autowired注解举例" class="headerlink" title="autowired注解举例"></a>autowired注解举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">Test t;</span><br></pre></td></tr></table></figure>
<p>查找类型为Test的bean，查询不到就会报错。<br>如果想要指定使用name查询，则需要配合Qualifier注解使用，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired @Qualifier(&quot;baseDao&quot;)</span><br><span class="line">Test t;</span><br></pre></td></tr></table></figure></p>
<p>首先查询类型为Test的bean，如果查询不到则会查询name为baseDao的bean。还查询不到，就会报错了。<br>另外，Autowired注解可以指定是否为null，使用required=false属性来指定。此时，该bean即使为null也不会报错。配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired(required=false) @Qualifier(&quot;baseDao&quot;)</span><br><span class="line">Test t;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> 注解 </tag>
            
            <tag> autowired </tag>
            
            <tag> resource </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring和springmvc的区别]]></title>
      <url>/2018/01/10/spring%E5%92%8Cspringmvc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<ul>
<li>spring是个容器，其主要特征是IOC和AOP。</li>
<li>springmvc则是mvc架构的mvc框架，主要特征是modelandview传过来的数据和页面综合体，前台可以很舒服的将页面和数据组织并展示出来。目前，该mvc框架搭配自己公司出品的Thymleaf框架，更加锋利。</li>
</ul>
<blockquote>
<p>两者同出于一个公司，不同团队。<br>随着spring的慢慢壮大，现在的spring指的是springcore包，springmvc则指的是web包。<br>spring是身体，springmvc则是身体的某个器官，springmvc是属于spring的一部分。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> springmvc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[知识焦虑的时代，我们该何去何从？]]></title>
      <url>/2018/01/10/%E7%9F%A5%E8%AF%86%E7%84%A6%E8%99%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h1 id="只有改变才能看见未来"><a href="#只有改变才能看见未来" class="headerlink" title="只有改变才能看见未来"></a>只有改变才能看见未来</h1><p>“王老师，我想改行！”<br>前段时间，一个干保险的朋友忽然联系我说道。<br>回想起该朋友至少8年的保险从业经验，我压抑住内心的震惊，问道：“你打算转行做什么？”<br>“互联网啊！”朋友的回复很快，不假思索。<br>我不知道说什么好了，短暂的失神，朋友的回复又接二连三的到来。<br>“现在是互联网时代了，我们这行业长不了！”<br>“领导们交代的任务动不动就是微信接单，互联网接单，近期还在筹划互联网系统！”<br>“王老师，王老师，在吗？我想学编程。”<br>字里行间，我感受到了朋友浓浓的焦虑。对于现在工作生活的倦怠和不满，对于未来的不安，对于不安的无所适从，没有方向。<br>“那就按照你的想法去做吧”、“你不再考虑考虑？”、“先考虑清楚了再说！”聊天界面上，我的措辞删了改，改了再删。<br>确实，我不知道如何去答复这个看起来没有方向处于知识焦虑期的朋友。<br>“先用工作闲暇时间去学习，改行的事儿先别着急下决定！”<br>思躇良久，我回答道。之后，整个人便陷入了深深的思索之中。<br>“只有改变才能看见未来！”老罗的一句话没来由的浮上心头。  </p>
<h1 id="知识焦虑的三个阶段"><a href="#知识焦虑的三个阶段" class="headerlink" title="知识焦虑的三个阶段"></a>知识焦虑的三个阶段</h1><p>朋友的处境相信是部分内心怀揣着梦想与奋斗的有志青年已经面临或者是即将面临的。<br>如何去定义这种处境，暂且称之为知识焦虑吧。<br>作为奋斗在互联网行业的小小码农的我，也经常会面临这种焦虑。比如，朋友介绍了一个价格不菲的关于项目改造的外包，谈着谈着发现自己不会这种编程语言。<br>于是，焦虑感瞬间席卷全身。对于人民币从指间流失的失落感，对于机会从身边错失的无助感兼而有之。不过，更多的是对于知识的焦虑。<br>突然之间，觉得自己要学的东西多到无法想象。用了十几年构建起来的对于自己所处领域以及所在行业的自信遭遇了滑铁卢。<br>结合自身体会，我把知识焦虑归结了三个阶段。  </p>
<ul>
<li>无感期<br>这一阶段，压根就不知道焦虑是什么感觉。从来没想过明天怎么样？后天又如何！得过且过，及时行乐。<br>多见于刚刚大学毕业的学生，当然还有一些不肯长大的中年患者（无可救药）。  </li>
<li>焦虑期<br>这一阶段，觉得自己欠缺的东西太多。需要学习的内容更多。<br>开始长大，开始想通过学习通过努力去改变去创造点什么。<br>但是，没有方向。眉毛胡子一把抓，往往什么也抓不住。<br>时间长了，觉得和无感期相比，付出了不少却什么也没得到。还不如无感期。<br>于是，又不争气的回炉了。<br>过一段时间，又开始焦虑。<br>周而复始，无限循环。  </li>
<li>成熟期<br>首先，恭喜进入这一阶段的人。可以有方向的规划自己的知识体系，并且有效的学习知识了。<br>经历了，无限循环周而复始的知识焦虑期，你得到了应有的回报。<br>得到了一种我觉得世界上最美好最伟大的一种能力。  <blockquote>
<p>自我提升，自我学习的能力。</p>
</blockquote>
</li>
</ul>
<p>三个阶段，循序渐进。区别在于第二个阶段，有些人在该阶段呆的时间长有些人呆的时间短。<br>但是，绝对会、一定会经历。如同人类的进化，没人可以避免，没人可以跨越。  </p>
<h1 id="何去何从？"><a href="#何去何从？" class="headerlink" title="何去何从？"></a>何去何从？</h1><p>在知识焦虑期，我们该何去何从？怎样才能快速稳定的度过这一个时期呢？<br>我总结了如下几个方法，不一定对任何人都适用，但是只要有一个人从中受益，我就知足了。<br>说明我洋洋洒洒码的几千字创造并产生了价值。  </p>
<blockquote>
<p>无以言表，只能偷偷一乐。  </p>
</blockquote>
<ol>
<li>自我暗示。  <blockquote>
<p>焦虑期最大的病症就是否定自己的努力。</p>
</blockquote>
</li>
</ol>
<p>程序员觉得自己用到的技术太老，不够先进。google一番，忽然发现瞬间诞生了如此多的新技术，这名词那名词的自己压根以前就没听说过。（从我的角度，其他职业参考，病症类似。）<br>于是，负面情绪就来了，觉得自己之前都在浪费时间，自己的努力都是白费了。<br>这时候，深呼吸，默念。  </p>
<blockquote>
<p>上帝不会偏袒任何虚度光阴之人，上帝不会无视任何挥洒汗水之人。</p>
</blockquote>
<p>反复默念，直到自己的心静下来。  </p>
<blockquote>
<p>做任何事，下任何决定之前，都先要让自己的心静下来。这样，才不会给自己的后悔买单。</p>
</blockquote>
<ol>
<li>写总结笔记。<blockquote>
<p>焦虑期最大的问题就是没有方向。</p>
</blockquote>
</li>
</ol>
<p>如果不能坚持每天一总结，可以一周一总结，一月一总结。<br>根据个人情况安排总结的频率，总结过多容易更加焦虑，总结过少不容易摸清自己的方向。<br>按照自己的实际情况具体而定。  </p>
<ol>
<li>和志同道合的朋友聊天。<blockquote>
<p>聊天可以舒缓自己的压力，也可以通过他人的角度找到自己的方向。</p>
</blockquote>
</li>
</ol>
<p>这里要注意，聊天对象一定要志！同！道！合！<br>还处在无感期的中年患者就不要拿出来交流了。<br>这个时候的对牛弹琴和牛给予的挖苦如同嚼砒霜，会无限延长你的知识焦虑期。<br>如果没有这种朋友，可以找我聊，我会是一个很好的倾听者。</p>
<blockquote>
<p>方法千万种，适合最重要。</p>
</blockquote>
<p>以上三种方法，是我尝试了无数种，发现对我而言最有效的方法。<br>说的再多，就不是我给大家建议，而是让大家做选择题了。<br>希望，给看过的各位起到哪怕一丁点的作用，我即心满意足。<br>预祝，尽快跨过知识焦虑期的大坑。后面即是阳关大道，有无数有趣可爱的知识，等着我们去发现去学习去掌握。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 知识焦虑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老生常谈（程序员如何赚外快）]]></title>
      <url>/2018/01/09/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%EF%BC%88%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E8%B5%9A%E5%A4%96%E5%BF%AB%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>相对而言，如今是程序员最好的时代。</p>
</blockquote>
<p>得益于天朝无与伦比的互联网发展空间和发展势头，每天产生的互联网项目是一个无法想象的量级。因此，对于渴望通过自己的努力获取一定收益的程序员而言，机会还是非常多的，前提是你够勤劳够努力。<br>无数的人已经投入互联网浪潮，后面计划进入这一行业的人也是前赴后继。通过几年的积累，博主对赚外快的方法简短说明。</p>
<ol>
<li>做网站。<br>目前是内容付费的时代，某某明星说句话得付费才能听到，写点文章得付费才能看到。某某专家录点声音，某某作家发点心灵鸡汤就能卖钱。自媒体的公众号也越发受到的追捧。反观软件行业，特别是非产品的软件，也就是我们说的第二条赚钱之路-做外包。一次做完了，源码扔电脑上，重装系统，然后没了！注意，是没了！<br>一直觉得，程序员是创造梦想和财富的人。我们每一天写的代码都应该创造出财富和价值。当然，我说的是有意义的实质性代码。然而，预期和现实大相径庭。<br>总而言之，做个资源类的网站，通过付费的形式可以进行下载。实现代码的交易，是一条不错的赚钱途径。</li>
<li>外包。<br>外包不仅仅是赚钱，同时积累资源积累人脉。目前，外包的需求量还是很大的，软件报价也是一个笑话，有人50k做有人5k就做。当然，效果肯定不一样。往往甲方是什么都不懂的一类人，不知道如何取舍。因此，他们非常着急的项目往往一而再再而三的拖着。<br>其次，大家应该知道。外包，是觉得公司报价太高才转而找小团队的无奈之选。对于一些不太富裕的甲方，对于工作室小团队的需求量越来越大。但是，他们在选择和报价的时候还是非常无奈的。差距太大，不知道如何取舍。<br>现在看来，正规的工作室越来越受到追捧。什么是，正规的工作室？有自己的服务器（最次也得是个阿里云之类的），有自己的成功案例，这是最起码的条件。<br>很多时候，客户根本就不清楚自己的需求。你给他看一个成功案例，他也许觉得恰好符合自己的要求，这样就合作订单就定下来了。<br>可是，矛盾点就在这里。绝大多数的程序员都是上班的，没时间去捣鼓自己的工作室，也不舍得去买一个服务器。<br>这样的情况造成的后果，就是正规工作室报价越来越高，慢慢的成立成了公司。散兵程序员依旧没饭吃。</li>
<li>好创意去融资。<br>怎么说呢，第三条路风险比较大。博主2017年一整年都在运作一个产品。结果，融资失败，目前正在喝西北风。</li>
<li>展示自己，然后跳槽<br>跳槽也是变相的赚外快嘛！<br>多写写技术文章，github多写点代码。把自己的工作经历整理一下（不是让你夸夸其他，整理一下近几年的项目和代码）</li>
</ol>
<p>总而言之，时间充裕并且态度勤恳的程序员，票子还是大大的有的！近期在组建团队，欢迎大牛入驻。<br>留言区留下联系方式，博主一一拜访。<br>当然，欢迎各位一起探讨该问题。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> 赚钱 </tag>
            
            <tag> 外包 </tag>
            
            <tag> 网站 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springmvc完全注解+sitemesh拦截]]></title>
      <url>/2018/01/08/springmvc%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3-sitemesh%E6%8B%A6%E6%88%AA/</url>
      <content type="html"><![CDATA[<h1 id="干掉web-xml"><a href="#干掉web-xml" class="headerlink" title="干掉web.xml"></a>干掉web.xml</h1><blockquote>
<p>基于servelet3.0，完全注解，将web.xml消灭掉。</p>
</blockquote>
<h2 id="WebApplicationInitializer代替web-xml工作"><a href="#WebApplicationInitializer代替web-xml工作" class="headerlink" title="WebApplicationInitializer代替web.xml工作"></a>WebApplicationInitializer代替web.xml工作</h2><p>基于注解的方式，在应用启动之前，使用该类去注册相关拦截器和servlet。这里主要说springmvc的注册，主要是注册dispatcherservlet，初始化web的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class WebInitializer implements WebApplicationInitializer&#123;</span><br><span class="line"></span><br><span class="line">    public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        //注册springmvc</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        ctx.setServletContext(servletContext);</span><br><span class="line">        ServletRegistration.Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;,new DispatcherServlet(ctx));</span><br><span class="line">        //拦截所有请求</span><br><span class="line">        servlet.addMapping(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">        servlet.setLoadOnStartup(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="springmvc配置"><a href="#springmvc配置" class="headerlink" title="springmvc配置"></a>springmvc配置</h2><p>通过注解的形式进行springmvc的配置，代替原始的springmvc.xml。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * springmvc的配置</span><br><span class="line"> * 注解解释为：</span><br><span class="line"> * 配置类</span><br><span class="line"> * 允许使用springmvc,启用之后会开启一些默认配置，比如ViewResolver</span><br><span class="line"> * 扫描包为com.cx.os</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">@ComponentScan(&quot;com.cx.os&quot;)</span><br><span class="line">public class SpringMvcConfig extends WebMvcConfigurerAdapter&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public InternalResourceViewResolver viewResolver()&#123;</span><br><span class="line">        //viewresolver来渲染页面</span><br><span class="line">        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();</span><br><span class="line">        //指定渲染页面路径</span><br><span class="line">        viewResolver.setPrefix(&quot;/WEB-INF/views/&quot;);</span><br><span class="line">        //指定页面格式</span><br><span class="line">        viewResolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">        //使用jstl标准进行页面的渲染</span><br><span class="line">        viewResolver.setViewClass(JstlView.class);</span><br><span class="line">        return  viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/statics/**&quot;).addResourceLocations(&quot;/WEB-INF/statics/&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到springmvc的一个渲染器和静态资源的注册。</p>
<ol>
<li><p>渲染器：主要有jstl和jsp两种，在设置viewclass之前需要设置渲染页面的路径和页面的格式，使用如下方法进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//指定渲染页面路径</span><br><span class="line">       viewResolver.setPrefix(&quot;/WEB-INF/views/&quot;);</span><br><span class="line">       //指定页面格式</span><br><span class="line">       viewResolver.setSuffix(&quot;.jsp&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态资源注册<br>springmvc默认拦截了所有页面请求，同时包括css和js文件。重写addResourceHandlers方法进行资源拦截，其中addResourceHandler为请求路径，addResourceLocations为实际路径。<br>验证静态资源是否设置成功的方式：<br>直接在浏览器访问资源文件如：localhost:8080/statics/js/jquery.js，看是否正常访问到资源。</p>
<h2 id="sitemesh拦截器"><a href="#sitemesh拦截器" class="headerlink" title="sitemesh拦截器"></a>sitemesh拦截器</h2><p>sitemesh3.0提供了基于注解的配置方式，集成ConfigurableSiteMeshFilter之后，重写applyCustomConfiguration方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;sitemesh&quot;,urlPatterns = &#123;&quot;/*&quot;&#125;)</span><br><span class="line">public class MySiteMeshFilter extends ConfigurableSiteMeshFilter&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void applyCustomConfiguration(SiteMeshFilterBuilder builder) &#123;</span><br><span class="line">        //使用decorator.jsp去装配所有的页面</span><br><span class="line">        builder.addDecoratorPath(&quot;/*&quot;,&quot;/decorator.jsp&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，webfilter取代web.xml的拦截器。而重写的applyCustomConfiguration方法里面对应的addDecoratorPath方法两个参数分别为，装饰页面和装饰模板。上面代码表示使用decorator.jsp装饰所有页面。这里需要注意一下装饰模板的路径。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>在进行maven打包的时候报错，找不到web.xml文件。通过配置pom文件解决该问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意使用maven tomcat插件的时候，该插件默认打包的web路径为webapp，将展示jsp和html文件放在webapp下面可以正常访问，放到resources下面则不能正常访问。<br>如何去配置打包属性[warSourceDirectory]，暂未找出合理方法<br>见<a href="&quot;http://tomcat.apache.org/maven-plugin-2.0/tomcat7-maven-plugin/run-mojo.html&quot;">apache官方文档</a>，这里面有讲解，暂未找到解决方案。<br>如果，你的资源文件在resources下面，那么只能使用tomcat发布或者将资源文件放到webapp下面。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> sitemesh </tag>
            
            <tag> 注解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于java环境变量]]></title>
      <url>/2018/01/05/%E5%85%B3%E4%BA%8Ejava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>目前在研究BS架构下面如何进行实现客户机的硬件调用问题。想到的方案为JNI、JNLP和JS调ocx。各种方案具体如何实现以及最终如何选择，后续进展又是如何暂不在本博文的讨论行列。本文仅仅是说一下java环境变量的问题。</p>
</blockquote>
<ul>
<li>环境变量？大哥你确定你不是在逗我？随便一个java基础的人都会啊！万年的java_home（额！这里一定得大写）、classpath和path呗！</li>
<li>确定不是逗你，如果你用的好死不死是jdk1.8的话，且听我慢慢道来。</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote>
<p>是这样，博主在探索JNI实现BS架构下的硬件调取的时候，发现了一个神奇的框架，叫做JNA！使用该框架可以优雅快速的进行java调C的功能实现。没啥好说的，只要注意一个问题就行，关于dll的路径问题！千万注意，保证dll和jdk的版本一致性（即32位jdk调取32位dll，64位jdk调取64位dll），存放位置嘛？博主建议将dll放在jdk的bin目录下即可。</p>
</blockquote>
<p>言归正传，就是基于这个问题，出现了我对jdk环境变量的十分疑惑，起初让我懵逼的有点怀疑人生了！我拿到一个32位的dll，然而我的jdk是64位，好死不死的1.8。于是，我得换啊！</p>
<ol>
<li>下载32位jdk</li>
<li>安装</li>
<li>修改环境变量（额！当时用的java_home，这里只要改一下这一个变量路径就好了，classpath和path不用管了，引用的呗！不禁为自己的机智深深的鞠了一躬）</li>
<li>我信息慢慢的输入java -version</li>
</ol>
<blockquote>
<p>神奇的事情发生了！what？竟然还是64位！</p>
</blockquote>
<p>哥们起初还是相当淡定的。有啥大不了的事儿？资深码农哪有一帆风顺的代码？容哥慢慢检查一遍环境变量，将背后的黑手一把揪出来！（博主一直将注意了放在环境变量上面，于是乎，很悲剧！）</p>
<p>郁闷了半小时，百度一下，看看有没有同病相怜的病友吧！果然，一大堆！按照一下操作步骤顺利解决，惊恐的喝了一口鸡汤。这个世界变化太快，不改变永远没有未来。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote>
<p>进入该文件夹C:\ProgramData\Oracle\Java\javapath，会发现里面有三个exe文件，这三个exe文件引发的幺蛾子。把32位的jdk的bin目录对应的三个文件进行替换，之后java -verion就看到了久违的32位了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery中prop和attr的区别]]></title>
      <url>/2018/01/03/jquery%E4%B8%ADprop%E5%92%8Cattr%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天遇到一个奇怪的问题，使用attr给多选框添加checked属性，无效果。通过浏览器查看元素，发现该属性确实已经添加上了，查找原因半天，终于找出问题。</p>
</blockquote>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给多选按钮添加选中效果，css代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.radio:checked + .radio-wrapper-cube .radio-label-cube &#123;</span><br><span class="line">    background: url(&apos;../img/loss_riskmind_checked.png&apos;);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里顺便介绍一下该css干了些什么事儿：</p>
<ol>
<li>首先是class为radio的元素，后面跟:checked表示选中的class为radio的元素。</li>
<li>后面+上一遍博客也已经做了介绍，表示兄弟元素，这里是选择兄弟元素里面class为radio-wrapper-cube的元素。</li>
<li>后面则表示子元素里面class为radio-label-cube的元素。</li>
</ol>
<p>看一下html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; style=&quot;width:10px;height:10px&quot; class=&quot;radio&quot; name=&quot;checbox&quot; id=&quot;111&quot; value=&quot;111&quot;&gt;</span><br><span class="line">&lt;div class=&quot;radio-wrapper-cube&quot;&gt;</span><br><span class="line"> &lt;label for=&quot;111&quot; class=&quot;radio-label-cube&quot; onclick=&quot;checkboxfun($(this))&quot;&gt;&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<p>重点关注圈出来的部分。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-371aa1cf1c050d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>现在呢，我加一个按钮，实现点击一下，就出现checkbox的选中效果。实现js如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#checkbutton&quot;).click(function() &#123;</span><br><span class="line">		 var maxlength = $(&quot;[name=&apos;checbox&apos;]&quot;).length;</span><br><span class="line">		var selectindex = 0;</span><br><span class="line">		var selectall = true;</span><br><span class="line">		$(&quot;[name=&apos;checbox&apos;]:checked&quot;).each(function()&#123;</span><br><span class="line"></span><br><span class="line">			selectindex++;</span><br><span class="line">			if(maxlength==selectindex)&#123;</span><br><span class="line">				selectall = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		$(&quot;[name=&apos;checbox&apos;]&quot;).attr(&quot;checked&quot;,selectall);</span><br><span class="line">			if(selectall)&#123;</span><br><span class="line">				$(&quot;[name=&apos;checbox&apos;]&quot;).parent().parent().addClass(&quot;selected&quot;);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				$(&quot;[name=&apos;checbox&apos;]&quot;).parent().parent().removeClass(&quot;selected&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里实现的功能为，点击一下全选按钮，实现全部选中的功能，上图以明身份：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-c1cb6a69c7e105ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>出现问题：<br>点击第一次会选中，之后，一直无效。</p>
<h1 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h1><p>原来问题出在这行代码上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;[name=&apos;checbox&apos;]&quot;).attr(&quot;checked&quot;,selectall);</span><br></pre></td></tr></table></figure></p>
<p>查阅资料发现，jquery在1.6之后进行了一些改动，增加了prop属性。当然，对attr属性也做了相关改动，改动如下：</p>
<ol>
<li>jQuery 1.6之前 ，.attr()方法在取某些 attribute 的值时，会返回 property 的值，这就导致了结果的不一致。从 jQuery 1.6 开始， .prop()方法 方法返回 property 的值,而 .attr() 方法返回 attributes 的值。 </li>
<li>例如, selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, 和 defaultSelected 应使用.prop()方法进行取值或赋值。 在jQuery1.6之前，这些属性使用.attr()方法取得，但是这并不是元素的attr属性。他们没有相应的属性（attributes），只有特性(property)。 </li>
</ol>
<p>相关资料见：<a href="&quot;https://m.baidu.com/from=1000953f/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%40320_1001%2Cta%40iphone_2_7.0_3_537/baiduid=05A2CB1D2D9B7B02C0F1F3CBBF89DC14/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=11572966020577836600&amp;order=3&amp;fm=alop&amp;tj=www_normal_3_0_10_title&amp;vit=osres&amp;m=8&amp;srd=1&amp;cltj=cloud_title&amp;asres=1&amp;title=.prop(">prop和attr区别API</a>%7CjQueryAPIDocumentation&amp;dict=30&amp;w_qd=IlPT2AEptyoA_yivDVKcCTpsvh0DQCVUugKDKj7&amp;tcplug=1&amp;sec=26627&amp;di=4987dc2a44416920&amp;bdenc=1&amp;tch=124.52.244.541.1.0&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IJwKM_yRJBzuglI39h47aUbBqUDzf2Sm5&amp;eqid=a09b6f478e35400&amp;qq-pf-to=pcqq.group”)</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery </tag>
            
            <tag> prop </tag>
            
            <tag> attr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJIdea如何进行项目发布（maven插件和tomcat）]]></title>
      <url>/2018/01/01/IntelliJIdea%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%EF%BC%88maven%E6%8F%92%E4%BB%B6%E5%92%8Ctomcat%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>主要介绍如何使用tomcat进行项目的发布，目前主要有两种，分别为（maven插件发布和tomcat发布）。</p>
</blockquote>
<h1 id="maven插件发布"><a href="#maven插件发布" class="headerlink" title="maven插件发布"></a>maven插件发布</h1><blockquote>
<p>个人推荐此种发布方式</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>添加tomcat插件，需要在pom文件里面进行如下配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tomcat plugin --&gt;</span><br><span class="line">     &lt;plugin&gt;</span><br><span class="line">       &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">       &lt;configuration&gt;</span><br><span class="line">         &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">         &lt;port&gt;8088&lt;/port&gt;</span><br><span class="line">         &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class="line">         &lt;url&gt;http://127.0.0.1/manager&lt;/url&gt;</span><br><span class="line">         &lt;server&gt;tomcat7&lt;/server&gt;</span><br><span class="line">         &lt;contextReloadable&gt;true&lt;/contextReloadable&gt;</span><br><span class="line">         &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt;</span><br><span class="line">         &lt;contextReloadable&gt;false&lt;/contextReloadable&gt;</span><br><span class="line">       &lt;/configuration&gt;</span><br><span class="line">     &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由上图代码可以看到，在pom文件里面可以实现端口号等基础配置。</p>
<ol>
<li>新建运行配置项<br>选择配置编辑<br><img src="http://upload-images.jianshu.io/upload_images/9493059-2ca025406d7e3cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>选择+按钮，之后选择maven，运行命令填入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat7:run</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-8528e2bdf5d5d314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>之后保存即可。<br>单击运行或者调试就可以进行相应的项目发布。</p>
<h1 id="tomcat发布"><a href="#tomcat发布" class="headerlink" title="tomcat发布"></a>tomcat发布</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>与maven插件发布方法类似，但是普通tomcat发布的方式不需要引入tomcat插件，直接新建运行配置项即可。<br>新建运行配置项的过程和之前相同，不过选择的时候需要选择tomcatserver，之后选择local，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-20b352ca57c2e431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>server配置不需要说明，选择好tomcat和jdk，配置一下端口号即可。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-d5741b18f1d19ff7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>deployment这里需要注意，单击后面的+按钮，添加发布项目。选择artifact，之后选择第二个exploded，将我们的项目导入进来。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-3b40a90e0b132625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>之后，进行项目的启动。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> tomcat </tag>
            
            <tag> IntelliJIdea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo个性化（next主题动态显示subtitle）]]></title>
      <url>/2017/12/30/hexo%E4%B8%AA%E6%80%A7%E5%8C%96%EF%BC%88next%E4%B8%BB%E9%A2%98%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BAsubtitle%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>个人比较喜欢精彩的句子，于是希望自己的next主题博客可以在每次刷新之后显示不一样的subtitle（subtitle我就当成一个分享好句子的地方了，尴尬）。</p>
</blockquote>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><ul>
<li>第一次进入博客的效果<br><img src="http://upload-images.jianshu.io/upload_images/9493059-ee1b87cce983a5fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>刷新之后的效果<br><img src="http://upload-images.jianshu.io/upload_images/9493059-e0825602f42c5581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>再次刷新<br><img src="http://upload-images.jianshu.io/upload_images/9493059-e90858ef79db47b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>OK！事不过三，效果就展示到这里，下面说一下我是如何实现的。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><blockquote>
<p> 纯干货，因为在网络上现在还没有发现类似的效果。并且，关键问题是，我对swig不熟悉，从未接触过，我是一个后端开发人员。当然，JS还算熟悉。我实现的是后加载，可能熟悉swig的人能提供更好的方案，欢迎指正。</p>
</blockquote>
<ol>
<li>修改hexo的配置文件，主要修改subtitle，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle: 我喝过最烈的酒，也放过不该放的手。从前不会回头，往后不会将就。W人生当苦无妨，良人当归即可。W世间文字八万个，唯有情字最杀人。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>句子与句子之间以W分割，后续需要根据该标志位去拆分句子组。</p>
<ol>
<li>修改themes\next\layout_partials下面的header.swig文件。在最开头添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> function GetRandomNum(Min,Max)</span><br><span class="line">  &#123;</span><br><span class="line">    var Range = Max - Min;</span><br><span class="line">    var Rand = Math.random();</span><br><span class="line">    return(Min + Math.round(Rand * Range));</span><br><span class="line">  &#125;</span><br><span class="line">function setSidebarMarginTop (headerOffset) &#123;</span><br><span class="line">    return $(&apos;#sidebar&apos;).css(&#123; &apos;margin-top&apos;: headerOffset &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> function getHeaderOffset () &#123;</span><br><span class="line">    return $(&apos;.header-inner&apos;).height() + CONFIG.sidebar.offset;</span><br><span class="line">  &#125;</span><br><span class="line">  window.onload=function()&#123;</span><br><span class="line">    var subtitle = &quot;&#123;&#123;config.subtitle&#125;&#125;&quot;;</span><br><span class="line">     var mytitle = subtitle.split(&quot;W&quot;);</span><br><span class="line">     var max = mytitle.length-1;</span><br><span class="line">     var index = GetRandomNum(0,max);</span><br><span class="line">     var text = mytitle[index];</span><br><span class="line">     $(&quot;#helloTitle&quot;).html(text);</span><br><span class="line">     var headOffset = getHeaderOffset();</span><br><span class="line">     setSidebarMarginTop(headOffset);</span><br><span class="line">   // alert(getHeaderOffset());</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>启动一下，会发现我们的名言警句可以动态改变了。</p>
<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>主要就是获取一下配置文件里面的subtitle，这里面我们配置的是根据我们定义的规则设置的句子组。然后再网页加载完成之后，获取句子组，然后对句子组split成一个数组对象。然后我们生成一个随机数，根据随机数去获取句子就可以了。<br>一定要注意：<font color="red">随机数是介于0到数组长度减一之间，否则会数组溢出。</font></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -hexo个性化 -next主题 -名句 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器一（+号和checked）]]></title>
      <url>/2017/12/29/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%80%EF%BC%88-%E5%8F%B7%E5%92%8Cchecked%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>虽千万人而吾往矣…</p>
</blockquote>
<h1 id="号选择器"><a href="#号选择器" class="headerlink" title="+号选择器"></a>+号选择器</h1><p>该选择器是相邻兄弟选择器，什么是相邻兄弟选择器呢？<br>即—-两个元素同级别，有同一个父元素，相当于jquery的next。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul>
<li><p>css代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1 + p &#123;margin-top:50px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>html代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;This is a heading.&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is paragraph.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;This is paragraph.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;This is paragraph.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;This is paragraph.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;This is paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行效果<br><img src="http://upload-images.jianshu.io/upload_images/9493059-d7ce051fc1dbbf87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li>解释<br>body下面的h1和五个p元素为兄弟元素，他们有同一个父元素body。<br>h1+p的话仅仅是选择的其后的第一个p元素，对于其他的p元素无效。<h1 id="checked元素"><a href="#checked元素" class="headerlink" title="checked元素"></a>checked元素</h1>选择所有被选中的元素。仅仅适用于input的多选按钮和单选按钮。<br>比较常用的方式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:checked</span><br><span class="line">&#123;</span><br><span class="line">background-color: #ff0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，所有被选中的单选按钮和多选按钮都会改变背景色。</p>
<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><font color="red">该选择器仅仅适用于Opera，对于其他任何浏览器都不适用。</font>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css的+号选择器 </tag>
            
            <tag> checked选择器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JNA完成调取C接口]]></title>
      <url>/2017/12/28/%E4%BD%BF%E7%94%A8JNA%E5%AE%8C%E6%88%90%E8%B0%83%E5%8F%96C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用JNI的各位可能受够了中间层的限制严格的JNI文件（就连方法名也要限制），当然，可以使用javac和javah进行自动生成，但是依然比较繁琐。JNA框架便是基于之上，可以让开发者直接去调用C接口方法的一个框架。</p>
</blockquote>
<h1 id="调用步骤"><a href="#调用步骤" class="headerlink" title="调用步骤"></a>调用步骤</h1><h2 id="添加jna支持"><a href="#添加jna支持" class="headerlink" title="添加jna支持"></a>添加jna支持</h2><blockquote>
<p>基于maven的项目，可以在pom文件里面将jar包直接引入。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jna&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非maven项目，则可以将jar包下载下来，添加到自己的项目里面。</p>
</blockquote>
<h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><ol>
<li>将dll文件加载进JVM（使用Native属性加载）。加载方式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLibrary INSTANCE = (CLibrary) Native.loadLibrary(&quot;PR2&quot;, CLibrary.class);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.方法声明，依照dll提供的接口，声明方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public boolean CITIC_PR2_CloseComPort();</span><br><span class="line">public boolean CITIC_PR2_OpenComPort(int port, long BaudRate, char Parity, char ByteSize, char StopBits);</span><br></pre></td></tr></table></figure></p>
<p>注意：接口名和参数数量和类型一定要做到和接口文件一致，这样才可以做到正常调用。</p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>使用CLibrary直接调取即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean open()&#123;</span><br><span class="line">       boolean result = CLibrary.INSTANCE.CITIC_PR2_OpenComPort(3,9600,&apos;N&apos;,&apos;8&apos;,&apos;1&apos;);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="关于dll加载"><a href="#关于dll加载" class="headerlink" title="关于dll加载"></a>关于dll加载</h2><blockquote>
<p>比较头大的问题就是加载路径。在这之前，首先一定要搞清楚自己的dll是32位还是64位，非常关键，因为这涉及到我们采用什么样的jdk去调用的问题。实验之后，得到如下结果：32位的jdk调用32位的dll，64位jdk调用64位dll。否则会报dll无法找到的错误。</p>
</blockquote>
<h2 id="关于dll存放位置"><a href="#关于dll存放位置" class="headerlink" title="关于dll存放位置"></a>关于dll存放位置</h2><blockquote>
<p>个人建议32位dll直接放到32位的jdk目录下面的bin文件夹。64位放到64位的jdk目录的bin文件夹。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> JNA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IntelliJIDEA编写JAVASWING]]></title>
      <url>/2017/12/28/%E4%BD%BF%E7%94%A8IntelliJIDEA%E7%BC%96%E5%86%99JAVASWING/</url>
      <content type="html"><![CDATA[<blockquote>
<p>java Swing程序，之前在eclipse编写，没用过编辑器，切换到IntelliIDEA之后，一次偶然机会，需要写一个JNA的本地调用程序，使用其编辑器之后，觉得非常好用，特总结一下，简单说明如何使用。</p>
</blockquote>
<h1 id="新建设计器"><a href="#新建设计器" class="headerlink" title="新建设计器"></a>新建设计器</h1><p>新建文件，new一个GUI的Form，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-5a18e0aaa41d732a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="设计器解释"><a href="#设计器解释" class="headerlink" title="设计器解释"></a>设计器解释</h1><ol>
<li>此时得到一个设计界面，其中主要有如下三部分，左边为组件属性栏，中间为设计界面，右边为组件栏。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-0454fc3b280879b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>拖动组件栏的组件，将其放到中间的设计界面即可。</li>
<li>点击设计界面的任意组件，在组件属性栏均可以看到该组件的属性。其中fieldname可以设置组件的ID，text可以设置显示内容。两个align属性可以设置组件布局方式。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-4da906c4d98d1ed3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h1 id="代码自动完成"><a href="#代码自动完成" class="headerlink" title="代码自动完成"></a>代码自动完成</h1></li>
<li>设计完成之后，可以在java类里面按下alt+insert键进行代码的自动插入，选择FormMain即可。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-f6ef52b19daa2431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li><p>自动生成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = new JFrame(&quot;TestJNAForm&quot;);</span><br><span class="line">frame.setContentPane(new TestJNAForm().jpanel);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.pack();</span><br><span class="line">frame.setVisible(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给组件绑定事件方式，右键指定组件，选择createlistener或者在选中组件的时候，按下ctrl+o键，在弹出的事件列表里面选择自己需要创建的事件，之后会自动生成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">close.addMouseListener(new MouseAdapter() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line">              jna.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="控制弹出swing窗口大小，在main方法里面添加如下代码，可以设置大小及弹出位置："><a href="#控制弹出swing窗口大小，在main方法里面添加如下代码，可以设置大小及弹出位置：" class="headerlink" title="控制弹出swing窗口大小，在main方法里面添加如下代码，可以设置大小及弹出位置："></a>控制弹出swing窗口大小，在main方法里面添加如下代码，可以设置大小及弹出位置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame.setSize(600,500);</span><br><span class="line">frame.setPreferredSize(new Dimension(600,500));</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJIDEA </tag>
            
            <tag> JAVASWING </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[intellijidea新建springboot项目]]></title>
      <url>/2017/12/26/intellijidea%E6%96%B0%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>之前使用SpringBoot+Thymleaf+mybatis为架构做了一个简单的网站，一段时间之后，再次使用intellijidea搭建框架竟然生疏到想不起来怎么做，特此，记录一遍，希望下次能够666的完成。</p>
</blockquote>
<h1 id="新建步骤"><a href="#新建步骤" class="headerlink" title="新建步骤"></a>新建步骤</h1><ol>
<li>新建项目project，选择springinitializr，选择next，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-dc51a04e212d69c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>默认为maven构建，填入相关数据即可，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-cd0f87cbcb483a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>选择使用框架，这里选择core里面的devtools，可以实现热部署。选择前端框架Thymleaf。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-18fe71ece2a15211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="devtools.png"><br><img src="http://upload-images.jianshu.io/upload_images/9493059-5771be29efadb88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thymleaf.png"></li>
<li>点击完成。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-f55148f58f7abf30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>新建controller包，新建测试类TestController.jar<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String test(Model model, HttpServletRequest request)&#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在resources下面的templates下面新建index.html<br>浏览器输入localhost:8080,看一下是否正常显示页面。</p>
<h1 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h1><p>修改默认端口号，修改配置文件application.properties：<br><code>server.port=80</code></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> intellijidea </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[intellijidea常用maven命令]]></title>
      <url>/2017/12/26/intellijidea%E5%B8%B8%E7%94%A8maven%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>常用的几个maven命令记录如下，作为备忘。</p>
</blockquote>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li><p>上传jar包到本地仓库，以阿里支付为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install:install-file -D groupId=com.alipay -D artifactId=sdk-java -D version=20171201160035 -D packaging=jar -D file=d:/alipay-sdk-java20171201160035.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包本地文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis自动生成代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-generator:generate -e</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol>
<li>单击右上角的下拉框，进行命令的编辑<br><img src="http://upload-images.jianshu.io/upload_images/9493059-548227d851268a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>进入编辑页面，点击左上角的加号，新增一个maven命令<br><img src="http://upload-images.jianshu.io/upload_images/9493059-865abc5d423539cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>name写入自己定义的名字，commandline里面写入maven命令，点击保存即可。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-2b7accd992edc80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> intellijidea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css解释及chrome使用详解]]></title>
      <url>/2017/12/24/css%E8%A7%A3%E9%87%8A%E5%8F%8Achrome%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简单的说一下CSS，这对入门者而言会有用，CSS大拿们见笑。</p>
</blockquote>
<h1 id="CSS解释"><a href="#CSS解释" class="headerlink" title="CSS解释"></a>CSS解释</h1><h2 id="html和css是如何建立联系的？"><a href="#html和css是如何建立联系的？" class="headerlink" title="html和css是如何建立联系的？"></a>html和css是如何建立联系的？</h2><blockquote>
<p>这一点很重要，做任何事情之前都要明确问题的关键点。做开发更是如此，不去思考，对事情的来龙去脉不去深入理解，写再多代码也是枉然。</p>
</blockquote>
<h3 id="css文件不是必须的。"><a href="#css文件不是必须的。" class="headerlink" title="css文件不是必须的。"></a>css文件不是必须的。</h3><p>我们完全可以把样式写到html里面，比如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:100%;color:red&quot;&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>div的样式是可以完成通过style标签去定义的。那么，我们为什么要使用css文件来“画蛇添足”呢？初学者肯定觉得不可思议，写到一个html文件里面多好？省事，方便，也不会出现诸如文件未找到之类的错误。<br>其实，随着我们后续接触项目，慢慢就会发现这其中的奥妙了。</p>
<h3 id="使用css文件的优点"><a href="#使用css文件的优点" class="headerlink" title="使用css文件的优点"></a>使用css文件的优点</h3><p>诸位可以设想一下这样的场景，我有100个html网页，其中顶部的样式完全一样，比如均使用类似百度的样式，右上角的按钮排列样式。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-f5d2da8bfcc3b5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我有100个网页，每个网页里面我都需要去添加style吗？就算是复制粘贴也能把人累死。<br>更严重的是，假如后续我改了样式，那么我是不是需要改100遍html网页呢？想想都头大。为了解决这个问题，css文件就应运而生了。我只要这般写网页就可以了：<code>&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</code>，在css文件里面定义test样式就可以了：<code>.test{width:100%;}</code>。<br>如果有一天，客户彪了，提出了新的需求，要求width全部改成50%，我们只需要改一下css文件就好了：<code>.test{width:50%}</code><br>综上，css文件的好处显而易见：</p>
<ol>
<li>消灭重复代码</li>
<li>修改需求方便</li>
</ol>
<h3 id="html和css建立联系"><a href="#html和css建立联系" class="headerlink" title="html和css建立联系"></a>html和css建立联系</h3><blockquote>
<p>废话落落了那么多，具体是如何建立联系的呢？</p>
</blockquote>
<ol>
<li>使用link标签将css文件引入进来</li>
<li>css文件里面定义样式</li>
<li>html里面使用样式</li>
</ol>
<h2 id="css定义样式的方式"><a href="#css定义样式的方式" class="headerlink" title="css定义样式的方式"></a>css定义样式的方式</h2><h3 id="class定义"><a href="#class定义" class="headerlink" title="class定义"></a>class定义</h3><p>.定义法，在css文件使用<code>.样式名{}</code>的形式来定义样式，在html里面则使用<code>class=&#39;样式名&#39;</code>来引入样式</p>
<h3 id="id定义法"><a href="#id定义法" class="headerlink" title="id定义法"></a>id定义法</h3><p>‘#定义法’，在css文件里面使用<code>#样式名{}</code>的形式来定义样式，在html里面则使用<code>id=&#39;样式名&#39;</code>来引入样式</p>
<h3 id="标签定义法"><a href="#标签定义法" class="headerlink" title="标签定义法"></a>标签定义法</h3><p>标签名定义法，如<code>div{width:100%}</code>或者<code>input{width:100%}</code>，以html标签直接定义，之后只要通过link将文件成功引入，那么对应的所有的标签都会使用该样式。</p>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><blockquote>
<p>一定要记得在样式名中间加空格，非常重要。否则就引用不到。</p>
</blockquote>
<p>通过了解上文说的定义样式的方式，相信这里就非常好理解了，举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.a .b .c &#123;</span><br><span class="line">这里表示样式a之下样式b之下样式c的样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的html应该这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;a&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;b&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;c&quot;&gt;</span><br><span class="line">      其中的元素会使用css里面的样式</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;aaaa&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;b&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;c&quot;&gt;</span><br><span class="line">      这里面的元素则不会使用css里面的样式</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure></p>
<p>假如，我的css文件这样写，就会全部生效了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.c&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，我可以混合样式的定义方式使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.a #abc&#123;&#125;</span><br><span class="line">.a div&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="chrome的使用"><a href="#chrome的使用" class="headerlink" title="chrome的使用"></a>chrome的使用</h1><blockquote>
<p>chrome是html的神器了，可以即时的修改css，查看样式，同时还可以调试脚本，好用的一塌糊涂。</p>
</blockquote>
<h2 id="f12"><a href="#f12" class="headerlink" title="f12"></a>f12</h2><p>按一下f12键，一切网页无法遁形：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-64be5096ee89e03e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>介绍一个各个功能栏</p>
<h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h3><p>这里可以查看到所有的元素：<br>鼠标滑到每一个标签，左侧的网页都会高亮显示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-f84b00a847393331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>同时我们还可以看到css：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-e238d6aa021569ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>红框框起来的地方为css，当然，我们可以修改css，左侧实时就显示出效果了，比如，我们把float浮动效果去掉：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-5d64f6ffbe1f4c3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>是不是变得不一样了？</p>
<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>此为控制台，主要打印日志，js日志可以从这里打印出来。报错信息也可以打印出来：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-8f20fd5df3995c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我修改一下css引用路径：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-ece82cc007deab4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>再打开网页，在控制台就报错了：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-70442524420519e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>报错信息为：无法加载文件，错误在第五行。</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>此为资源展示界面，可以在该界面进行js的调试。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-840d2a639ef6a4dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>比如，我在第七行加一个断点，f5刷新之后，程序会在第七行停止，然后等待我们去执行。<br>左下方的两个常用按钮为跳到下一个断点，和跳到下一行。假如我们定义了两个断点，第一个按钮点击之后就会到下一个断点。第二个按钮则会到下一行。</p>
<p>简单说这些，希望对初学者有帮助。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Chrome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小王子的眼泪]]></title>
      <url>/2017/12/24/%E5%B0%8F%E7%8E%8B%E5%AD%90%E7%9A%84%E7%9C%BC%E6%B3%AA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>如果有人爱上了一朵花，天上的星星有亿万颗，而这朵花只长在其中一颗上，这足以让他在仰望星空时感到很快乐。他会告诉自己：在星空的某处有我的花。但如果绵羊把花吃掉了，对他来说就等于所有的星星突然熄灭了！</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/9493059-745d1224d54ab1b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="世界上属于我的花.png"></p>
<p>我仿佛看到了一个孩子在低声的倾诉，没有咆哮，没有眼泪甚至没有大声呼喊，只是低声的诉说。却足以让任何听到他声音的人动容。我印象中的小王子，一定有一双清澈如水的眼睛，一定要有从容的气质。他说话的时候一脸的认真，并且肯定注视着对方的眼睛，一眨不眨。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-6fcd60601d2d68c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="梵高的星空.png"></p>
<p>忽然想到了前几天看的至爱梵高，很难想象，全世界都无法理解自己时候的孤苦无依。特别是，周围熙熙攘攘，全部都是人，但好像又全都不是人。全都是怪物，无法理解自己的怪物。全世界的星星全部熄灭了，恰好又让自己一个人看到了，大概就是这种心情吧。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-71011e89b6c94ede.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每个人心中都拥有属于自己的烟花.png"></p>
<p>2017年很快就要过去了，对我这种人而言需要刻骨铭心去记住的事情不多。无非是2016年傲寒的降生，2017年傲寒又长了一岁罢了。再让我感到心情好一点的就是2016年可以枕着《大鱼海棠》和《你的名字》安静的去怀念，2017年可以拥抱着《至爱梵高》和《烟花》努力的去感同身受，之后又努力的让全世界的星星再次点亮吧。<br>2018，抬头仰望星空的时候一定要很快乐，一定要记得微笑。  </p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -小王子 -至爱梵高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot在Ubuntu下以服务方式启动]]></title>
      <url>/2017/12/23/SpringBoot%E5%9C%A8Ubuntu%E4%B8%8B%E4%BB%A5%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用springboot+thymleaf开发了一个小网站，计划布到Ubuntu的系统下。如果采用java -jar的方式启动，关掉远程之后，网站随之关闭。需要采用服务的方式在后台启动。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><blockquote>
<p>见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment-install.html" target="_blank" rel="noopener">官网介绍</a></p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ol>
<li>在pom文件中加入如下描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">            &lt;executable&gt;true&lt;/executable&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ol>
<li>打包为jar包并上传到远程服务器Ubuntu系统。</li>
<li>创建连接，使用ln -s命令，具体如下：<br><code>sudo ln -s 【jar路径】 /etc/init.d/myapp</code></li>
<li>启动程序即可<code>service myapp start</code><br>上述步骤即可完成服务的发布和启动，常用命令为start启动，stop终止，restart重启。<br>但是，遗憾的是，在Ubuntu的环境下，上述命令并没有正常执行。尝试直接启动jar，使用如下方式：<br><code>【jar包路径】start</code><br>提示，权限不足，给该jar包赋予权限，使用如下命令：<br><code>chmod 777 【jar包路径】</code><br>再次启动，可以正常启动。注意，这里启动的依旧非后台方式。使用如下命令完成服务的后台启动、终止和重启。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/myapp start</span><br><span class="line">sudo /etc/init.d/myapp stop</span><br><span class="line">sudo /etc/init.d/myapp restart</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 服务 </tag>
            
            <tag> 启动 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot进行日志配置]]></title>
      <url>/2017/12/23/SpringBoot%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="SpringBoot进行日志配置"><a href="#SpringBoot进行日志配置" class="headerlink" title="SpringBoot进行日志配置"></a>SpringBoot进行日志配置</h1><p>默认情况下，springBoot使用Logback作为日志框架。</p>
<ol>
<li>采用如下的方式进行日志级别的配置：<br><code>logging.level.org.springframework.web=DEBUG</code></li>
<li>采用如下方式设置日志输出目录：<br><code>logging.file=d:/myfile/log.log</code><br>如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-494792ead915ddd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h1 id="mybatis进行日志配置"><a href="#mybatis进行日志配置" class="headerlink" title="mybatis进行日志配置"></a>mybatis进行日志配置</h1><blockquote>
<p>同时，这里总结一下mybatis如何控制控制台打印SQL语句，这里以log4j为日志框架为例，并且这里说的是传统方式进行日志文件的配置，非springBoot方式。</p>
</blockquote>
</li>
</ol>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender    </span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout    </span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n      </span><br><span class="line">log4j.logger.java.sql.ResultSet=INFO    </span><br><span class="line">log4j.logger.org.apache=INFO    </span><br><span class="line">log4j.logger.java.sql.Connection=DEBUG    </span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG    </span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger = $&#123;log.level&#125;,Console,default,allfile  </span><br><span class="line">log4j.logger.com.ibatis=debug  </span><br><span class="line">log4j.logger.java.sql=debug  </span><br><span class="line">log4j.logger.com.sf.egmas.dcn.web.mapper=debug</span><br></pre></td></tr></table></figure>
<h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=info,debug,stdout,info,error  </span><br><span class="line">  </span><br><span class="line">#ibatis logger config  </span><br><span class="line">log4j.logger.com.ibatis=debug  </span><br><span class="line">log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug  </span><br><span class="line">log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug  </span><br><span class="line">log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug  </span><br><span class="line">log4j.logger.java.sql.Connection=debug  </span><br><span class="line">log4j.logger.java.sql.Statement=debug  </span><br><span class="line">log4j.logger.java.sql.PreparedStatement=debug</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot - 日志 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thymleaf使用th:each遍历]]></title>
      <url>/2017/12/22/Thymleaf%E4%BD%BF%E7%94%A8th-each%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用该标签完成list或map数据的遍历</p>
<h1 id="后台传参"><a href="#后台传参" class="headerlink" title="后台传参"></a>后台传参</h1><p>标准的springmvc传参的方式，见如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/gwview.html&quot;,method = RequestMethod.GET )</span><br><span class="line">	public String gwview(ModelMap modelMap, HttpServletRequest request) &#123;</span><br><span class="line">      modelMap.put(&quot;gwlist&quot;, gwlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>使用modelmap，将数据put进去即可。</p>
<h1 id="前台展示"><a href="#前台展示" class="headerlink" title="前台展示"></a>前台展示</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;weui-cell weui-media-box_appmsg&quot;  th:each=&quot;gw,gwstate:$&#123;gwlist&#125;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;weui-media-box__bd&quot;&gt;</span><br><span class="line">         &lt;h4 class=&quot;weui-media-box__title&quot; th:text=&quot;$&#123;gw.name&#125;&quot;&gt;&lt;/h4&gt;</span><br><span class="line">              &lt;p class=&quot;weui-media-box__desc&quot;&gt;发布人：&lt;span&gt;name&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;search-status&quot;&gt;</span><br><span class="line">         &lt;h4 class=&quot;weui-media-box__title&quot; th:text=&quot;$&#123;#dates.format(gw.createTime,&apos;yyyy-MM-dd&apos;)&#125;&quot;&gt;2017-09-09&lt;/h4&gt;</span><br><span class="line">           &lt;p class=&quot;weui-media-box__desc green&quot; th:text=&quot;$&#123;gwstate.first&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p>在需要重复的地方需要加入th:each标签，注意里面两个参数gw,gwstate，目前第一个gw是定义的list里面的每一个对象，gwstate则是对象参数，注意第二个参数是thymleaf定义的，规定了如下几个参数：</p>
<ul>
<li>index:当前迭代对象的index（从0开始计算）<ul>
<li>count: 当前迭代对象的index(从1开始计算)</li>
<li>size:被迭代对象的大小</li>
<li>current:当前迭代变量</li>
<li>even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）</li>
<li>first:布尔值，当前循环是否是第一个</li>
<li>last:布尔值，当前循环是否是最后一个<br>当然，gw和gwstate可以自己定义名字，如果你喜欢，可以定义成fuck和fuckstate都是可以的。</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> theymleaf </tag>
            
            <tag> th-each遍历 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分体式设备方案整理]]></title>
      <url>/2017/12/22/%E5%88%86%E4%BD%93%E5%BC%8F%E8%AE%BE%E5%A4%87%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>目前分体式设备比较火爆，主要部件为底座和pad。</p>
</blockquote>
<h1 id="部件说明"><a href="#部件说明" class="headerlink" title="部件说明"></a>部件说明</h1><p>解释一下pad和底座</p>
<h2 id="pad"><a href="#pad" class="headerlink" title="pad"></a>pad</h2><p>作为手持端，平常的时候需要插到底座上面，客户办理业务的时候则可以将pad拿下来，拿在手里办理，增强了用户的体验。</p>
<h2 id="底座"><a href="#底座" class="headerlink" title="底座"></a>底座</h2><p>目前工行的方案是分层的原理，将SP的驱动做到了底座上面，驱动常用的硬件模块，包括凭条打印机、四合一读卡器、指纹仪、密码键盘、摄像头。其他模块，比如发卡机则是单独的模块没有做集成。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>目前业界比较流行的方案，也就是工行方案。主要由pad发起交易，通过蓝牙和底座进行通讯，完成基本的二代证读取、卡片信息读取、指纹校验、人脸识别、凭条打印、输入密码等基本功能。底座和pad之间经由蓝牙通讯，之后，底座去调取相关设备。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>首先蓝牙传输的速度太慢，经测试4.0的传输速度在150k左右。</li>
<li>安全性的问题，采用安卓自带的4G模块，需要配置apn和vpn以接入银行内网，这样的话相关的配置信息就存在了android系统上面，存在安全隐患。另外，如果sp做在了底座上面，那么相关的用户敏感信息势必会经过安卓系统，导致敏感信息的泄露。</li>
</ol>
<h1 id="其他方案参考"><a href="#其他方案参考" class="headerlink" title="其他方案参考"></a>其他方案参考</h1><h2 id="HUB通讯"><a href="#HUB通讯" class="headerlink" title="HUB通讯"></a>HUB通讯</h2><blockquote>
<p>pad直接去连接设备，底座不带系统，全部由pad进行硬件的调取。这样做的话，可以将网络和敏感信息类的安全问题规避掉。但是，这样做的话，会存在布线问题，pad没有那么多的U口，势必需要接HUB，然后将所有的硬件模块通过HUB和PAD串联起来。另外，如果这样去调取，实际上做成了一对一的模式，一个pad对应一套硬件设备。违背了我们设计的初衷。</p>
</blockquote>
<h2 id="4G模块"><a href="#4G模块" class="headerlink" title="4G模块"></a>4G模块</h2><blockquote>
<p>增加一个4G模块，进行网络接入，和底座的安卓系统分开。相关网络信息配置在了4G模块上面，不再留存配置信息。其他模块依然是将SP装在底座上面，保证SP的分层。PAD则通过蓝牙通讯的方式通过底座调取硬件。这样做是将网络配置信息进行了隔离，与安卓系统做到了分开。但是其他模块的敏感信息依然会保存到底座上面，无法脱敏。这样做的好处就是实现了我们一开始的一对多的设计思路。</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>业务设计的时候，一定要做到随时调取随时断开，调取完设备之后，马上将蓝牙断开。这样，其他pad才可以调取到设备。真正的实现一对多的设计思想。</p>
]]></content>
      
        <categories>
            
            <category> 方案 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分体式 </tag>
            
            <tag> 安卓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio连接夜神模拟器]]></title>
      <url>/2017/12/20/AndroidStudio%E8%BF%9E%E6%8E%A5%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
      <content type="html"><![CDATA[<ol>
<li>运行<code>-cmd</code>，进入夜神模拟器安装目录，进入目录下的bin</li>
<li>执行<code>Nox_adb.exe connect 127.0.0.1:62001</code>命令，connect左右都有空格。</li>
<li>执行命令后就可以连接到夜神模拟器。</li>
</ol>
<hr>
<blockquote>
<p>2017-12-23增加eclipse连接夜神模拟器相关信息</p>
</blockquote>
<h1 id="eclipse连接夜神模拟器注意事项"><a href="#eclipse连接夜神模拟器注意事项" class="headerlink" title="eclipse连接夜神模拟器注意事项"></a>eclipse连接夜神模拟器注意事项</h1><ul>
<li>和androidstudio方法一样</li>
<li>需要首先启动eclipse，然后再启动夜神模拟器</li>
<li>注意，如果此时启动的时候没有正常连接，可以尝试如下的操作，我使用如下的操作方法，成功的连接上了模拟器。</li>
</ul>
<blockquote>
<p>操作方法如下:</p>
</blockquote>
<ol>
<li>进入DDMS模式，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-029ddadd3af82c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DDMS模式.png"></li>
<li>单击左侧的devices栏倒三角，上图标注的位置。</li>
<li>选择reset adb</li>
<li>重复连接模拟器的步骤，即：进cmd，进入模拟器bin目录，使用命令行进行模拟器的连接。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -androidstudio -夜神模拟器 -随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[idea如何实现热部署]]></title>
      <url>/2017/12/20/idea%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>intellij idea真是让人又爱又恨，界面美观舒服，编码提示友好，开发效率高。但是最近发现一个很不爽的问题，使用springboot的时候无法实现热部署，于是乎，即使修改html一个标点符号，也得点击右上角启动。</p>
<h1 id="妥协妥协"><a href="#妥协妥协" class="headerlink" title="妥协妥协"></a>妥协妥协</h1><p>先这么将就着用吧。<br>有时候人就这样，不到逼不得已就不会做出改变。</p>
<h1 id="爆发吧"><a href="#爆发吧" class="headerlink" title="爆发吧"></a>爆发吧</h1><p>各种百度，找到如下解决方案，按照我说的步骤，必定实现热部署。</p>
<ol>
<li>确保setting compile下面的自动构建打钩，一般默认都会打钩，这里检查一遍，以防万一。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-f3af5a709a8dcde5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setting设置.png"></li>
<li>ctrl+shift+a呼出搜索界面，一定要选择     第一个，然后回车：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-49c2e08d86b20b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>找到如下图所示的选项，勾选<br><img src="http://upload-images.jianshu.io/upload_images/9493059-d3d73b4b16fffe5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>设置完成，重启intellij idea</li>
</ol>
</blockquote>
<h1 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h1><ol>
<li>修改pom配置文件，添加devtools，注意optional节点设置为true<br><img src="http://upload-images.jianshu.io/upload_images/9493059-440825eddc3dcf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>添加configuration节点<br><img src="http://upload-images.jianshu.io/upload_images/9493059-4e3b4e132669b2ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>谷歌浏览器设置一下不带缓存<br><img src="http://upload-images.jianshu.io/upload_images/9493059-1d87264f911fd81c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>设置Thymleaf不带缓存<br><img src="http://upload-images.jianshu.io/upload_images/9493059-0c3d16ea01ec05d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<blockquote>
<p>OK 我们不在妥协了，和黑暗恶势力理直气壮的说了一句NO，please遵守老子的规则。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> intellijidea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thymleaf里面如何使用onclick事件]]></title>
      <url>/2017/12/20/Thymleaf%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8onclick%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不得不说springboot+Thymleaf是一个超级开发神器。再加上mybatis自动生成，一般的小项目分分钟搞定的节奏。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>不过，最近遇到一个问题，问题如下：<br>在Thymleaf下面如何触发js的点击事件？一通百度之后，得到如下解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span th:text=&quot;$&#123;classType.classname&#125; th:onclick=&quot;&apos;javascript:test(\&apos;&apos;+$&#123;classType.id&#125;+&apos;\&apos;)&apos;&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用th:onclick标签，最终调取如下js函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test(aaa) &#123;</span><br><span class="line">        window.location.href = &quot;alllist?classid=&quot;+aaa;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上js正常写即可。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li>th:onclick之后一定要记得加javascript:，否则不会生效</li>
<li>javascript开头的要用’’包括起来。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> Thymleaf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[构建工具Gradle]]></title>
      <url>/2017/12/20/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/</url>
      <content type="html"><![CDATA[<blockquote>
<p>更严格意义上来说应该叫做：androidstudio下面的gradle介绍  </p>
<ul>
<li>敲黑板：在androidstudio的terminal命令行里面运行gradle的命令为：gradlew，比如：<code>gradlew -v</code><br><img src="http://upload-images.jianshu.io/upload_images/9493059-fdce26aa645c714b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="terminal位置.png"><h1 id="gradle的概念"><a href="#gradle的概念" class="headerlink" title="gradle的概念"></a>gradle的概念</h1></li>
<li>构建工具，使用java编程的各位应该对大名鼎鼎的maven比较熟悉，这俩干的活是一样的。</li>
<li>面向java语言<h1 id="gradle的仓库"><a href="#gradle的仓库" class="headerlink" title="gradle的仓库"></a>gradle的仓库</h1><h2 id="仓库类型及配置"><a href="#仓库类型及配置" class="headerlink" title="仓库类型及配置"></a>仓库类型及配置</h2>盗用一张图，里面有各种仓库：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-0d4b719d3da5220a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源仓库.png"><br>具体的仓库位置配置如下（app下面的build构建文件）：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-2e0623f19fcbd6a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
</blockquote>
<p>插一句，在各位使用maven的时候，将仓库地址替换成阿里云的镜像是不是快了很多？当然这里我们也可以采用和上图一样的配置使用阿里云镜像，构建过程瞬间提速有木有？</p>
<h2 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h2><ol>
<li>我们需要获取资源地址，推荐阿里云中央仓库，从此处可以搜到绝大多数的资源，<a href="http://mvnrepository.com/artifact/com.aliyun" target="_blank" rel="noopener">传送而去吧！</a></li>
<li>搜索到jar包资源之后，查看gradle构建语句：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-516ffdd6f15edad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看构建语句.png"></li>
<li>在app的build文件引入资源：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-ffc127db6237e479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>好了，可以查看到我们的资源并且使用我们的资源了。<br><img src="http://upload-images.jianshu.io/upload_images/9493059-de9158e498a50358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>瞬间变得很简单了有木有？不用抓狂的搜索资源，下载资源，然后丢到libs里面了！感谢maven，感谢gradle。</li>
</ol>
<p>荆轲刺秦王，感谢扈三娘。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排队填单一体机解决方案]]></title>
      <url>/2017/12/20/%E6%8E%92%E9%98%9F%E5%A1%AB%E5%8D%95%E4%B8%80%E4%BD%93%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p> 银行网点的人流量越来越大，办理业务人员也越来越多，办理的业务也越来越繁琐和复杂。传统的排队机和传统的填单机各自为政，已经无法处理当前需要两者协同作业的业务，随着这些业务的日渐繁多，排队填单一体机的建设逐步的被提上日程。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>各大银行网点<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1></li>
</ul>
<ol>
<li>排队</li>
<li>预填单<h1 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h1></li>
</ol>
<ul>
<li>首先是目前银行太多太杂，各自的信息化建设水平层次不同。有的银行信息化程度高，已经存在一个总行级别的管理后台，将信息做了整体汇总。代表行：工行。</li>
<li>业务各不相同，各个行对应的业务无论是复杂度还是繁琐程度各不相同。<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote>
<p>区分P、C、V端。</p>
</blockquote>
</li>
<li>V端主要进行设备的管理，设备的监控和填单模板的配置。目前bcmv系统基本可以满足要求，但是欠缺的是填单模板部分。填单模板采用uedit扩展插件，拖拽的形式进行模板的配置。最终将模板以html的格式存入到数据库之中。</li>
<li>P端主要进行报文的收发，接收C端报文，发往V端获取数据，之后将报文再反馈给C端。</li>
<li>C端主要面向客户，提供取号业务和预填单业务。主要介绍一下预填单业务。客户选择预填单模板之后，显示对应的模板界面，操作完成之后，将模板填充并打印。<blockquote>
<p>技术方案      </p>
</blockquote>
</li>
</ul>
<p>C端使用基于arm的软件架构，基于android进行软件开发。<br>需要调取如下硬件：</p>
<ol>
<li>读卡器（读取二代证和银行卡，多合一）</li>
<li>凭条打印机</li>
<li>激光打印机<br>调取驱动SP主要是基于JNI，调取C编程的底层驱动SP，达到调取硬件的目的。<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><img src="http://upload-images.jianshu.io/upload_images/9493059-85550adfaba5611f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区分开发模块.png"><h3 id="UI展示模块"><a href="#UI展示模块" class="headerlink" title="UI展示模块"></a>UI展示模块</h3>封装常用的UI控件<h3 id="报文交互模块"><a href="#报文交互模块" class="headerlink" title="报文交互模块"></a>报文交互模块</h3>进行与P端通讯，获取服务端数据<h3 id="调取硬件模块"><a href="#调取硬件模块" class="headerlink" title="调取硬件模块"></a>调取硬件模块</h3>JNI调用底层硬件库，完成硬件模块的调用<h2 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h2></li>
<li>gradle构建（组件化开发）之前一直使用maven，gradle没有仔细研究过。</li>
<li>ndk打包</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 方案 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 方案 </tag>
            
            <tag> 排队填单 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA['Hexo搭建个人博客']]></title>
      <url>/2017/12/13/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>看了一些基于hexo的博客，瞬间觉得漂亮的不像话，主要是阅读文章的时候体验比较好，右边的导航栏好用的不要不要的。上一张读博客时候的图片看一下：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-5784bac83bd519bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo效果.png"><br>于是乎，决定折腾一下。  </p>
<h1 id="Hexo的安装步骤"><a href="#Hexo的安装步骤" class="headerlink" title="Hexo的安装步骤"></a>Hexo的安装步骤</h1><ol>
<li>安装nodeJS</li>
<li>安装Hexo</li>
<li>下载喜欢的Hexo模板</li>
<li>如果是用github做服务器（或者支持markdown解析），可以直接上传md文件，如果放到自己的服务器上，就需要进行静态网页的发布，先将源代码发布为html文件，然后安装发布软件进行发布（我用的nginx，这是说明一下nginx的安装）<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2>主要介绍一下window和ubuntu的安装。<h3 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h3></li>
<li>直接从官网下载安装文件即可，可以从该网站下载所需安装包<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node中文网下载</a>。傻瓜式安装，一路next直到安装成功。</li>
<li>安装完成之后，会有一个nodejs的命令窗口，打开命令窗口，下载hexo。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/9493059-47706a8328560b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nodejs命令窗口.png"><br><img src="http://upload-images.jianshu.io/upload_images/9493059-fc6dd99b213f0128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开效果如下.png"></li>
<li>下载hexo资源<br>输入<code>npm install -g hexo</code><br>此处搞清楚了依赖关系，hexo是依赖于node的，想要安装使用hexo，必须得先安装node，之后使用npm进行hexo的安装下载。</li>
<li>初始化hexo<br>输入<code>hexo init</code><br>这样会在你当前目录下生成hexo的初始化资源，因此在执行该条语句之前，需要先cd到指定目录。</li>
<li>现在安装的hexo都是3.0版本，<font color="red">3.0版本的hexo有一个明显的改变就是把server进行了分离，安装hexo之后，还需要安装server</font>，使用如下命令进行安装即可：<code>npm install hexo-server --save</code>   </li>
<li>启动hexo<br>默认4000端口启动：<code>hexo s</code><br>指定端口启动：<code>hexo s -p 4001</code><br>不出意外，访问localhost:4000就可以看到美的冒泡的博客了吧。 <h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3>安装顺序跟上面类似，依次获取资源命令如下：<br><code>apt-get install nodejs</code><br><code>npm install -g hexo</code><br><code>hexo init</code><br><code>npm install hexo-server --save</code><br>有可能出现apt-get失败的情况，这时候将资源包进行一下更新即可：<br><code>apt-get update</code><br><code>apt-get upgrade</code><br>好了，到此为止hexo就安装完成了。下面需要美化我们的个人博客。下一遍继续更新。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
